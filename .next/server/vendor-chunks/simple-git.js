"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/simple-git";
exports.ids = ["vendor-chunks/simple-git"];
exports.modules = {

/***/ "(rsc)/./node_modules/simple-git/dist/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/simple-git/dist/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CheckRepoActions: () => (/* binding */ CheckRepoActions),\n/* harmony export */   CleanOptions: () => (/* binding */ CleanOptions),\n/* harmony export */   DiffNameStatus: () => (/* binding */ DiffNameStatus),\n/* harmony export */   GitConfigScope: () => (/* binding */ GitConfigScope),\n/* harmony export */   GitConstructError: () => (/* binding */ GitConstructError),\n/* harmony export */   GitError: () => (/* binding */ GitError),\n/* harmony export */   GitPluginError: () => (/* binding */ GitPluginError),\n/* harmony export */   GitResponseError: () => (/* binding */ GitResponseError),\n/* harmony export */   ResetMode: () => (/* binding */ ResetMode),\n/* harmony export */   TaskConfigurationError: () => (/* binding */ TaskConfigurationError),\n/* harmony export */   \"default\": () => (/* binding */ esm_default),\n/* harmony export */   gitP: () => (/* binding */ gitP),\n/* harmony export */   grepQueryBuilder: () => (/* binding */ grepQueryBuilder),\n/* harmony export */   pathspec: () => (/* binding */ pathspec),\n/* harmony export */   simpleGit: () => (/* binding */ simpleGit)\n/* harmony export */ });\n/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:buffer */ \"node:buffer\");\n/* harmony import */ var _kwsites_file_exists__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @kwsites/file-exists */ \"(rsc)/./node_modules/@kwsites/file-exists/dist/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var _kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @kwsites/promise-deferred */ \"(rsc)/./node_modules/@kwsites/promise-deferred/dist/index.js\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:events */ \"node:events\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/lib/args/pathspec.ts\nfunction pathspec(...paths) {\n  const key = new String(paths);\n  cache.set(key, paths);\n  return key;\n}\nfunction isPathSpec(path) {\n  return path instanceof String && cache.has(path);\n}\nfunction toPaths(pathSpec) {\n  return cache.get(pathSpec) || [];\n}\nvar cache;\nvar init_pathspec = __esm({\n  \"src/lib/args/pathspec.ts\"() {\n    \"use strict\";\n    cache = /* @__PURE__ */ new WeakMap();\n  }\n});\n\n// src/lib/errors/git-error.ts\nvar GitError;\nvar init_git_error = __esm({\n  \"src/lib/errors/git-error.ts\"() {\n    \"use strict\";\n    GitError = class extends Error {\n      constructor(task, message) {\n        super(message);\n        this.task = task;\n        Object.setPrototypeOf(this, new.target.prototype);\n      }\n    };\n  }\n});\n\n// src/lib/errors/git-response-error.ts\nvar GitResponseError;\nvar init_git_response_error = __esm({\n  \"src/lib/errors/git-response-error.ts\"() {\n    \"use strict\";\n    init_git_error();\n    GitResponseError = class extends GitError {\n      constructor(git, message) {\n        super(void 0, message || String(git));\n        this.git = git;\n      }\n    };\n  }\n});\n\n// src/lib/errors/task-configuration-error.ts\nvar TaskConfigurationError;\nvar init_task_configuration_error = __esm({\n  \"src/lib/errors/task-configuration-error.ts\"() {\n    \"use strict\";\n    init_git_error();\n    TaskConfigurationError = class extends GitError {\n      constructor(message) {\n        super(void 0, message);\n      }\n    };\n  }\n});\n\n// src/lib/utils/util.ts\n\n\nfunction asFunction(source) {\n  if (typeof source !== \"function\") {\n    return NOOP;\n  }\n  return source;\n}\nfunction isUserFunction(source) {\n  return typeof source === \"function\" && source !== NOOP;\n}\nfunction splitOn(input, char) {\n  const index = input.indexOf(char);\n  if (index <= 0) {\n    return [input, \"\"];\n  }\n  return [input.substr(0, index), input.substr(index + 1)];\n}\nfunction first(input, offset = 0) {\n  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;\n}\nfunction last(input, offset = 0) {\n  if (isArrayLike(input) && input.length > offset) {\n    return input[input.length - 1 - offset];\n  }\n}\nfunction isArrayLike(input) {\n  return filterHasLength(input);\n}\nfunction toLinesWithContent(input = \"\", trimmed2 = true, separator = \"\\n\") {\n  return input.split(separator).reduce((output, line) => {\n    const lineContent = trimmed2 ? line.trim() : line;\n    if (lineContent) {\n      output.push(lineContent);\n    }\n    return output;\n  }, []);\n}\nfunction forEachLineWithContent(input, callback) {\n  return toLinesWithContent(input, true).map((line) => callback(line));\n}\nfunction folderExists(path) {\n  return (0,_kwsites_file_exists__WEBPACK_IMPORTED_MODULE_1__.exists)(path, _kwsites_file_exists__WEBPACK_IMPORTED_MODULE_1__.FOLDER);\n}\nfunction append(target, item) {\n  if (Array.isArray(target)) {\n    if (!target.includes(item)) {\n      target.push(item);\n    }\n  } else {\n    target.add(item);\n  }\n  return item;\n}\nfunction including(target, item) {\n  if (Array.isArray(target) && !target.includes(item)) {\n    target.push(item);\n  }\n  return target;\n}\nfunction remove(target, item) {\n  if (Array.isArray(target)) {\n    const index = target.indexOf(item);\n    if (index >= 0) {\n      target.splice(index, 1);\n    }\n  } else {\n    target.delete(item);\n  }\n  return item;\n}\nfunction asArray(source) {\n  return Array.isArray(source) ? source : [source];\n}\nfunction asCamelCase(str) {\n  return str.replace(/[\\s-]+(.)/g, (_all, chr) => {\n    return chr.toUpperCase();\n  });\n}\nfunction asStringArray(source) {\n  return asArray(source).map((item) => {\n    return item instanceof String ? item : String(item);\n  });\n}\nfunction asNumber(source, onNaN = 0) {\n  if (source == null) {\n    return onNaN;\n  }\n  const num = parseInt(source, 10);\n  return Number.isNaN(num) ? onNaN : num;\n}\nfunction prefixedArray(input, prefix) {\n  const output = [];\n  for (let i = 0, max = input.length; i < max; i++) {\n    output.push(prefix, input[i]);\n  }\n  return output;\n}\nfunction bufferToString(input) {\n  return (Array.isArray(input) ? node_buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat(input) : input).toString(\"utf-8\");\n}\nfunction pick(source, properties) {\n  const out = {};\n  properties.forEach((key) => {\n    if (source[key] !== void 0) {\n      out[key] = source[key];\n    }\n  });\n  return out;\n}\nfunction delay(duration = 0) {\n  return new Promise((done) => setTimeout(done, duration));\n}\nfunction orVoid(input) {\n  if (input === false) {\n    return void 0;\n  }\n  return input;\n}\nvar NULL, NOOP, objectToString;\nvar init_util = __esm({\n  \"src/lib/utils/util.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    NULL = \"\\0\";\n    NOOP = () => {\n    };\n    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);\n  }\n});\n\n// src/lib/utils/argument-filters.ts\nfunction filterType(input, filter, def) {\n  if (filter(input)) {\n    return input;\n  }\n  return arguments.length > 2 ? def : void 0;\n}\nfunction filterPrimitives(input, omit) {\n  const type = isPathSpec(input) ? \"string\" : typeof input;\n  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));\n}\nfunction filterPlainObject(input) {\n  return !!input && objectToString(input) === \"[object Object]\";\n}\nfunction filterFunction(input) {\n  return typeof input === \"function\";\n}\nvar filterArray, filterNumber, filterString, filterStringOrStringArray, filterHasLength;\nvar init_argument_filters = __esm({\n  \"src/lib/utils/argument-filters.ts\"() {\n    \"use strict\";\n    init_pathspec();\n    init_util();\n    filterArray = (input) => {\n      return Array.isArray(input);\n    };\n    filterNumber = (input) => {\n      return typeof input === \"number\";\n    };\n    filterString = (input) => {\n      return typeof input === \"string\";\n    };\n    filterStringOrStringArray = (input) => {\n      return filterString(input) || Array.isArray(input) && input.every(filterString);\n    };\n    filterHasLength = (input) => {\n      if (input == null || \"number|boolean|function\".includes(typeof input)) {\n        return false;\n      }\n      return typeof input.length === \"number\";\n    };\n  }\n});\n\n// src/lib/utils/exit-codes.ts\nvar ExitCodes;\nvar init_exit_codes = __esm({\n  \"src/lib/utils/exit-codes.ts\"() {\n    \"use strict\";\n    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {\n      ExitCodes2[ExitCodes2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n      ExitCodes2[ExitCodes2[\"ERROR\"] = 1] = \"ERROR\";\n      ExitCodes2[ExitCodes2[\"NOT_FOUND\"] = -2] = \"NOT_FOUND\";\n      ExitCodes2[ExitCodes2[\"UNCLEAN\"] = 128] = \"UNCLEAN\";\n      return ExitCodes2;\n    })(ExitCodes || {});\n  }\n});\n\n// src/lib/utils/git-output-streams.ts\nvar GitOutputStreams;\nvar init_git_output_streams = __esm({\n  \"src/lib/utils/git-output-streams.ts\"() {\n    \"use strict\";\n    GitOutputStreams = class _GitOutputStreams {\n      constructor(stdOut, stdErr) {\n        this.stdOut = stdOut;\n        this.stdErr = stdErr;\n      }\n      asStrings() {\n        return new _GitOutputStreams(this.stdOut.toString(\"utf8\"), this.stdErr.toString(\"utf8\"));\n      }\n    };\n  }\n});\n\n// src/lib/utils/line-parser.ts\nfunction useMatchesDefault() {\n  throw new Error(`LineParser:useMatches not implemented`);\n}\nvar LineParser, RemoteLineParser;\nvar init_line_parser = __esm({\n  \"src/lib/utils/line-parser.ts\"() {\n    \"use strict\";\n    LineParser = class {\n      constructor(regExp, useMatches) {\n        this.matches = [];\n        this.useMatches = useMatchesDefault;\n        this.parse = (line, target) => {\n          this.resetMatches();\n          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n            return false;\n          }\n          return this.useMatches(target, this.prepareMatches()) !== false;\n        };\n        this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n        if (useMatches) {\n          this.useMatches = useMatches;\n        }\n      }\n      resetMatches() {\n        this.matches.length = 0;\n      }\n      prepareMatches() {\n        return this.matches;\n      }\n      addMatch(reg, index, line) {\n        const matched = line && reg.exec(line);\n        if (matched) {\n          this.pushMatch(index, matched);\n        }\n        return !!matched;\n      }\n      pushMatch(_index, matched) {\n        this.matches.push(...matched.slice(1));\n      }\n    };\n    RemoteLineParser = class extends LineParser {\n      addMatch(reg, index, line) {\n        return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n      }\n      pushMatch(index, matched) {\n        if (index > 0 || matched.length > 1) {\n          super.pushMatch(index, matched);\n        }\n      }\n    };\n  }\n});\n\n// src/lib/utils/simple-git-options.ts\nfunction createInstanceConfig(...options) {\n  const baseDir = process.cwd();\n  const config = Object.assign(\n    { baseDir, ...defaultOptions },\n    ...options.filter((o) => typeof o === \"object\" && o)\n  );\n  config.baseDir = config.baseDir || baseDir;\n  config.trimmed = config.trimmed === true;\n  return config;\n}\nvar defaultOptions;\nvar init_simple_git_options = __esm({\n  \"src/lib/utils/simple-git-options.ts\"() {\n    \"use strict\";\n    defaultOptions = {\n      binary: \"git\",\n      maxConcurrentProcesses: 5,\n      config: [],\n      trimmed: false\n    };\n  }\n});\n\n// src/lib/utils/task-options.ts\nfunction appendTaskOptions(options, commands = []) {\n  if (!filterPlainObject(options)) {\n    return commands;\n  }\n  return Object.keys(options).reduce((commands2, key) => {\n    const value = options[key];\n    if (isPathSpec(value)) {\n      commands2.push(value);\n    } else if (filterPrimitives(value, [\"boolean\"])) {\n      commands2.push(key + \"=\" + value);\n    } else if (Array.isArray(value)) {\n      for (const v of value) {\n        if (!filterPrimitives(v, [\"string\", \"number\"])) {\n          commands2.push(key + \"=\" + v);\n        }\n      }\n    } else {\n      commands2.push(key);\n    }\n    return commands2;\n  }, commands);\n}\nfunction getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {\n  const command = [];\n  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n    if (\"string|number\".includes(typeof args[i])) {\n      command.push(String(args[i]));\n    }\n  }\n  appendTaskOptions(trailingOptionsArgument(args), command);\n  if (!objectOnly) {\n    command.push(...trailingArrayArgument(args));\n  }\n  return command;\n}\nfunction trailingArrayArgument(args) {\n  const hasTrailingCallback = typeof last(args) === \"function\";\n  return asStringArray(filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []));\n}\nfunction trailingOptionsArgument(args) {\n  const hasTrailingCallback = filterFunction(last(args));\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\nfunction trailingFunctionArgument(args, includeNoop = true) {\n  const callback = asFunction(last(args));\n  return includeNoop || isUserFunction(callback) ? callback : void 0;\n}\nvar init_task_options = __esm({\n  \"src/lib/utils/task-options.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    init_util();\n    init_pathspec();\n  }\n});\n\n// src/lib/utils/task-parser.ts\nfunction callTaskParser(parser4, streams) {\n  return parser4(streams.stdOut, streams.stdErr);\n}\nfunction parseStringResponse(result, parsers12, texts, trim = true) {\n  asArray(texts).forEach((text) => {\n    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {\n      const line = (offset = 0) => {\n        if (i + offset >= max) {\n          return;\n        }\n        return lines[i + offset];\n      };\n      parsers12.some(({ parse }) => parse(line, result));\n    }\n  });\n  return result;\n}\nvar init_task_parser = __esm({\n  \"src/lib/utils/task-parser.ts\"() {\n    \"use strict\";\n    init_util();\n  }\n});\n\n// src/lib/utils/index.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  ExitCodes: () => ExitCodes,\n  GitOutputStreams: () => GitOutputStreams,\n  LineParser: () => LineParser,\n  NOOP: () => NOOP,\n  NULL: () => NULL,\n  RemoteLineParser: () => RemoteLineParser,\n  append: () => append,\n  appendTaskOptions: () => appendTaskOptions,\n  asArray: () => asArray,\n  asCamelCase: () => asCamelCase,\n  asFunction: () => asFunction,\n  asNumber: () => asNumber,\n  asStringArray: () => asStringArray,\n  bufferToString: () => bufferToString,\n  callTaskParser: () => callTaskParser,\n  createInstanceConfig: () => createInstanceConfig,\n  delay: () => delay,\n  filterArray: () => filterArray,\n  filterFunction: () => filterFunction,\n  filterHasLength: () => filterHasLength,\n  filterNumber: () => filterNumber,\n  filterPlainObject: () => filterPlainObject,\n  filterPrimitives: () => filterPrimitives,\n  filterString: () => filterString,\n  filterStringOrStringArray: () => filterStringOrStringArray,\n  filterType: () => filterType,\n  first: () => first,\n  folderExists: () => folderExists,\n  forEachLineWithContent: () => forEachLineWithContent,\n  getTrailingOptions: () => getTrailingOptions,\n  including: () => including,\n  isUserFunction: () => isUserFunction,\n  last: () => last,\n  objectToString: () => objectToString,\n  orVoid: () => orVoid,\n  parseStringResponse: () => parseStringResponse,\n  pick: () => pick,\n  prefixedArray: () => prefixedArray,\n  remove: () => remove,\n  splitOn: () => splitOn,\n  toLinesWithContent: () => toLinesWithContent,\n  trailingFunctionArgument: () => trailingFunctionArgument,\n  trailingOptionsArgument: () => trailingOptionsArgument\n});\nvar init_utils = __esm({\n  \"src/lib/utils/index.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    init_exit_codes();\n    init_git_output_streams();\n    init_line_parser();\n    init_simple_git_options();\n    init_task_options();\n    init_task_parser();\n    init_util();\n  }\n});\n\n// src/lib/tasks/check-is-repo.ts\nvar check_is_repo_exports = {};\n__export(check_is_repo_exports, {\n  CheckRepoActions: () => CheckRepoActions,\n  checkIsBareRepoTask: () => checkIsBareRepoTask,\n  checkIsRepoRootTask: () => checkIsRepoRootTask,\n  checkIsRepoTask: () => checkIsRepoTask\n});\nfunction checkIsRepoTask(action) {\n  switch (action) {\n    case \"bare\" /* BARE */:\n      return checkIsBareRepoTask();\n    case \"root\" /* IS_REPO_ROOT */:\n      return checkIsRepoRootTask();\n  }\n  const commands = [\"rev-parse\", \"--is-inside-work-tree\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction checkIsRepoRootTask() {\n  const commands = [\"rev-parse\", \"--git-dir\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser(path) {\n      return /^\\.(git)?$/.test(path.trim());\n    }\n  };\n}\nfunction checkIsBareRepoTask() {\n  const commands = [\"rev-parse\", \"--is-bare-repository\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction isNotRepoMessage(error) {\n  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\nvar CheckRepoActions, onError, parser;\nvar init_check_is_repo = __esm({\n  \"src/lib/tasks/check-is-repo.ts\"() {\n    \"use strict\";\n    init_utils();\n    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {\n      CheckRepoActions2[\"BARE\"] = \"bare\";\n      CheckRepoActions2[\"IN_TREE\"] = \"tree\";\n      CheckRepoActions2[\"IS_REPO_ROOT\"] = \"root\";\n      return CheckRepoActions2;\n    })(CheckRepoActions || {});\n    onError = ({ exitCode }, error, done, fail) => {\n      if (exitCode === 128 /* UNCLEAN */ && isNotRepoMessage(error)) {\n        return done(Buffer.from(\"false\"));\n      }\n      fail(error);\n    };\n    parser = (text) => {\n      return text.trim() === \"true\";\n    };\n  }\n});\n\n// src/lib/responses/CleanSummary.ts\nfunction cleanSummaryParser(dryRun, text) {\n  const summary = new CleanResponse(dryRun);\n  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n  toLinesWithContent(text).forEach((line) => {\n    const removed = line.replace(regexp, \"\");\n    summary.paths.push(removed);\n    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n  });\n  return summary;\n}\nvar CleanResponse, removalRegexp, dryRunRemovalRegexp, isFolderRegexp;\nvar init_CleanSummary = __esm({\n  \"src/lib/responses/CleanSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n    CleanResponse = class {\n      constructor(dryRun) {\n        this.dryRun = dryRun;\n        this.paths = [];\n        this.files = [];\n        this.folders = [];\n      }\n    };\n    removalRegexp = /^[a-z]+\\s*/i;\n    dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\n    isFolderRegexp = /\\/$/;\n  }\n});\n\n// src/lib/tasks/task.ts\nvar task_exports = {};\n__export(task_exports, {\n  EMPTY_COMMANDS: () => EMPTY_COMMANDS,\n  adhocExecTask: () => adhocExecTask,\n  configurationErrorTask: () => configurationErrorTask,\n  isBufferTask: () => isBufferTask,\n  isEmptyTask: () => isEmptyTask,\n  straightThroughBufferTask: () => straightThroughBufferTask,\n  straightThroughStringTask: () => straightThroughStringTask\n});\nfunction adhocExecTask(parser4) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser: parser4\n  };\n}\nfunction configurationErrorTask(error) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser() {\n      throw typeof error === \"string\" ? new TaskConfigurationError(error) : error;\n    }\n  };\n}\nfunction straightThroughStringTask(commands, trimmed2 = false) {\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return trimmed2 ? String(text).trim() : text;\n    }\n  };\n}\nfunction straightThroughBufferTask(commands) {\n  return {\n    commands,\n    format: \"buffer\",\n    parser(buffer) {\n      return buffer;\n    }\n  };\n}\nfunction isBufferTask(task) {\n  return task.format === \"buffer\";\n}\nfunction isEmptyTask(task) {\n  return task.format === \"empty\" || !task.commands.length;\n}\nvar EMPTY_COMMANDS;\nvar init_task = __esm({\n  \"src/lib/tasks/task.ts\"() {\n    \"use strict\";\n    init_task_configuration_error();\n    EMPTY_COMMANDS = [];\n  }\n});\n\n// src/lib/tasks/clean.ts\nvar clean_exports = {};\n__export(clean_exports, {\n  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,\n  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,\n  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,\n  CleanOptions: () => CleanOptions,\n  cleanTask: () => cleanTask,\n  cleanWithOptionsTask: () => cleanWithOptionsTask,\n  isCleanOptionsArray: () => isCleanOptionsArray\n});\nfunction cleanWithOptionsTask(mode, customArgs) {\n  const { cleanMode, options, valid } = getCleanOptions(mode);\n  if (!cleanMode) {\n    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n  }\n  if (!valid.options) {\n    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n  }\n  options.push(...customArgs);\n  if (options.some(isInteractiveMode)) {\n    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n  }\n  return cleanTask(cleanMode, options);\n}\nfunction cleanTask(mode, customArgs) {\n  const commands = [\"clean\", `-${mode}`, ...customArgs];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return cleanSummaryParser(mode === \"n\" /* DRY_RUN */, text);\n    }\n  };\n}\nfunction isCleanOptionsArray(input) {\n  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));\n}\nfunction getCleanOptions(input) {\n  let cleanMode;\n  let options = [];\n  let valid = { cleanMode: false, options: true };\n  input.replace(/[^a-z]i/g, \"\").split(\"\").forEach((char) => {\n    if (isCleanMode(char)) {\n      cleanMode = char;\n      valid.cleanMode = true;\n    } else {\n      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);\n    }\n  });\n  return {\n    cleanMode,\n    options,\n    valid\n  };\n}\nfunction isCleanMode(cleanMode) {\n  return cleanMode === \"f\" /* FORCE */ || cleanMode === \"n\" /* DRY_RUN */;\n}\nfunction isKnownOption(option) {\n  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\nfunction isInteractiveMode(option) {\n  if (/^-[^\\-]/.test(option)) {\n    return option.indexOf(\"i\") > 0;\n  }\n  return option === \"--interactive\";\n}\nvar CONFIG_ERROR_INTERACTIVE_MODE, CONFIG_ERROR_MODE_REQUIRED, CONFIG_ERROR_UNKNOWN_OPTION, CleanOptions, CleanOptionValues;\nvar init_clean = __esm({\n  \"src/lib/tasks/clean.ts\"() {\n    \"use strict\";\n    init_CleanSummary();\n    init_utils();\n    init_task();\n    CONFIG_ERROR_INTERACTIVE_MODE = \"Git clean interactive mode is not supported\";\n    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\n    CONFIG_ERROR_UNKNOWN_OPTION = \"Git clean unknown option found in: \";\n    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {\n      CleanOptions2[\"DRY_RUN\"] = \"n\";\n      CleanOptions2[\"FORCE\"] = \"f\";\n      CleanOptions2[\"IGNORED_INCLUDED\"] = \"x\";\n      CleanOptions2[\"IGNORED_ONLY\"] = \"X\";\n      CleanOptions2[\"EXCLUDING\"] = \"e\";\n      CleanOptions2[\"QUIET\"] = \"q\";\n      CleanOptions2[\"RECURSIVE\"] = \"d\";\n      return CleanOptions2;\n    })(CleanOptions || {});\n    CleanOptionValues = /* @__PURE__ */ new Set([\n      \"i\",\n      ...asStringArray(Object.values(CleanOptions))\n    ]);\n  }\n});\n\n// src/lib/responses/ConfigList.ts\nfunction configListParser(text) {\n  const config = new ConfigList();\n  for (const item of configParser(text)) {\n    config.addValue(item.file, String(item.key), item.value);\n  }\n  return config;\n}\nfunction configGetParser(text, key) {\n  let value = null;\n  const values = [];\n  const scopes = /* @__PURE__ */ new Map();\n  for (const item of configParser(text, key)) {\n    if (item.key !== key) {\n      continue;\n    }\n    values.push(value = item.value);\n    if (!scopes.has(item.file)) {\n      scopes.set(item.file, []);\n    }\n    scopes.get(item.file).push(value);\n  }\n  return {\n    key,\n    paths: Array.from(scopes.keys()),\n    scopes,\n    value,\n    values\n  };\n}\nfunction configFilePath(filePath) {\n  return filePath.replace(/^(file):/, \"\");\n}\nfunction* configParser(text, requestedKey = null) {\n  const lines = text.split(\"\\0\");\n  for (let i = 0, max = lines.length - 1; i < max; ) {\n    const file = configFilePath(lines[i++]);\n    let value = lines[i++];\n    let key = requestedKey;\n    if (value.includes(\"\\n\")) {\n      const line = splitOn(value, \"\\n\");\n      key = line[0];\n      value = line[1];\n    }\n    yield { file, key, value };\n  }\n}\nvar ConfigList;\nvar init_ConfigList = __esm({\n  \"src/lib/responses/ConfigList.ts\"() {\n    \"use strict\";\n    init_utils();\n    ConfigList = class {\n      constructor() {\n        this.files = [];\n        this.values = /* @__PURE__ */ Object.create(null);\n      }\n      get all() {\n        if (!this._all) {\n          this._all = this.files.reduce((all, file) => {\n            return Object.assign(all, this.values[file]);\n          }, {});\n        }\n        return this._all;\n      }\n      addFile(file) {\n        if (!(file in this.values)) {\n          const latest = last(this.files);\n          this.values[file] = latest ? Object.create(this.values[latest]) : {};\n          this.files.push(file);\n        }\n        return this.values[file];\n      }\n      addValue(file, key, value) {\n        const values = this.addFile(file);\n        if (!Object.hasOwn(values, key)) {\n          values[key] = value;\n        } else if (Array.isArray(values[key])) {\n          values[key].push(value);\n        } else {\n          values[key] = [values[key], value];\n        }\n        this._all = void 0;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/config.ts\nfunction asConfigScope(scope, fallback) {\n  if (typeof scope === \"string\" && Object.hasOwn(GitConfigScope, scope)) {\n    return scope;\n  }\n  return fallback;\n}\nfunction addConfigTask(key, value, append2, scope) {\n  const commands = [\"config\", `--${scope}`];\n  if (append2) {\n    commands.push(\"--add\");\n  }\n  commands.push(key, value);\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return text;\n    }\n  };\n}\nfunction getConfigTask(key, scope) {\n  const commands = [\"config\", \"--null\", \"--show-origin\", \"--get-all\", key];\n  if (scope) {\n    commands.splice(1, 0, `--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configGetParser(text, key);\n    }\n  };\n}\nfunction listConfigTask(scope) {\n  const commands = [\"config\", \"--list\", \"--show-origin\", \"--null\"];\n  if (scope) {\n    commands.push(`--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configListParser(text);\n    }\n  };\n}\nfunction config_default() {\n  return {\n    addConfig(key, value, ...rest) {\n      return this._runTask(\n        addConfigTask(\n          key,\n          value,\n          rest[0] === true,\n          asConfigScope(rest[1], \"local\" /* local */)\n        ),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    getConfig(key, scope) {\n      return this._runTask(\n        getConfigTask(key, asConfigScope(scope, void 0)),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    listConfig(...rest) {\n      return this._runTask(\n        listConfigTask(asConfigScope(rest[0], void 0)),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar GitConfigScope;\nvar init_config = __esm({\n  \"src/lib/tasks/config.ts\"() {\n    \"use strict\";\n    init_ConfigList();\n    init_utils();\n    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {\n      GitConfigScope2[\"system\"] = \"system\";\n      GitConfigScope2[\"global\"] = \"global\";\n      GitConfigScope2[\"local\"] = \"local\";\n      GitConfigScope2[\"worktree\"] = \"worktree\";\n      return GitConfigScope2;\n    })(GitConfigScope || {});\n  }\n});\n\n// src/lib/tasks/diff-name-status.ts\nfunction isDiffNameStatus(input) {\n  return diffNameStatus.has(input);\n}\nvar DiffNameStatus, diffNameStatus;\nvar init_diff_name_status = __esm({\n  \"src/lib/tasks/diff-name-status.ts\"() {\n    \"use strict\";\n    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {\n      DiffNameStatus2[\"ADDED\"] = \"A\";\n      DiffNameStatus2[\"COPIED\"] = \"C\";\n      DiffNameStatus2[\"DELETED\"] = \"D\";\n      DiffNameStatus2[\"MODIFIED\"] = \"M\";\n      DiffNameStatus2[\"RENAMED\"] = \"R\";\n      DiffNameStatus2[\"CHANGED\"] = \"T\";\n      DiffNameStatus2[\"UNMERGED\"] = \"U\";\n      DiffNameStatus2[\"UNKNOWN\"] = \"X\";\n      DiffNameStatus2[\"BROKEN\"] = \"B\";\n      return DiffNameStatus2;\n    })(DiffNameStatus || {});\n    diffNameStatus = new Set(Object.values(DiffNameStatus));\n  }\n});\n\n// src/lib/tasks/grep.ts\nfunction grepQueryBuilder(...params) {\n  return new GrepQuery().param(...params);\n}\nfunction parseGrep(grep) {\n  const paths = /* @__PURE__ */ new Set();\n  const results = {};\n  forEachLineWithContent(grep, (input) => {\n    const [path, line, preview] = input.split(NULL);\n    paths.add(path);\n    (results[path] = results[path] || []).push({\n      line: asNumber(line),\n      path,\n      preview\n    });\n  });\n  return {\n    paths,\n    results\n  };\n}\nfunction grep_default() {\n  return {\n    grep(searchTerm) {\n      const then = trailingFunctionArgument(arguments);\n      const options = getTrailingOptions(arguments);\n      for (const option of disallowedOptions) {\n        if (options.includes(option)) {\n          return this._runTask(\n            configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n            then\n          );\n        }\n      }\n      if (typeof searchTerm === \"string\") {\n        searchTerm = grepQueryBuilder().param(searchTerm);\n      }\n      const commands = [\"grep\", \"--null\", \"-n\", \"--full-name\", ...options, ...searchTerm];\n      return this._runTask(\n        {\n          commands,\n          format: \"utf-8\",\n          parser(stdOut) {\n            return parseGrep(stdOut);\n          }\n        },\n        then\n      );\n    }\n  };\n}\nvar disallowedOptions, Query, _a, GrepQuery;\nvar init_grep = __esm({\n  \"src/lib/tasks/grep.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n    disallowedOptions = [\"-h\"];\n    Query = Symbol(\"grepQuery\");\n    GrepQuery = class {\n      constructor() {\n        this[_a] = [];\n      }\n      *[(_a = Query, Symbol.iterator)]() {\n        for (const query of this[Query]) {\n          yield query;\n        }\n      }\n      and(...and) {\n        and.length && this[Query].push(\"--and\", \"(\", ...prefixedArray(and, \"-e\"), \")\");\n        return this;\n      }\n      param(...param) {\n        this[Query].push(...prefixedArray(param, \"-e\"));\n        return this;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/reset.ts\nvar reset_exports = {};\n__export(reset_exports, {\n  ResetMode: () => ResetMode,\n  getResetMode: () => getResetMode,\n  resetTask: () => resetTask\n});\nfunction resetTask(mode, customArgs) {\n  const commands = [\"reset\"];\n  if (isValidResetMode(mode)) {\n    commands.push(`--${mode}`);\n  }\n  commands.push(...customArgs);\n  return straightThroughStringTask(commands);\n}\nfunction getResetMode(mode) {\n  if (isValidResetMode(mode)) {\n    return mode;\n  }\n  switch (typeof mode) {\n    case \"string\":\n    case \"undefined\":\n      return \"soft\" /* SOFT */;\n  }\n  return;\n}\nfunction isValidResetMode(mode) {\n  return typeof mode === \"string\" && validResetModes.includes(mode);\n}\nvar ResetMode, validResetModes;\nvar init_reset = __esm({\n  \"src/lib/tasks/reset.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n    ResetMode = /* @__PURE__ */ ((ResetMode2) => {\n      ResetMode2[\"MIXED\"] = \"mixed\";\n      ResetMode2[\"SOFT\"] = \"soft\";\n      ResetMode2[\"HARD\"] = \"hard\";\n      ResetMode2[\"MERGE\"] = \"merge\";\n      ResetMode2[\"KEEP\"] = \"keep\";\n      return ResetMode2;\n    })(ResetMode || {});\n    validResetModes = asStringArray(Object.values(ResetMode));\n  }\n});\n\n// src/lib/git-logger.ts\n\nfunction createLog() {\n  return debug__WEBPACK_IMPORTED_MODULE_2__(\"simple-git\");\n}\nfunction prefixedLogger(to, prefix, forward) {\n  if (!prefix || !String(prefix).replace(/\\s*/, \"\")) {\n    return !forward ? to : (message, ...args) => {\n      to(message, ...args);\n      forward(message, ...args);\n    };\n  }\n  return (message, ...args) => {\n    to(`%s ${message}`, prefix, ...args);\n    if (forward) {\n      forward(message, ...args);\n    }\n  };\n}\nfunction childLoggerName(name, childDebugger, { namespace: parentNamespace }) {\n  if (typeof name === \"string\") {\n    return name;\n  }\n  const childNamespace = childDebugger && childDebugger.namespace || \"\";\n  if (childNamespace.startsWith(parentNamespace)) {\n    return childNamespace.substr(parentNamespace.length + 1);\n  }\n  return childNamespace || parentNamespace;\n}\nfunction createLogger(label, verbose, initialStep, infoDebugger = createLog()) {\n  const labelPrefix = label && `[${label}]` || \"\";\n  const spawned = [];\n  const debugDebugger = typeof verbose === \"string\" ? infoDebugger.extend(verbose) : verbose;\n  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n  return step(initialStep);\n  function sibling(name, initial) {\n    return append(\n      spawned,\n      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)\n    );\n  }\n  function step(phase) {\n    const stepPrefix = phase && `[${phase}]` || \"\";\n    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);\n    return Object.assign(debugDebugger ? debug2 : info, {\n      label,\n      sibling,\n      info,\n      step\n    });\n  }\n}\nvar init_git_logger = __esm({\n  \"src/lib/git-logger.ts\"() {\n    \"use strict\";\n    init_utils();\n    debug__WEBPACK_IMPORTED_MODULE_2__.formatters.L = (value) => String(filterHasLength(value) ? value.length : \"-\");\n    debug__WEBPACK_IMPORTED_MODULE_2__.formatters.B = (value) => {\n      if (Buffer.isBuffer(value)) {\n        return value.toString(\"utf8\");\n      }\n      return objectToString(value);\n    };\n  }\n});\n\n// src/lib/runners/tasks-pending-queue.ts\nvar TasksPendingQueue;\nvar init_tasks_pending_queue = __esm({\n  \"src/lib/runners/tasks-pending-queue.ts\"() {\n    \"use strict\";\n    init_git_error();\n    init_git_logger();\n    TasksPendingQueue = class _TasksPendingQueue {\n      constructor(logLabel = \"GitExecutor\") {\n        this.logLabel = logLabel;\n        this._queue = /* @__PURE__ */ new Map();\n      }\n      withProgress(task) {\n        return this._queue.get(task);\n      }\n      createProgress(task) {\n        const name = _TasksPendingQueue.getName(task.commands[0]);\n        const logger = createLogger(this.logLabel, name);\n        return {\n          task,\n          logger,\n          name\n        };\n      }\n      push(task) {\n        const progress = this.createProgress(task);\n        progress.logger(\"Adding task to the queue, commands = %o\", task.commands);\n        this._queue.set(task, progress);\n        return progress;\n      }\n      fatal(err) {\n        for (const [task, { logger }] of Array.from(this._queue.entries())) {\n          if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(\n              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`\n            );\n          } else {\n            logger.info(\n              `A fatal exception occurred in a previous task, the queue has been purged: %o`,\n              err.message\n            );\n          }\n          this.complete(task);\n        }\n        if (this._queue.size !== 0) {\n          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n        }\n      }\n      complete(task) {\n        const progress = this.withProgress(task);\n        if (progress) {\n          this._queue.delete(task);\n        }\n      }\n      attempt(task) {\n        const progress = this.withProgress(task);\n        if (!progress) {\n          throw new GitError(void 0, \"TasksPendingQueue: attempt called for an unknown task\");\n        }\n        progress.logger(\"Starting task\");\n        return progress;\n      }\n      static getName(name = \"empty\") {\n        return `task:${name}:${++_TasksPendingQueue.counter}`;\n      }\n      static {\n        this.counter = 0;\n      }\n    };\n  }\n});\n\n// src/lib/runners/git-executor-chain.ts\n\nfunction pluginContext(task, commands) {\n  return {\n    method: first(task.commands) || \"\",\n    commands\n  };\n}\nfunction onErrorReceived(target, logger) {\n  return (err) => {\n    logger(`[ERROR] child process exception %o`, err);\n    target.push(Buffer.from(String(err.stack), \"ascii\"));\n  };\n}\nfunction onDataReceived(target, name, logger, output) {\n  return (buffer) => {\n    logger(`%s received %L bytes`, name, buffer);\n    output(`%B`, buffer);\n    target.push(buffer);\n  };\n}\nvar GitExecutorChain;\nvar init_git_executor_chain = __esm({\n  \"src/lib/runners/git-executor-chain.ts\"() {\n    \"use strict\";\n    init_git_error();\n    init_task();\n    init_utils();\n    init_tasks_pending_queue();\n    GitExecutorChain = class {\n      constructor(_executor, _scheduler, _plugins) {\n        this._executor = _executor;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = Promise.resolve();\n        this._queue = new TasksPendingQueue();\n      }\n      get cwd() {\n        return this._cwd || this._executor.cwd;\n      }\n      set cwd(cwd) {\n        this._cwd = cwd;\n      }\n      get env() {\n        return this._executor.env;\n      }\n      get outputHandler() {\n        return this._executor.outputHandler;\n      }\n      chain() {\n        return this;\n      }\n      push(task) {\n        this._queue.push(task);\n        return this._chain = this._chain.then(() => this.attemptTask(task));\n      }\n      async attemptTask(task) {\n        const onScheduleComplete = await this._scheduler.next();\n        const onQueueComplete = () => this._queue.complete(task);\n        try {\n          const { logger } = this._queue.attempt(task);\n          return await (isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger));\n        } catch (e) {\n          throw this.onFatalException(task, e);\n        } finally {\n          onQueueComplete();\n          onScheduleComplete();\n        }\n      }\n      onFatalException(task, e) {\n        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));\n        this._chain = Promise.resolve();\n        this._queue.fatal(gitError);\n        return gitError;\n      }\n      async attemptRemoteTask(task, logger) {\n        const binary = this._plugins.exec(\"spawn.binary\", \"\", pluginContext(task, task.commands));\n        const args = this._plugins.exec(\n          \"spawn.args\",\n          [...task.commands],\n          pluginContext(task, task.commands)\n        );\n        const raw = await this.gitResponse(\n          task,\n          binary,\n          args,\n          this.outputHandler,\n          logger.step(\"SPAWN\")\n        );\n        const outputStreams = await this.handleTaskData(task, args, raw, logger.step(\"HANDLE\"));\n        logger(`passing response to task's parser as a %s`, task.format);\n        if (isBufferTask(task)) {\n          return callTaskParser(task.parser, outputStreams);\n        }\n        return callTaskParser(task.parser, outputStreams.asStrings());\n      }\n      async attemptEmptyTask(task, logger) {\n        logger(`empty task bypassing child process to call to task's parser`);\n        return task.parser(this);\n      }\n      handleTaskData(task, args, result, logger) {\n        const { exitCode, rejection, stdOut, stdErr } = result;\n        return new Promise((done, fail) => {\n          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n          const { error } = this._plugins.exec(\n            \"task.error\",\n            { error: rejection },\n            {\n              ...pluginContext(task, args),\n              ...result\n            }\n          );\n          if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n            return task.onError(\n              result,\n              error,\n              (newStdOut) => {\n                logger.info(`custom error handler treated as success`);\n                logger(`custom error returned a %s`, objectToString(newStdOut));\n                done(\n                  new GitOutputStreams(\n                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                    Buffer.concat(stdErr)\n                  )\n                );\n              },\n              fail\n            );\n          }\n          if (error) {\n            logger.info(\n              `handling as error: exitCode=%s stdErr=%s rejection=%o`,\n              exitCode,\n              stdErr.length,\n              rejection\n            );\n            return fail(error);\n          }\n          logger.info(`retrieving task output complete`);\n          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));\n        });\n      }\n      async gitResponse(task, command, args, outputHandler, logger) {\n        const outputLogger = logger.sibling(\"output\");\n        const spawnOptions = this._plugins.exec(\n          \"spawn.options\",\n          {\n            cwd: this.cwd,\n            env: this.env,\n            windowsHide: true\n          },\n          pluginContext(task, task.commands)\n        );\n        return new Promise((done) => {\n          const stdOut = [];\n          const stdErr = [];\n          logger.info(`%s %o`, command, args);\n          logger(\"%O\", spawnOptions);\n          let rejection = this._beforeSpawn(task, args);\n          if (rejection) {\n            return done({\n              stdOut,\n              stdErr,\n              exitCode: 9901,\n              rejection\n            });\n          }\n          this._plugins.exec(\"spawn.before\", void 0, {\n            ...pluginContext(task, args),\n            kill(reason) {\n              rejection = reason || rejection;\n            }\n          });\n          const spawned = (0,child_process__WEBPACK_IMPORTED_MODULE_3__.spawn)(command, args, spawnOptions);\n          spawned.stdout.on(\n            \"data\",\n            onDataReceived(stdOut, \"stdOut\", logger, outputLogger.step(\"stdOut\"))\n          );\n          spawned.stderr.on(\n            \"data\",\n            onDataReceived(stdErr, \"stdErr\", logger, outputLogger.step(\"stdErr\"))\n          );\n          spawned.on(\"error\", onErrorReceived(stdErr, logger));\n          if (outputHandler) {\n            logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n            outputHandler(command, spawned.stdout, spawned.stderr, [...args]);\n          }\n          this._plugins.exec(\"spawn.after\", void 0, {\n            ...pluginContext(task, args),\n            spawned,\n            close(exitCode, reason) {\n              done({\n                stdOut,\n                stdErr,\n                exitCode,\n                rejection: rejection || reason\n              });\n            },\n            kill(reason) {\n              if (spawned.killed) {\n                return;\n              }\n              rejection = reason;\n              spawned.kill(\"SIGINT\");\n            }\n          });\n        });\n      }\n      _beforeSpawn(task, args) {\n        let rejection;\n        this._plugins.exec(\"spawn.before\", void 0, {\n          ...pluginContext(task, args),\n          kill(reason) {\n            rejection = reason || rejection;\n          }\n        });\n        return rejection;\n      }\n    };\n  }\n});\n\n// src/lib/runners/git-executor.ts\nvar git_executor_exports = {};\n__export(git_executor_exports, {\n  GitExecutor: () => GitExecutor\n});\nvar GitExecutor;\nvar init_git_executor = __esm({\n  \"src/lib/runners/git-executor.ts\"() {\n    \"use strict\";\n    init_git_executor_chain();\n    GitExecutor = class {\n      constructor(cwd, _scheduler, _plugins) {\n        this.cwd = cwd;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      chain() {\n        return new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      push(task) {\n        return this._chain.push(task);\n      }\n    };\n  }\n});\n\n// src/lib/task-callback.ts\nfunction taskCallback(task, response, callback = NOOP) {\n  const onSuccess = (data) => {\n    callback(null, data);\n  };\n  const onError2 = (err) => {\n    if (err?.task === task) {\n      callback(\n        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,\n        void 0\n      );\n    }\n  };\n  response.then(onSuccess, onError2);\n}\nfunction addDeprecationNoticeToError(err) {\n  let log = (name) => {\n    console.warn(\n      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`\n    );\n    log = NOOP;\n  };\n  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n  function descriptorReducer(all, name) {\n    if (name in err) {\n      return all;\n    }\n    all[name] = {\n      enumerable: false,\n      configurable: false,\n      get() {\n        log(name);\n        return err.git[name];\n      }\n    };\n    return all;\n  }\n}\nvar init_task_callback = __esm({\n  \"src/lib/task-callback.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/change-working-directory.ts\nfunction changeWorkingDirectoryTask(directory, root) {\n  return adhocExecTask((instance) => {\n    if (!folderExists(directory)) {\n      throw new Error(`Git.cwd: cannot change to non-directory \"${directory}\"`);\n    }\n    return (root || instance).cwd = directory;\n  });\n}\nvar init_change_working_directory = __esm({\n  \"src/lib/tasks/change-working-directory.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/checkout.ts\nfunction checkoutTask(args) {\n  const commands = [\"checkout\", ...args];\n  if (commands[1] === \"-b\" && commands.includes(\"-B\")) {\n    commands[1] = remove(commands, \"-B\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction checkout_default() {\n  return {\n    checkout() {\n      return this._runTask(\n        checkoutTask(getTrailingOptions(arguments, 1)),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    checkoutBranch(branchName, startPoint) {\n      return this._runTask(\n        checkoutTask([\"-b\", branchName, startPoint, ...getTrailingOptions(arguments)]),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    checkoutLocalBranch(branchName) {\n      return this._runTask(\n        checkoutTask([\"-b\", branchName, ...getTrailingOptions(arguments)]),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_checkout = __esm({\n  \"src/lib/tasks/checkout.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/count-objects.ts\nfunction countObjectsResponse() {\n  return {\n    count: 0,\n    garbage: 0,\n    inPack: 0,\n    packs: 0,\n    prunePackable: 0,\n    size: 0,\n    sizeGarbage: 0,\n    sizePack: 0\n  };\n}\nfunction count_objects_default() {\n  return {\n    countObjects() {\n      return this._runTask({\n        commands: [\"count-objects\", \"--verbose\"],\n        format: \"utf-8\",\n        parser(stdOut) {\n          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);\n        }\n      });\n    }\n  };\n}\nvar parser2;\nvar init_count_objects = __esm({\n  \"src/lib/tasks/count-objects.ts\"() {\n    \"use strict\";\n    init_utils();\n    parser2 = new LineParser(\n      /([a-z-]+): (\\d+)$/,\n      (result, [key, value]) => {\n        const property = asCamelCase(key);\n        if (Object.hasOwn(result, property)) {\n          result[property] = asNumber(value);\n        }\n      }\n    );\n  }\n});\n\n// src/lib/parsers/parse-commit.ts\nfunction parseCommitResult(stdOut) {\n  const result = {\n    author: null,\n    branch: \"\",\n    commit: \"\",\n    root: false,\n    summary: {\n      changes: 0,\n      insertions: 0,\n      deletions: 0\n    }\n  };\n  return parseStringResponse(result, parsers, stdOut);\n}\nvar parsers;\nvar init_parse_commit = __esm({\n  \"src/lib/parsers/parse-commit.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers = [\n      new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n        result.branch = branch;\n        result.commit = commit;\n        result.root = !!root;\n      }),\n      new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n        const parts = author.split(\"<\");\n        const email = parts.pop();\n        if (!email || !email.includes(\"@\")) {\n          return;\n        }\n        result.author = {\n          email: email.substr(0, email.length - 1),\n          name: parts.join(\"<\").trim()\n        };\n      }),\n      new LineParser(\n        /(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g,\n        (result, [changes, insertions, deletions]) => {\n          result.summary.changes = parseInt(changes, 10) || 0;\n          result.summary.insertions = parseInt(insertions, 10) || 0;\n          result.summary.deletions = parseInt(deletions, 10) || 0;\n        }\n      ),\n      new LineParser(\n        /^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/,\n        (result, [changes, lines, direction]) => {\n          result.summary.changes = parseInt(changes, 10) || 0;\n          const count = parseInt(lines, 10) || 0;\n          if (direction === \"-\") {\n            result.summary.deletions = count;\n          } else if (direction === \"+\") {\n            result.summary.insertions = count;\n          }\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/commit.ts\nfunction commitTask(message, files, customArgs) {\n  const commands = [\n    \"-c\",\n    \"core.abbrev=40\",\n    \"commit\",\n    ...prefixedArray(message, \"-m\"),\n    ...files,\n    ...customArgs\n  ];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseCommitResult\n  };\n}\nfunction commit_default() {\n  return {\n    commit(message, ...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const task = rejectDeprecatedSignatures(message) || commitTask(\n        asArray(message),\n        asArray(filterType(rest[0], filterStringOrStringArray, [])),\n        [\n          ...asStringArray(filterType(rest[1], filterArray, [])),\n          ...getTrailingOptions(arguments, 0, true)\n        ]\n      );\n      return this._runTask(task, next);\n    }\n  };\n  function rejectDeprecatedSignatures(message) {\n    return !filterStringOrStringArray(message) && configurationErrorTask(\n      `git.commit: requires the commit message to be supplied as a string/string[]`\n    );\n  }\n}\nvar init_commit = __esm({\n  \"src/lib/tasks/commit.ts\"() {\n    \"use strict\";\n    init_parse_commit();\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/first-commit.ts\nfunction first_commit_default() {\n  return {\n    firstCommit() {\n      return this._runTask(\n        straightThroughStringTask([\"rev-list\", \"--max-parents=0\", \"HEAD\"], true),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_first_commit = __esm({\n  \"src/lib/tasks/first-commit.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/hash-object.ts\nfunction hashObjectTask(filePath, write) {\n  const commands = [\"hash-object\", filePath];\n  if (write) {\n    commands.push(\"-w\");\n  }\n  return straightThroughStringTask(commands, true);\n}\nvar init_hash_object = __esm({\n  \"src/lib/tasks/hash-object.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/InitSummary.ts\nfunction parseInit(bare, path, text) {\n  const response = String(text).trim();\n  let result;\n  if (result = initResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, false, result[1]);\n  }\n  if (result = reInitResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, true, result[1]);\n  }\n  let gitDir = \"\";\n  const tokens = response.split(\" \");\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (token === \"in\") {\n      gitDir = tokens.join(\" \");\n      break;\n    }\n  }\n  return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\nvar InitSummary, initResponseRegex, reInitResponseRegex;\nvar init_InitSummary = __esm({\n  \"src/lib/responses/InitSummary.ts\"() {\n    \"use strict\";\n    InitSummary = class {\n      constructor(bare, path, existing, gitDir) {\n        this.bare = bare;\n        this.path = path;\n        this.existing = existing;\n        this.gitDir = gitDir;\n      }\n    };\n    initResponseRegex = /^Init.+ repository in (.+)$/;\n    reInitResponseRegex = /^Rein.+ in (.+)$/;\n  }\n});\n\n// src/lib/tasks/init.ts\nfunction hasBareCommand(command) {\n  return command.includes(bareCommand);\n}\nfunction initTask(bare = false, path, customArgs) {\n  const commands = [\"init\", ...customArgs];\n  if (bare && !hasBareCommand(commands)) {\n    commands.splice(1, 0, bareCommand);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return parseInit(commands.includes(\"--bare\"), path, text);\n    }\n  };\n}\nvar bareCommand;\nvar init_init = __esm({\n  \"src/lib/tasks/init.ts\"() {\n    \"use strict\";\n    init_InitSummary();\n    bareCommand = \"--bare\";\n  }\n});\n\n// src/lib/args/log-format.ts\nfunction logFormatFromCommand(customArgs) {\n  for (let i = 0; i < customArgs.length; i++) {\n    const format = logFormatRegex.exec(customArgs[i]);\n    if (format) {\n      return `--${format[1]}`;\n    }\n  }\n  return \"\" /* NONE */;\n}\nfunction isLogFormat(customArg) {\n  return logFormatRegex.test(customArg);\n}\nvar logFormatRegex;\nvar init_log_format = __esm({\n  \"src/lib/args/log-format.ts\"() {\n    \"use strict\";\n    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;\n  }\n});\n\n// src/lib/responses/DiffSummary.ts\nvar DiffSummary;\nvar init_DiffSummary = __esm({\n  \"src/lib/responses/DiffSummary.ts\"() {\n    \"use strict\";\n    DiffSummary = class {\n      constructor() {\n        this.changed = 0;\n        this.deletions = 0;\n        this.insertions = 0;\n        this.files = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-diff-summary.ts\nfunction getDiffParser(format = \"\" /* NONE */) {\n  const parser4 = diffSummaryParsers[format];\n  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);\n}\nvar statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;\nvar init_parse_diff_summary = __esm({\n  \"src/lib/parsers/parse-diff-summary.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_DiffSummary();\n    init_diff_name_status();\n    init_utils();\n    statParser = [\n      new LineParser(\n        /^(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/,\n        (result, [file, changes, alterations = \"\"]) => {\n          result.files.push({\n            file: file.trim(),\n            changes: asNumber(changes),\n            insertions: alterations.replace(/[^+]/g, \"\").length,\n            deletions: alterations.replace(/[^-]/g, \"\").length,\n            binary: false\n          });\n        }\n      ),\n      new LineParser(\n        /^(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,\n        (result, [file, before, after]) => {\n          result.files.push({\n            file: file.trim(),\n            before: asNumber(before),\n            after: asNumber(after),\n            binary: true\n          });\n        }\n      ),\n      new LineParser(\n        /(\\d+) files? changed\\s*((?:, \\d+ [^,]+){0,2})/,\n        (result, [changed, summary]) => {\n          const inserted = /(\\d+) i/.exec(summary);\n          const deleted = /(\\d+) d/.exec(summary);\n          result.changed = asNumber(changed);\n          result.insertions = asNumber(inserted?.[1]);\n          result.deletions = asNumber(deleted?.[1]);\n        }\n      )\n    ];\n    numStatParser = [\n      new LineParser(\n        /(\\d+)\\t(\\d+)\\t(.+)$/,\n        (result, [changesInsert, changesDelete, file]) => {\n          const insertions = asNumber(changesInsert);\n          const deletions = asNumber(changesDelete);\n          result.changed++;\n          result.insertions += insertions;\n          result.deletions += deletions;\n          result.files.push({\n            file,\n            changes: insertions + deletions,\n            insertions,\n            deletions,\n            binary: false\n          });\n        }\n      ),\n      new LineParser(/-\\t-\\t(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          after: 0,\n          before: 0,\n          binary: true\n        });\n      })\n    ];\n    nameOnlyParser = [\n      new LineParser(/(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          changes: 0,\n          insertions: 0,\n          deletions: 0,\n          binary: false\n        });\n      })\n    ];\n    nameStatusParser = [\n      new LineParser(\n        /([ACDMRTUXB])([0-9]{0,3})\\t(.[^\\t]*)(\\t(.[^\\t]*))?$/,\n        (result, [status, similarity, from, _to, to]) => {\n          result.changed++;\n          result.files.push({\n            file: to ?? from,\n            changes: 0,\n            insertions: 0,\n            deletions: 0,\n            binary: false,\n            status: orVoid(isDiffNameStatus(status) && status),\n            from: orVoid(!!to && from !== to && from),\n            similarity: asNumber(similarity)\n          });\n        }\n      )\n    ];\n    diffSummaryParsers = {\n      [\"\" /* NONE */]: statParser,\n      [\"--stat\" /* STAT */]: statParser,\n      [\"--numstat\" /* NUM_STAT */]: numStatParser,\n      [\"--name-status\" /* NAME_STATUS */]: nameStatusParser,\n      [\"--name-only\" /* NAME_ONLY */]: nameOnlyParser\n    };\n  }\n});\n\n// src/lib/parsers/parse-list-log-summary.ts\nfunction lineBuilder(tokens, fields) {\n  return fields.reduce(\n    (line, field, index) => {\n      line[field] = tokens[index] || \"\";\n      return line;\n    },\n    /* @__PURE__ */ Object.create({ diff: null })\n  );\n}\nfunction createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = \"\" /* NONE */) {\n  const parseDiffResult = getDiffParser(logFormat);\n  return function(stdOut) {\n    const all = toLinesWithContent(\n      stdOut.trim(),\n      false,\n      START_BOUNDARY\n    ).map(function(item) {\n      const lineDetail = item.split(COMMIT_BOUNDARY);\n      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);\n      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n        listLogLine.diff = parseDiffResult(lineDetail[1]);\n      }\n      return listLogLine;\n    });\n    return {\n      all,\n      latest: all.length && all[0] || null,\n      total: all.length\n    };\n  };\n}\nvar START_BOUNDARY, COMMIT_BOUNDARY, SPLITTER, defaultFieldNames;\nvar init_parse_list_log_summary = __esm({\n  \"src/lib/parsers/parse-list-log-summary.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_diff_summary();\n    init_log_format();\n    START_BOUNDARY = \"\\xF2\\xF2\\xF2\\xF2\\xF2\\xF2 \";\n    COMMIT_BOUNDARY = \" \\xF2\\xF2\";\n    SPLITTER = \" \\xF2 \";\n    defaultFieldNames = [\"hash\", \"date\", \"message\", \"refs\", \"author_name\", \"author_email\"];\n  }\n});\n\n// src/lib/tasks/diff.ts\nvar diff_exports = {};\n__export(diff_exports, {\n  diffSummaryTask: () => diffSummaryTask,\n  validateLogFormatConfig: () => validateLogFormatConfig\n});\nfunction diffSummaryTask(customArgs) {\n  let logFormat = logFormatFromCommand(customArgs);\n  const commands = [\"diff\"];\n  if (logFormat === \"\" /* NONE */) {\n    logFormat = \"--stat\" /* STAT */;\n    commands.push(\"--stat=4096\");\n  }\n  commands.push(...customArgs);\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: getDiffParser(logFormat)\n  };\n}\nfunction validateLogFormatConfig(customArgs) {\n  const flags = customArgs.filter(isLogFormat);\n  if (flags.length > 1) {\n    return configurationErrorTask(\n      `Summary flags are mutually exclusive - pick one of ${flags.join(\",\")}`\n    );\n  }\n  if (flags.length && customArgs.includes(\"-z\")) {\n    return configurationErrorTask(\n      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`\n    );\n  }\n}\nvar init_diff = __esm({\n  \"src/lib/tasks/diff.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_parse_diff_summary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/log.ts\nfunction prettyFormat(format, splitter) {\n  const fields = [];\n  const formatStr = [];\n  Object.keys(format).forEach((field) => {\n    fields.push(field);\n    formatStr.push(String(format[field]));\n  });\n  return [fields, formatStr.join(splitter)];\n}\nfunction userOptions(input) {\n  return Object.keys(input).reduce((out, key) => {\n    if (!(key in excludeOptions)) {\n      out[key] = input[key];\n    }\n    return out;\n  }, {});\n}\nfunction parseLogOptions(opt = {}, customArgs = []) {\n  const splitter = filterType(opt.splitter, filterString, SPLITTER);\n  const format = filterPlainObject(opt.format) ? opt.format : {\n    hash: \"%H\",\n    date: opt.strictDate === false ? \"%ai\" : \"%aI\",\n    message: \"%s\",\n    refs: \"%D\",\n    body: opt.multiLine ? \"%B\" : \"%b\",\n    author_name: opt.mailMap !== false ? \"%aN\" : \"%an\",\n    author_email: opt.mailMap !== false ? \"%aE\" : \"%ae\"\n  };\n  const [fields, formatStr] = prettyFormat(format, splitter);\n  const suffix = [];\n  const command = [\n    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n    ...customArgs\n  ];\n  const maxCount = opt.n || opt[\"max-count\"] || opt.maxCount;\n  if (maxCount) {\n    command.push(`--max-count=${maxCount}`);\n  }\n  if (opt.from || opt.to) {\n    const rangeOperator = opt.symmetric !== false ? \"...\" : \"..\";\n    suffix.push(`${opt.from || \"\"}${rangeOperator}${opt.to || \"\"}`);\n  }\n  if (filterString(opt.file)) {\n    command.push(\"--follow\", pathspec(opt.file));\n  }\n  appendTaskOptions(userOptions(opt), command);\n  return {\n    fields,\n    splitter,\n    commands: [...command, ...suffix]\n  };\n}\nfunction logTask(splitter, fields, customArgs) {\n  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));\n  return {\n    commands: [\"log\", ...customArgs],\n    format: \"utf-8\",\n    parser: parser4\n  };\n}\nfunction log_default() {\n  return {\n    log(...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const options = parseLogOptions(\n        trailingOptionsArgument(arguments),\n        asStringArray(filterType(arguments[0], filterArray, []))\n      );\n      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);\n      return this._runTask(task, next);\n    }\n  };\n  function createLogTask(options) {\n    return logTask(options.splitter, options.fields, options.commands);\n  }\n  function rejectDeprecatedSignatures(from, to) {\n    return filterString(from) && filterString(to) && configurationErrorTask(\n      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`\n    );\n  }\n}\nvar excludeOptions;\nvar init_log = __esm({\n  \"src/lib/tasks/log.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_pathspec();\n    init_parse_list_log_summary();\n    init_utils();\n    init_task();\n    init_diff();\n    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {\n      excludeOptions2[excludeOptions2[\"--pretty\"] = 0] = \"--pretty\";\n      excludeOptions2[excludeOptions2[\"max-count\"] = 1] = \"max-count\";\n      excludeOptions2[excludeOptions2[\"maxCount\"] = 2] = \"maxCount\";\n      excludeOptions2[excludeOptions2[\"n\"] = 3] = \"n\";\n      excludeOptions2[excludeOptions2[\"file\"] = 4] = \"file\";\n      excludeOptions2[excludeOptions2[\"format\"] = 5] = \"format\";\n      excludeOptions2[excludeOptions2[\"from\"] = 6] = \"from\";\n      excludeOptions2[excludeOptions2[\"to\"] = 7] = \"to\";\n      excludeOptions2[excludeOptions2[\"splitter\"] = 8] = \"splitter\";\n      excludeOptions2[excludeOptions2[\"symmetric\"] = 9] = \"symmetric\";\n      excludeOptions2[excludeOptions2[\"mailMap\"] = 10] = \"mailMap\";\n      excludeOptions2[excludeOptions2[\"multiLine\"] = 11] = \"multiLine\";\n      excludeOptions2[excludeOptions2[\"strictDate\"] = 12] = \"strictDate\";\n      return excludeOptions2;\n    })(excludeOptions || {});\n  }\n});\n\n// src/lib/responses/MergeSummary.ts\nvar MergeSummaryConflict, MergeSummaryDetail;\nvar init_MergeSummary = __esm({\n  \"src/lib/responses/MergeSummary.ts\"() {\n    \"use strict\";\n    MergeSummaryConflict = class {\n      constructor(reason, file = null, meta) {\n        this.reason = reason;\n        this.file = file;\n        this.meta = meta;\n      }\n      toString() {\n        return `${this.file}:${this.reason}`;\n      }\n    };\n    MergeSummaryDetail = class {\n      constructor() {\n        this.conflicts = [];\n        this.merges = [];\n        this.result = \"success\";\n      }\n      get failed() {\n        return this.conflicts.length > 0;\n      }\n      get reason() {\n        return this.result;\n      }\n      toString() {\n        if (this.conflicts.length) {\n          return `CONFLICTS: ${this.conflicts.join(\", \")}`;\n        }\n        return \"OK\";\n      }\n    };\n  }\n});\n\n// src/lib/responses/PullSummary.ts\nvar PullSummary, PullFailedSummary;\nvar init_PullSummary = __esm({\n  \"src/lib/responses/PullSummary.ts\"() {\n    \"use strict\";\n    PullSummary = class {\n      constructor() {\n        this.remoteMessages = {\n          all: []\n        };\n        this.created = [];\n        this.deleted = [];\n        this.files = [];\n        this.deletions = {};\n        this.insertions = {};\n        this.summary = {\n          changes: 0,\n          deletions: 0,\n          insertions: 0\n        };\n      }\n    };\n    PullFailedSummary = class {\n      constructor() {\n        this.remote = \"\";\n        this.hash = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.branch = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.message = \"\";\n      }\n      toString() {\n        return this.message;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-remote-objects.ts\nfunction objectEnumerationResult(remoteMessages) {\n  return remoteMessages.objects = remoteMessages.objects || {\n    compressing: 0,\n    counting: 0,\n    enumerating: 0,\n    packReused: 0,\n    reused: { count: 0, delta: 0 },\n    total: { count: 0, delta: 0 }\n  };\n}\nfunction asObjectCount(source) {\n  const count = /^\\s*(\\d+)/.exec(source);\n  const delta = /delta (\\d+)/i.exec(source);\n  return {\n    count: asNumber(count && count[1] || \"0\"),\n    delta: asNumber(delta && delta[1] || \"0\")\n  };\n}\nvar remoteMessagesObjectParsers;\nvar init_parse_remote_objects = __esm({\n  \"src/lib/parsers/parse-remote-objects.ts\"() {\n    \"use strict\";\n    init_utils();\n    remoteMessagesObjectParsers = [\n      new RemoteLineParser(\n        /^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i,\n        (result, [action, count]) => {\n          const key = action.toLowerCase();\n          const enumeration = objectEnumerationResult(result.remoteMessages);\n          Object.assign(enumeration, { [key]: asNumber(count) });\n        }\n      ),\n      new RemoteLineParser(\n        /^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i,\n        (result, [action, count]) => {\n          const key = action.toLowerCase();\n          const enumeration = objectEnumerationResult(result.remoteMessages);\n          Object.assign(enumeration, { [key]: asNumber(count) });\n        }\n      ),\n      new RemoteLineParser(\n        /total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i,\n        (result, [total, reused, packReused]) => {\n          const objects = objectEnumerationResult(result.remoteMessages);\n          objects.total = asObjectCount(total);\n          objects.reused = asObjectCount(reused);\n          objects.packReused = asNumber(packReused);\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/parsers/parse-remote-messages.ts\nfunction parseRemoteMessages(_stdOut, stdErr) {\n  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);\n}\nvar parsers2, RemoteMessageSummary;\nvar init_parse_remote_messages = __esm({\n  \"src/lib/parsers/parse-remote-messages.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_remote_objects();\n    parsers2 = [\n      new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n        result.remoteMessages.all.push(text.trim());\n        return false;\n      }),\n      ...remoteMessagesObjectParsers,\n      new RemoteLineParser(\n        [/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/],\n        (result, [pullRequestUrl]) => {\n          result.remoteMessages.pullRequestUrl = pullRequestUrl;\n        }\n      ),\n      new RemoteLineParser(\n        [/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/],\n        (result, [count, summary, url]) => {\n          result.remoteMessages.vulnerabilities = {\n            count: asNumber(count),\n            summary,\n            url\n          };\n        }\n      )\n    ];\n    RemoteMessageSummary = class {\n      constructor() {\n        this.all = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-pull.ts\nfunction parsePullErrorResult(stdOut, stdErr) {\n  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);\n  return pullError.message && pullError;\n}\nvar FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;\nvar init_parse_pull = __esm({\n  \"src/lib/parsers/parse-pull.ts\"() {\n    \"use strict\";\n    init_PullSummary();\n    init_utils();\n    init_parse_remote_messages();\n    FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\n    SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\n    ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n    parsers3 = [\n      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n        result.files.push(file);\n        if (insertions) {\n          result.insertions[file] = insertions.length;\n        }\n        if (deletions) {\n          result.deletions[file] = deletions.length;\n        }\n      }),\n      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n        if (insertions !== void 0 || deletions !== void 0) {\n          result.summary.changes = +changes || 0;\n          result.summary.insertions = +insertions || 0;\n          result.summary.deletions = +deletions || 0;\n          return true;\n        }\n        return false;\n      }),\n      new LineParser(ACTION_REGEX, (result, [action, file]) => {\n        append(result.files, file);\n        append(action === \"create\" ? result.created : result.deleted, file);\n      })\n    ];\n    errorParsers = [\n      new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n      new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n      new LineParser(\n        /([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/,\n        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n          result.branch.local = branchLocal;\n          result.hash.local = hashLocal;\n          result.branch.remote = branchRemote;\n          result.hash.remote = hashRemote;\n        }\n      )\n    ];\n    parsePullDetail = (stdOut, stdErr) => {\n      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);\n    };\n    parsePullResult = (stdOut, stdErr) => {\n      return Object.assign(\n        new PullSummary(),\n        parsePullDetail(stdOut, stdErr),\n        parseRemoteMessages(stdOut, stdErr)\n      );\n    };\n  }\n});\n\n// src/lib/parsers/parse-merge.ts\nvar parsers4, parseMergeResult, parseMergeDetail;\nvar init_parse_merge = __esm({\n  \"src/lib/parsers/parse-merge.ts\"() {\n    \"use strict\";\n    init_MergeSummary();\n    init_utils();\n    init_parse_pull();\n    parsers4 = [\n      new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n        summary.merges.push(autoMerge);\n      }),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, file));\n      }),\n      new LineParser(\n        /^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/,\n        (summary, [reason, file, deleteRef]) => {\n          summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));\n        }\n      ),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, null));\n      }),\n      new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n        summary.result = result;\n      })\n    ];\n    parseMergeResult = (stdOut, stdErr) => {\n      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));\n    };\n    parseMergeDetail = (stdOut) => {\n      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);\n    };\n  }\n});\n\n// src/lib/tasks/merge.ts\nfunction mergeTask(customArgs) {\n  if (!customArgs.length) {\n    return configurationErrorTask(\"Git.merge requires at least one option\");\n  }\n  return {\n    commands: [\"merge\", ...customArgs],\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      const merge = parseMergeResult(stdOut, stdErr);\n      if (merge.failed) {\n        throw new GitResponseError(merge);\n      }\n      return merge;\n    }\n  };\n}\nvar init_merge = __esm({\n  \"src/lib/tasks/merge.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_merge();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-push.ts\nfunction pushResultPushedItem(local, remote, status) {\n  const deleted = status.includes(\"deleted\");\n  const tag = status.includes(\"tag\") || /^refs\\/tags/.test(local);\n  const alreadyUpdated = !status.includes(\"new\");\n  return {\n    deleted,\n    tag,\n    branch: !tag,\n    new: !alreadyUpdated,\n    alreadyUpdated,\n    local,\n    remote\n  };\n}\nvar parsers5, parsePushResult, parsePushDetail;\nvar init_parse_push = __esm({\n  \"src/lib/parsers/parse-push.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_remote_messages();\n    parsers5 = [\n      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n        result.repo = repo;\n      }),\n      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n        result.ref = {\n          ...result.ref || {},\n          local\n        };\n      }),\n      new LineParser(/^[=*-]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n        result.pushed.push(pushResultPushedItem(local, remote, type));\n      }),\n      new LineParser(\n        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,\n        (result, [local, remote, remoteName]) => {\n          result.branch = {\n            ...result.branch || {},\n            local,\n            remote,\n            remoteName\n          };\n        }\n      ),\n      new LineParser(\n        /^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/,\n        (result, [local, remote, from, to]) => {\n          result.update = {\n            head: {\n              local,\n              remote\n            },\n            hash: {\n              from,\n              to\n            }\n          };\n        }\n      )\n    ];\n    parsePushResult = (stdOut, stdErr) => {\n      const pushDetail = parsePushDetail(stdOut, stdErr);\n      const responseDetail = parseRemoteMessages(stdOut, stdErr);\n      return {\n        ...pushDetail,\n        ...responseDetail\n      };\n    };\n    parsePushDetail = (stdOut, stdErr) => {\n      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/tasks/push.ts\nvar push_exports = {};\n__export(push_exports, {\n  pushTagsTask: () => pushTagsTask,\n  pushTask: () => pushTask\n});\nfunction pushTagsTask(ref = {}, customArgs) {\n  append(customArgs, \"--tags\");\n  return pushTask(ref, customArgs);\n}\nfunction pushTask(ref = {}, customArgs) {\n  const commands = [\"push\", ...customArgs];\n  if (ref.branch) {\n    commands.splice(1, 0, ref.branch);\n  }\n  if (ref.remote) {\n    commands.splice(1, 0, ref.remote);\n  }\n  remove(commands, \"-v\");\n  append(commands, \"--verbose\");\n  append(commands, \"--porcelain\");\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parsePushResult\n  };\n}\nvar init_push = __esm({\n  \"src/lib/tasks/push.ts\"() {\n    \"use strict\";\n    init_parse_push();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/show.ts\nfunction show_default() {\n  return {\n    showBuffer() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      if (!commands.includes(\"--binary\")) {\n        commands.splice(1, 0, \"--binary\");\n      }\n      return this._runTask(\n        straightThroughBufferTask(commands),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    show() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      return this._runTask(\n        straightThroughStringTask(commands),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_show = __esm({\n  \"src/lib/tasks/show.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/responses/FileStatusSummary.ts\nvar fromPathRegex, FileStatusSummary;\nvar init_FileStatusSummary = __esm({\n  \"src/lib/responses/FileStatusSummary.ts\"() {\n    \"use strict\";\n    fromPathRegex = /^(.+)\\0(.+)$/;\n    FileStatusSummary = class {\n      constructor(path, index, working_dir) {\n        this.path = path;\n        this.index = index;\n        this.working_dir = working_dir;\n        if (index === \"R\" || working_dir === \"R\") {\n          const detail = fromPathRegex.exec(path) || [null, path, path];\n          this.from = detail[2] || \"\";\n          this.path = detail[1] || \"\";\n        }\n      }\n    };\n  }\n});\n\n// src/lib/responses/StatusSummary.ts\nfunction renamedFile(line) {\n  const [to, from] = line.split(NULL);\n  return {\n    from: from || to,\n    to\n  };\n}\nfunction parser3(indexX, indexY, handler) {\n  return [`${indexX}${indexY}`, handler];\n}\nfunction conflicts(indexX, ...indexY) {\n  return indexY.map((y) => parser3(indexX, y, (result, file) => append(result.conflicted, file)));\n}\nfunction splitLine(result, lineStr) {\n  const trimmed2 = lineStr.trim();\n  switch (\" \") {\n    case trimmed2.charAt(2):\n      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));\n    case trimmed2.charAt(1):\n      return data(\" \" /* NONE */, trimmed2.charAt(0), trimmed2.substr(2));\n    default:\n      return;\n  }\n  function data(index, workingDir, path) {\n    const raw = `${index}${workingDir}`;\n    const handler = parsers6.get(raw);\n    if (handler) {\n      handler(result, path);\n    }\n    if (raw !== \"##\" && raw !== \"!!\") {\n      result.files.push(new FileStatusSummary(path, index, workingDir));\n    }\n  }\n}\nvar StatusSummary, parsers6, parseStatusSummary;\nvar init_StatusSummary = __esm({\n  \"src/lib/responses/StatusSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_FileStatusSummary();\n    StatusSummary = class {\n      constructor() {\n        this.not_added = [];\n        this.conflicted = [];\n        this.created = [];\n        this.deleted = [];\n        this.ignored = void 0;\n        this.modified = [];\n        this.renamed = [];\n        this.files = [];\n        this.staged = [];\n        this.ahead = 0;\n        this.behind = 0;\n        this.current = null;\n        this.tracking = null;\n        this.detached = false;\n        this.isClean = () => {\n          return !this.files.length;\n        };\n      }\n    };\n    parsers6 = new Map([\n      parser3(\n        \" \" /* NONE */,\n        \"A\" /* ADDED */,\n        (result, file) => append(result.created, file)\n      ),\n      parser3(\n        \" \" /* NONE */,\n        \"D\" /* DELETED */,\n        (result, file) => append(result.deleted, file)\n      ),\n      parser3(\n        \" \" /* NONE */,\n        \"M\" /* MODIFIED */,\n        (result, file) => append(result.modified, file)\n      ),\n      parser3(\n        \"A\" /* ADDED */,\n        \" \" /* NONE */,\n        (result, file) => append(result.created, file) && append(result.staged, file)\n      ),\n      parser3(\n        \"A\" /* ADDED */,\n        \"M\" /* MODIFIED */,\n        (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)\n      ),\n      parser3(\n        \"D\" /* DELETED */,\n        \" \" /* NONE */,\n        (result, file) => append(result.deleted, file) && append(result.staged, file)\n      ),\n      parser3(\n        \"M\" /* MODIFIED */,\n        \" \" /* NONE */,\n        (result, file) => append(result.modified, file) && append(result.staged, file)\n      ),\n      parser3(\n        \"M\" /* MODIFIED */,\n        \"M\" /* MODIFIED */,\n        (result, file) => append(result.modified, file) && append(result.staged, file)\n      ),\n      parser3(\"R\" /* RENAMED */, \" \" /* NONE */, (result, file) => {\n        append(result.renamed, renamedFile(file));\n      }),\n      parser3(\"R\" /* RENAMED */, \"M\" /* MODIFIED */, (result, file) => {\n        const renamed = renamedFile(file);\n        append(result.renamed, renamed);\n        append(result.modified, renamed.to);\n      }),\n      parser3(\"!\" /* IGNORED */, \"!\" /* IGNORED */, (_result, _file) => {\n        append(_result.ignored = _result.ignored || [], _file);\n      }),\n      parser3(\n        \"?\" /* UNTRACKED */,\n        \"?\" /* UNTRACKED */,\n        (result, file) => append(result.not_added, file)\n      ),\n      ...conflicts(\"A\" /* ADDED */, \"A\" /* ADDED */, \"U\" /* UNMERGED */),\n      ...conflicts(\n        \"D\" /* DELETED */,\n        \"D\" /* DELETED */,\n        \"U\" /* UNMERGED */\n      ),\n      ...conflicts(\n        \"U\" /* UNMERGED */,\n        \"A\" /* ADDED */,\n        \"D\" /* DELETED */,\n        \"U\" /* UNMERGED */\n      ),\n      [\n        \"##\",\n        (result, line) => {\n          const aheadReg = /ahead (\\d+)/;\n          const behindReg = /behind (\\d+)/;\n          const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n          const trackingReg = /\\.{3}(\\S*)/;\n          const onEmptyBranchReg = /\\son\\s(\\S+?)(?=\\.{3}|$)/;\n          let regexResult = aheadReg.exec(line);\n          result.ahead = regexResult && +regexResult[1] || 0;\n          regexResult = behindReg.exec(line);\n          result.behind = regexResult && +regexResult[1] || 0;\n          regexResult = currentReg.exec(line);\n          result.current = filterType(regexResult?.[1], filterString, null);\n          regexResult = trackingReg.exec(line);\n          result.tracking = filterType(regexResult?.[1], filterString, null);\n          regexResult = onEmptyBranchReg.exec(line);\n          if (regexResult) {\n            result.current = filterType(regexResult?.[1], filterString, result.current);\n          }\n          result.detached = /\\(no branch\\)/.test(line);\n        }\n      ]\n    ]);\n    parseStatusSummary = function(text) {\n      const lines = text.split(NULL);\n      const status = new StatusSummary();\n      for (let i = 0, l = lines.length; i < l; ) {\n        let line = lines[i++].trim();\n        if (!line) {\n          continue;\n        }\n        if (line.charAt(0) === \"R\" /* RENAMED */) {\n          line += NULL + (lines[i++] || \"\");\n        }\n        splitLine(status, line);\n      }\n      return status;\n    };\n  }\n});\n\n// src/lib/tasks/status.ts\nfunction statusTask(customArgs) {\n  const commands = [\n    \"status\",\n    \"--porcelain\",\n    \"-b\",\n    \"-u\",\n    \"--null\",\n    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))\n  ];\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(text) {\n      return parseStatusSummary(text);\n    }\n  };\n}\nvar ignoredOptions;\nvar init_status = __esm({\n  \"src/lib/tasks/status.ts\"() {\n    \"use strict\";\n    init_StatusSummary();\n    ignoredOptions = [\"--null\", \"-z\"];\n  }\n});\n\n// src/lib/tasks/version.ts\nfunction versionResponse(major = 0, minor = 0, patch = 0, agent = \"\", installed = true) {\n  return Object.defineProperty(\n    {\n      major,\n      minor,\n      patch,\n      agent,\n      installed\n    },\n    \"toString\",\n    {\n      value() {\n        return `${this.major}.${this.minor}.${this.patch}`;\n      },\n      configurable: false,\n      enumerable: false\n    }\n  );\n}\nfunction notInstalledResponse() {\n  return versionResponse(0, 0, 0, \"\", false);\n}\nfunction version_default() {\n  return {\n    version() {\n      return this._runTask({\n        commands: [\"--version\"],\n        format: \"utf-8\",\n        parser: versionParser,\n        onError(result, error, done, fail) {\n          if (result.exitCode === -2 /* NOT_FOUND */) {\n            return done(Buffer.from(NOT_INSTALLED));\n          }\n          fail(error);\n        }\n      });\n    }\n  };\n}\nfunction versionParser(stdOut) {\n  if (stdOut === NOT_INSTALLED) {\n    return notInstalledResponse();\n  }\n  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);\n}\nvar NOT_INSTALLED, parsers7;\nvar init_version = __esm({\n  \"src/lib/tasks/version.ts\"() {\n    \"use strict\";\n    init_utils();\n    NOT_INSTALLED = \"installed=false\";\n    parsers7 = [\n      new LineParser(\n        /version (\\d+)\\.(\\d+)\\.(\\d+)(?:\\s*\\((.+)\\))?/,\n        (result, [major, minor, patch, agent = \"\"]) => {\n          Object.assign(\n            result,\n            versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent)\n          );\n        }\n      ),\n      new LineParser(\n        /version (\\d+)\\.(\\d+)\\.(\\D+)(.+)?$/,\n        (result, [major, minor, patch, agent = \"\"]) => {\n          Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/simple-git-api.ts\nvar simple_git_api_exports = {};\n__export(simple_git_api_exports, {\n  SimpleGitApi: () => SimpleGitApi\n});\nvar SimpleGitApi;\nvar init_simple_git_api = __esm({\n  \"src/lib/simple-git-api.ts\"() {\n    \"use strict\";\n    init_task_callback();\n    init_change_working_directory();\n    init_checkout();\n    init_count_objects();\n    init_commit();\n    init_config();\n    init_first_commit();\n    init_grep();\n    init_hash_object();\n    init_init();\n    init_log();\n    init_merge();\n    init_push();\n    init_show();\n    init_status();\n    init_task();\n    init_version();\n    init_utils();\n    SimpleGitApi = class {\n      constructor(_executor) {\n        this._executor = _executor;\n      }\n      _runTask(task, then) {\n        const chain = this._executor.chain();\n        const promise = chain.push(task);\n        if (then) {\n          taskCallback(task, promise, then);\n        }\n        return Object.create(this, {\n          then: { value: promise.then.bind(promise) },\n          catch: { value: promise.catch.bind(promise) },\n          _executor: { value: chain }\n        });\n      }\n      add(files) {\n        return this._runTask(\n          straightThroughStringTask([\"add\", ...asArray(files)]),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      cwd(directory) {\n        const next = trailingFunctionArgument(arguments);\n        if (typeof directory === \"string\") {\n          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n        }\n        if (typeof directory?.path === \"string\") {\n          return this._runTask(\n            changeWorkingDirectoryTask(\n              directory.path,\n              directory.root && this._executor || void 0\n            ),\n            next\n          );\n        }\n        return this._runTask(\n          configurationErrorTask(\"Git.cwd: workingDirectory must be supplied as a string\"),\n          next\n        );\n      }\n      hashObject(path, write) {\n        return this._runTask(\n          hashObjectTask(path, write === true),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      init(bare) {\n        return this._runTask(\n          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      merge() {\n        return this._runTask(\n          mergeTask(getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      mergeFromTo(remote, branch) {\n        if (!(filterString(remote) && filterString(branch))) {\n          return this._runTask(\n            configurationErrorTask(\n              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n            )\n          );\n        }\n        return this._runTask(\n          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n          trailingFunctionArgument(arguments, false)\n        );\n      }\n      outputHandler(handler) {\n        this._executor.outputHandler = handler;\n        return this;\n      }\n      push() {\n        const task = pushTask(\n          {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString)\n          },\n          getTrailingOptions(arguments)\n        );\n        return this._runTask(task, trailingFunctionArgument(arguments));\n      }\n      stash() {\n        return this._runTask(\n          straightThroughStringTask([\"stash\", ...getTrailingOptions(arguments)]),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      status() {\n        return this._runTask(\n          statusTask(getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n    };\n    Object.assign(\n      SimpleGitApi.prototype,\n      checkout_default(),\n      commit_default(),\n      config_default(),\n      count_objects_default(),\n      first_commit_default(),\n      grep_default(),\n      log_default(),\n      show_default(),\n      version_default()\n    );\n  }\n});\n\n// src/lib/runners/scheduler.ts\nvar scheduler_exports = {};\n__export(scheduler_exports, {\n  Scheduler: () => Scheduler\n});\n\nvar createScheduledTask, Scheduler;\nvar init_scheduler = __esm({\n  \"src/lib/runners/scheduler.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_git_logger();\n    createScheduledTask = /* @__PURE__ */ (() => {\n      let id = 0;\n      return () => {\n        id++;\n        const { promise, done } = (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.createDeferred)();\n        return {\n          promise,\n          done,\n          id\n        };\n      };\n    })();\n    Scheduler = class {\n      constructor(concurrency = 2) {\n        this.concurrency = concurrency;\n        this.logger = createLogger(\"\", \"scheduler\");\n        this.pending = [];\n        this.running = [];\n        this.logger(`Constructed, concurrency=%s`, concurrency);\n      }\n      schedule() {\n        if (!this.pending.length || this.running.length >= this.concurrency) {\n          this.logger(\n            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,\n            this.pending.length,\n            this.running.length,\n            this.concurrency\n          );\n          return;\n        }\n        const task = append(this.running, this.pending.shift());\n        this.logger(`Attempting id=%s`, task.id);\n        task.done(() => {\n          this.logger(`Completing id=`, task.id);\n          remove(this.running, task);\n          this.schedule();\n        });\n      }\n      next() {\n        const { promise, id } = append(this.pending, createScheduledTask());\n        this.logger(`Scheduling id=%s`, id);\n        this.schedule();\n        return promise;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/apply-patch.ts\nvar apply_patch_exports = {};\n__export(apply_patch_exports, {\n  applyPatchTask: () => applyPatchTask\n});\nfunction applyPatchTask(patches, customArgs) {\n  return straightThroughStringTask([\"apply\", ...customArgs, ...patches]);\n}\nvar init_apply_patch = __esm({\n  \"src/lib/tasks/apply-patch.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/BranchDeleteSummary.ts\nfunction branchDeletionSuccess(branch, hash) {\n  return {\n    branch,\n    hash,\n    success: true\n  };\n}\nfunction branchDeletionFailure(branch) {\n  return {\n    branch,\n    hash: null,\n    success: false\n  };\n}\nvar BranchDeletionBatch;\nvar init_BranchDeleteSummary = __esm({\n  \"src/lib/responses/BranchDeleteSummary.ts\"() {\n    \"use strict\";\n    BranchDeletionBatch = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.errors = [];\n      }\n      get success() {\n        return !this.errors.length;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch-delete.ts\nfunction hasBranchDeletionError(data, processExitCode) {\n  return processExitCode === 1 /* ERROR */ && deleteErrorRegex.test(data);\n}\nvar deleteSuccessRegex, deleteErrorRegex, parsers8, parseBranchDeletions;\nvar init_parse_branch_delete = __esm({\n  \"src/lib/parsers/parse-branch-delete.ts\"() {\n    \"use strict\";\n    init_BranchDeleteSummary();\n    init_utils();\n    deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\n    deleteErrorRegex = /^error[^']+'([^']+)'/m;\n    parsers8 = [\n      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n        const deletion = branchDeletionSuccess(branch, hash);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      }),\n      new LineParser(deleteErrorRegex, (result, [branch]) => {\n        const deletion = branchDeletionFailure(branch);\n        result.errors.push(deletion);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      })\n    ];\n    parseBranchDeletions = (stdOut, stdErr) => {\n      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/responses/BranchSummary.ts\nvar BranchSummaryResult;\nvar init_BranchSummary = __esm({\n  \"src/lib/responses/BranchSummary.ts\"() {\n    \"use strict\";\n    BranchSummaryResult = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.current = \"\";\n        this.detached = false;\n      }\n      push(status, detached, name, commit, label) {\n        if (status === \"*\" /* CURRENT */) {\n          this.detached = detached;\n          this.current = name;\n        }\n        this.all.push(name);\n        this.branches[name] = {\n          current: status === \"*\" /* CURRENT */,\n          linkedWorkTree: status === \"+\" /* LINKED */,\n          name,\n          commit,\n          label\n        };\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch.ts\nfunction branchStatus(input) {\n  return input ? input.charAt(0) : \"\";\n}\nfunction parseBranchSummary(stdOut, currentOnly = false) {\n  return parseStringResponse(\n    new BranchSummaryResult(),\n    currentOnly ? [currentBranchParser] : parsers9,\n    stdOut\n  );\n}\nvar parsers9, currentBranchParser;\nvar init_parse_branch = __esm({\n  \"src/lib/parsers/parse-branch.ts\"() {\n    \"use strict\";\n    init_BranchSummary();\n    init_utils();\n    parsers9 = [\n      new LineParser(\n        /^([*+]\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/,\n        (result, [current, name, commit, label]) => {\n          result.push(branchStatus(current), true, name, commit, label);\n        }\n      ),\n      new LineParser(\n        /^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s,\n        (result, [current, name, commit, label]) => {\n          result.push(branchStatus(current), false, name, commit, label);\n        }\n      )\n    ];\n    currentBranchParser = new LineParser(/^(\\S+)$/s, (result, [name]) => {\n      result.push(\"*\" /* CURRENT */, false, name, \"\", \"\");\n    });\n  }\n});\n\n// src/lib/tasks/branch.ts\nvar branch_exports = {};\n__export(branch_exports, {\n  branchLocalTask: () => branchLocalTask,\n  branchTask: () => branchTask,\n  containsDeleteBranchCommand: () => containsDeleteBranchCommand,\n  deleteBranchTask: () => deleteBranchTask,\n  deleteBranchesTask: () => deleteBranchesTask\n});\nfunction containsDeleteBranchCommand(commands) {\n  const deleteCommands = [\"-d\", \"-D\", \"--delete\"];\n  return commands.some((command) => deleteCommands.includes(command));\n}\nfunction branchTask(customArgs) {\n  const isDelete = containsDeleteBranchCommand(customArgs);\n  const isCurrentOnly = customArgs.includes(\"--show-current\");\n  const commands = [\"branch\", ...customArgs];\n  if (commands.length === 1) {\n    commands.push(\"-a\");\n  }\n  if (!commands.includes(\"-v\")) {\n    commands.splice(1, 0, \"-v\");\n  }\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(stdOut, stdErr) {\n      if (isDelete) {\n        return parseBranchDeletions(stdOut, stdErr).all[0];\n      }\n      return parseBranchSummary(stdOut, isCurrentOnly);\n    }\n  };\n}\nfunction branchLocalTask() {\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\"],\n    parser(stdOut) {\n      return parseBranchSummary(stdOut);\n    }\n  };\n}\nfunction deleteBranchesTask(branches, forceDelete = false) {\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", ...branches],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr);\n    },\n    onError({ exitCode, stdOut }, error, done, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      done(stdOut);\n    }\n  };\n}\nfunction deleteBranchTask(branch, forceDelete = false) {\n  const task = {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", branch],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr).branches[branch];\n    },\n    onError({ exitCode, stdErr, stdOut }, error, _, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      throw new GitResponseError(\n        task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n        String(error)\n      );\n    }\n  };\n  return task;\n}\nvar init_branch = __esm({\n  \"src/lib/tasks/branch.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_branch_delete();\n    init_parse_branch();\n    init_utils();\n  }\n});\n\n// src/lib/responses/CheckIgnore.ts\n\nfunction toPath(input) {\n  const path = input.trim().replace(/^[\"']|[\"']$/g, \"\");\n  return path && (0,node_path__WEBPACK_IMPORTED_MODULE_5__.normalize)(path);\n}\nvar parseCheckIgnore;\nvar init_CheckIgnore = __esm({\n  \"src/lib/responses/CheckIgnore.ts\"() {\n    \"use strict\";\n    parseCheckIgnore = (text) => {\n      return text.split(/\\n/g).map(toPath).filter(Boolean);\n    };\n  }\n});\n\n// src/lib/tasks/check-ignore.ts\nvar check_ignore_exports = {};\n__export(check_ignore_exports, {\n  checkIgnoreTask: () => checkIgnoreTask\n});\nfunction checkIgnoreTask(paths) {\n  return {\n    commands: [\"check-ignore\", ...paths],\n    format: \"utf-8\",\n    parser: parseCheckIgnore\n  };\n}\nvar init_check_ignore = __esm({\n  \"src/lib/tasks/check-ignore.ts\"() {\n    \"use strict\";\n    init_CheckIgnore();\n  }\n});\n\n// src/lib/tasks/clone.ts\nvar clone_exports = {};\n__export(clone_exports, {\n  cloneMirrorTask: () => cloneMirrorTask,\n  cloneTask: () => cloneTask\n});\nfunction disallowedCommand(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction cloneTask(repo, directory, customArgs) {\n  const commands = [\"clone\", ...customArgs];\n  filterString(repo) && commands.push(repo);\n  filterString(directory) && commands.push(directory);\n  const banned = commands.find(disallowedCommand);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return straightThroughStringTask(commands);\n}\nfunction cloneMirrorTask(repo, directory, customArgs) {\n  append(customArgs, \"--mirror\");\n  return cloneTask(repo, directory, customArgs);\n}\nvar init_clone = __esm({\n  \"src/lib/tasks/clone.ts\"() {\n    \"use strict\";\n    init_task();\n    init_utils();\n  }\n});\n\n// src/lib/parsers/parse-fetch.ts\nfunction parseFetchResult(stdOut, stdErr) {\n  const result = {\n    raw: stdOut,\n    remote: null,\n    branches: [],\n    tags: [],\n    updated: [],\n    deleted: []\n  };\n  return parseStringResponse(result, parsers10, [stdOut, stdErr]);\n}\nvar parsers10;\nvar init_parse_fetch = __esm({\n  \"src/lib/parsers/parse-fetch.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers10 = [\n      new LineParser(/From (.+)$/, (result, [remote]) => {\n        result.remote = remote;\n      }),\n      new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.branches.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.tags.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/- \\[deleted]\\s+\\S+\\s*-> (.+)$/, (result, [tracking]) => {\n        result.deleted.push({\n          tracking\n        });\n      }),\n      new LineParser(\n        /\\s*([^.]+)\\.\\.(\\S+)\\s+(\\S+)\\s*-> (.+)$/,\n        (result, [from, to, name, tracking]) => {\n          result.updated.push({\n            name,\n            tracking,\n            to,\n            from\n          });\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/fetch.ts\nvar fetch_exports = {};\n__export(fetch_exports, {\n  fetchTask: () => fetchTask\n});\nfunction disallowedCommand2(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction fetchTask(remote, branch, customArgs) {\n  const commands = [\"fetch\", ...customArgs];\n  if (remote && branch) {\n    commands.push(remote, branch);\n  }\n  const banned = commands.find(disallowedCommand2);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseFetchResult\n  };\n}\nvar init_fetch = __esm({\n  \"src/lib/tasks/fetch.ts\"() {\n    \"use strict\";\n    init_parse_fetch();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-move.ts\nfunction parseMoveResult(stdOut) {\n  return parseStringResponse({ moves: [] }, parsers11, stdOut);\n}\nvar parsers11;\nvar init_parse_move = __esm({\n  \"src/lib/parsers/parse-move.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers11 = [\n      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n        result.moves.push({ from, to });\n      })\n    ];\n  }\n});\n\n// src/lib/tasks/move.ts\nvar move_exports = {};\n__export(move_exports, {\n  moveTask: () => moveTask\n});\nfunction moveTask(from, to) {\n  return {\n    commands: [\"mv\", \"-v\", ...asArray(from), to],\n    format: \"utf-8\",\n    parser: parseMoveResult\n  };\n}\nvar init_move = __esm({\n  \"src/lib/tasks/move.ts\"() {\n    \"use strict\";\n    init_parse_move();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/pull.ts\nvar pull_exports = {};\n__export(pull_exports, {\n  pullTask: () => pullTask\n});\nfunction pullTask(remote, branch, customArgs) {\n  const commands = [\"pull\", ...customArgs];\n  if (remote && branch) {\n    commands.splice(1, 0, remote, branch);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      return parsePullResult(stdOut, stdErr);\n    },\n    onError(result, _error, _done, fail) {\n      const pullError = parsePullErrorResult(\n        bufferToString(result.stdOut),\n        bufferToString(result.stdErr)\n      );\n      if (pullError) {\n        return fail(new GitResponseError(pullError));\n      }\n      fail(_error);\n    }\n  };\n}\nvar init_pull = __esm({\n  \"src/lib/tasks/pull.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_pull();\n    init_utils();\n  }\n});\n\n// src/lib/responses/GetRemoteSummary.ts\nfunction parseGetRemotes(text) {\n  const remotes = {};\n  forEach(text, ([name]) => remotes[name] = { name });\n  return Object.values(remotes);\n}\nfunction parseGetRemotesVerbose(text) {\n  const remotes = {};\n  forEach(text, ([name, url, purpose]) => {\n    if (!Object.hasOwn(remotes, name)) {\n      remotes[name] = {\n        name,\n        refs: { fetch: \"\", push: \"\" }\n      };\n    }\n    if (purpose && url) {\n      remotes[name].refs[purpose.replace(/[^a-z]/g, \"\")] = url;\n    }\n  });\n  return Object.values(remotes);\n}\nfunction forEach(text, handler) {\n  forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\nvar init_GetRemoteSummary = __esm({\n  \"src/lib/responses/GetRemoteSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n  }\n});\n\n// src/lib/tasks/remote.ts\nvar remote_exports = {};\n__export(remote_exports, {\n  addRemoteTask: () => addRemoteTask,\n  getRemotesTask: () => getRemotesTask,\n  listRemotesTask: () => listRemotesTask,\n  remoteTask: () => remoteTask,\n  removeRemoteTask: () => removeRemoteTask\n});\nfunction addRemoteTask(remoteName, remoteRepo, customArgs) {\n  return straightThroughStringTask([\"remote\", \"add\", ...customArgs, remoteName, remoteRepo]);\n}\nfunction getRemotesTask(verbose) {\n  const commands = [\"remote\"];\n  if (verbose) {\n    commands.push(\"-v\");\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes\n  };\n}\nfunction listRemotesTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"ls-remote\") {\n    commands.unshift(\"ls-remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction remoteTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"remote\") {\n    commands.unshift(\"remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction removeRemoteTask(remoteName) {\n  return straightThroughStringTask([\"remote\", \"remove\", remoteName]);\n}\nvar init_remote = __esm({\n  \"src/lib/tasks/remote.ts\"() {\n    \"use strict\";\n    init_GetRemoteSummary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/stash-list.ts\nvar stash_list_exports = {};\n__export(stash_list_exports, {\n  stashListTask: () => stashListTask\n});\nfunction stashListTask(opt = {}, customArgs) {\n  const options = parseLogOptions(opt);\n  const commands = [\"stash\", \"list\", ...options.commands, ...customArgs];\n  const parser4 = createListLogSummaryParser(\n    options.splitter,\n    options.fields,\n    logFormatFromCommand(commands)\n  );\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: parser4\n  };\n}\nvar init_stash_list = __esm({\n  \"src/lib/tasks/stash-list.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_parse_list_log_summary();\n    init_diff();\n    init_log();\n  }\n});\n\n// src/lib/tasks/sub-module.ts\nvar sub_module_exports = {};\n__export(sub_module_exports, {\n  addSubModuleTask: () => addSubModuleTask,\n  initSubModuleTask: () => initSubModuleTask,\n  subModuleTask: () => subModuleTask,\n  updateSubModuleTask: () => updateSubModuleTask\n});\nfunction addSubModuleTask(repo, path) {\n  return subModuleTask([\"add\", repo, path]);\n}\nfunction initSubModuleTask(customArgs) {\n  return subModuleTask([\"init\", ...customArgs]);\n}\nfunction subModuleTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"submodule\") {\n    commands.unshift(\"submodule\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction updateSubModuleTask(customArgs) {\n  return subModuleTask([\"update\", ...customArgs]);\n}\nvar init_sub_module = __esm({\n  \"src/lib/tasks/sub-module.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/TagList.ts\nfunction singleSorted(a, b) {\n  const aIsNum = Number.isNaN(a);\n  const bIsNum = Number.isNaN(b);\n  if (aIsNum !== bIsNum) {\n    return aIsNum ? 1 : -1;\n  }\n  return aIsNum ? sorted(a, b) : 0;\n}\nfunction sorted(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction trimmed(input) {\n  return input.trim();\n}\nfunction toNumber(input) {\n  if (typeof input === \"string\") {\n    return parseInt(input.replace(/^\\D+/g, \"\"), 10) || 0;\n  }\n  return 0;\n}\nvar TagList, parseTagList;\nvar init_TagList = __esm({\n  \"src/lib/responses/TagList.ts\"() {\n    \"use strict\";\n    TagList = class {\n      constructor(all, latest) {\n        this.all = all;\n        this.latest = latest;\n      }\n    };\n    parseTagList = function(data, customSort = false) {\n      const tags = data.split(\"\\n\").map(trimmed).filter(Boolean);\n      if (!customSort) {\n        tags.sort(function(tagA, tagB) {\n          const partsA = tagA.split(\".\");\n          const partsB = tagB.split(\".\");\n          if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n          }\n          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n            if (diff) {\n              return diff;\n            }\n          }\n          return 0;\n        });\n      }\n      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(\".\") >= 0);\n      return new TagList(tags, latest);\n    };\n  }\n});\n\n// src/lib/tasks/tag.ts\nvar tag_exports = {};\n__export(tag_exports, {\n  addAnnotatedTagTask: () => addAnnotatedTagTask,\n  addTagTask: () => addTagTask,\n  tagListTask: () => tagListTask\n});\nfunction tagListTask(customArgs = []) {\n  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-l\", ...customArgs],\n    parser(text) {\n      return parseTagList(text, hasCustomSort);\n    }\n  };\n}\nfunction addTagTask(name) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", name],\n    parser() {\n      return { name };\n    }\n  };\n}\nfunction addAnnotatedTagTask(name, tagMessage) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-a\", \"-m\", tagMessage, name],\n    parser() {\n      return { name };\n    }\n  };\n}\nvar init_tag = __esm({\n  \"src/lib/tasks/tag.ts\"() {\n    \"use strict\";\n    init_TagList();\n  }\n});\n\n// src/git.js\nvar require_git = __commonJS({\n  \"src/git.js\"(exports, module) {\n    \"use strict\";\n    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));\n    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));\n    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));\n    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));\n    var {\n      asArray: asArray2,\n      filterArray: filterArray2,\n      filterPrimitives: filterPrimitives2,\n      filterString: filterString2,\n      filterStringOrStringArray: filterStringOrStringArray2,\n      filterType: filterType2,\n      getTrailingOptions: getTrailingOptions2,\n      trailingFunctionArgument: trailingFunctionArgument2,\n      trailingOptionsArgument: trailingOptionsArgument2\n    } = (init_utils(), __toCommonJS(utils_exports));\n    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));\n    var {\n      branchTask: branchTask2,\n      branchLocalTask: branchLocalTask2,\n      deleteBranchesTask: deleteBranchesTask2,\n      deleteBranchTask: deleteBranchTask2\n    } = (init_branch(), __toCommonJS(branch_exports));\n    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));\n    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));\n    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));\n    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));\n    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));\n    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));\n    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));\n    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));\n    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));\n    var {\n      addRemoteTask: addRemoteTask2,\n      getRemotesTask: getRemotesTask2,\n      listRemotesTask: listRemotesTask2,\n      remoteTask: remoteTask2,\n      removeRemoteTask: removeRemoteTask2\n    } = (init_remote(), __toCommonJS(remote_exports));\n    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));\n    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));\n    var {\n      addSubModuleTask: addSubModuleTask2,\n      initSubModuleTask: initSubModuleTask2,\n      subModuleTask: subModuleTask2,\n      updateSubModuleTask: updateSubModuleTask2\n    } = (init_sub_module(), __toCommonJS(sub_module_exports));\n    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));\n    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));\n    function Git2(options, plugins) {\n      this._plugins = plugins;\n      this._executor = new GitExecutor2(\n        options.baseDir,\n        new Scheduler2(options.maxConcurrentProcesses),\n        plugins\n      );\n      this._trimmed = options.trimmed;\n    }\n    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;\n    Git2.prototype.customBinary = function(command) {\n      this._plugins.reconfigure(\"binary\", command);\n      return this;\n    };\n    Git2.prototype.env = function(name, value) {\n      if (arguments.length === 1 && typeof name === \"object\") {\n        this._executor.env = name;\n      } else {\n        (this._executor.env = this._executor.env || {})[name] = value;\n      }\n      return this;\n    };\n    Git2.prototype.stashList = function(options) {\n      return this._runTask(\n        stashListTask2(\n          trailingOptionsArgument2(arguments) || {},\n          filterArray2(options) && options || []\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    function createCloneTask(api, task, repoPath, localPath) {\n      if (typeof repoPath !== \"string\") {\n        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);\n      }\n      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));\n    }\n    Git2.prototype.clone = function() {\n      return this._runTask(\n        createCloneTask(\"clone\", cloneTask2, ...arguments),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.mirror = function() {\n      return this._runTask(\n        createCloneTask(\"mirror\", cloneMirrorTask2, ...arguments),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.mv = function(from, to) {\n      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.checkoutLatestTag = function(then) {\n      var git = this;\n      return this.pull(function() {\n        git.tags(function(err, tags) {\n          git.checkout(tags.latest, then);\n        });\n      });\n    };\n    Git2.prototype.pull = function(remote, branch, options, then) {\n      return this._runTask(\n        pullTask2(\n          filterType2(remote, filterString2),\n          filterType2(branch, filterString2),\n          getTrailingOptions2(arguments)\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.fetch = function(remote, branch) {\n      return this._runTask(\n        fetchTask2(\n          filterType2(remote, filterString2),\n          filterType2(branch, filterString2),\n          getTrailingOptions2(arguments)\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.silent = function(silence) {\n      console.warn(\n        \"simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3\"\n      );\n      return this;\n    };\n    Git2.prototype.tags = function(options, then) {\n      return this._runTask(\n        tagListTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.rebase = function() {\n      return this._runTask(\n        straightThroughStringTask2([\"rebase\", ...getTrailingOptions2(arguments)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.reset = function(mode) {\n      return this._runTask(\n        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.revert = function(commit) {\n      const next = trailingFunctionArgument2(arguments);\n      if (typeof commit !== \"string\") {\n        return this._runTask(configurationErrorTask2(\"Commit must be a string\"), next);\n      }\n      return this._runTask(\n        straightThroughStringTask2([\"revert\", ...getTrailingOptions2(arguments, 0, true), commit]),\n        next\n      );\n    };\n    Git2.prototype.addTag = function(name) {\n      const task = typeof name === \"string\" ? addTagTask2(name) : configurationErrorTask2(\"Git.addTag requires a tag name\");\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {\n      return this._runTask(\n        addAnnotatedTagTask2(tagName, tagMessage),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {\n      return this._runTask(\n        deleteBranchTask2(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {\n      return this._runTask(\n        deleteBranchesTask2(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.branch = function(options, then) {\n      return this._runTask(\n        branchTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.branchLocal = function(then) {\n      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.raw = function(commands) {\n      const createRestCommands = !Array.isArray(commands);\n      const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n      for (let i = 0; i < command.length && createRestCommands; i++) {\n        if (!filterPrimitives2(command[i])) {\n          command.splice(i, command.length - i);\n          break;\n        }\n      }\n      command.push(...getTrailingOptions2(arguments, 0, true));\n      var next = trailingFunctionArgument2(arguments);\n      if (!command.length) {\n        return this._runTask(\n          configurationErrorTask2(\"Raw: must supply one or more command to execute\"),\n          next\n        );\n      }\n      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);\n    };\n    Git2.prototype.submoduleAdd = function(repo, path, then) {\n      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.submoduleUpdate = function(args, then) {\n      return this._runTask(\n        updateSubModuleTask2(getTrailingOptions2(arguments, true)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.submoduleInit = function(args, then) {\n      return this._runTask(\n        initSubModuleTask2(getTrailingOptions2(arguments, true)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.subModule = function(options, then) {\n      return this._runTask(\n        subModuleTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.listRemote = function() {\n      return this._runTask(\n        listRemotesTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {\n      return this._runTask(\n        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.removeRemote = function(remoteName, then) {\n      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.getRemotes = function(verbose, then) {\n      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.remote = function(options, then) {\n      return this._runTask(\n        remoteTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.tag = function(options, then) {\n      const command = getTrailingOptions2(arguments);\n      if (command[0] !== \"tag\") {\n        command.unshift(\"tag\");\n      }\n      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.updateServerInfo = function(then) {\n      return this._runTask(\n        straightThroughStringTask2([\"update-server-info\"]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.pushTags = function(remote, then) {\n      const task = pushTagsTask2(\n        { remote: filterType2(remote, filterString2) },\n        getTrailingOptions2(arguments)\n      );\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rm = function(files) {\n      return this._runTask(\n        straightThroughStringTask2([\"rm\", \"-f\", ...asArray2(files)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.rmKeepLocal = function(files) {\n      return this._runTask(\n        straightThroughStringTask2([\"rm\", \"--cached\", ...asArray2(files)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.catFile = function(options, then) {\n      return this._catFile(\"utf-8\", arguments);\n    };\n    Git2.prototype.binaryCatFile = function() {\n      return this._catFile(\"buffer\", arguments);\n    };\n    Git2.prototype._catFile = function(format, args) {\n      var handler = trailingFunctionArgument2(args);\n      var command = [\"cat-file\"];\n      var options = args[0];\n      if (typeof options === \"string\") {\n        return this._runTask(\n          configurationErrorTask2(\"Git.catFile: options must be supplied as an array of strings\"),\n          handler\n        );\n      }\n      if (Array.isArray(options)) {\n        command.push.apply(command, options);\n      }\n      const task = format === \"buffer\" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);\n      return this._runTask(task, handler);\n    };\n    Git2.prototype.diff = function(options, then) {\n      const task = filterString2(options) ? configurationErrorTask2(\n        \"git.diff: supplying options as a single string is no longer supported, switch to an array of strings\"\n      ) : straightThroughStringTask2([\"diff\", ...getTrailingOptions2(arguments)]);\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.diffSummary = function() {\n      return this._runTask(\n        diffSummaryTask2(getTrailingOptions2(arguments, 1)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.applyPatch = function(patches) {\n      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(\n        `git.applyPatch requires one or more string patches as the first argument`\n      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.revparse = function() {\n      const commands = [\"rev-parse\", ...getTrailingOptions2(arguments, true)];\n      return this._runTask(\n        straightThroughStringTask2(commands, true),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.clean = function(mode, options, then) {\n      const usingCleanOptionsArray = isCleanOptionsArray2(mode);\n      const cleanMode = usingCleanOptionsArray && mode.join(\"\") || filterType2(mode, filterString2) || \"\";\n      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n      return this._runTask(\n        cleanWithOptionsTask2(cleanMode, customArgs),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.exec = function(then) {\n      const task = {\n        commands: [],\n        format: \"utf-8\",\n        parser() {\n          if (typeof then === \"function\") {\n            then();\n          }\n        }\n      };\n      return this._runTask(task);\n    };\n    Git2.prototype.clearQueue = function() {\n      return this;\n    };\n    Git2.prototype.checkIgnore = function(pathnames, then) {\n      return this._runTask(\n        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.checkIsRepo = function(checkType, then) {\n      return this._runTask(\n        checkIsRepoTask2(filterType2(checkType, filterString2)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    module.exports = Git2;\n  }\n});\n\n// src/lib/api.ts\ninit_pathspec();\n\n// src/lib/errors/git-construct-error.ts\ninit_git_error();\nvar GitConstructError = class extends GitError {\n  constructor(config, message) {\n    super(void 0, message);\n    this.config = config;\n  }\n};\n\n// src/lib/api.ts\ninit_git_error();\n\n// src/lib/errors/git-plugin-error.ts\ninit_git_error();\nvar GitPluginError = class extends GitError {\n  constructor(task, plugin, message) {\n    super(task, message);\n    this.task = task;\n    this.plugin = plugin;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\n\n// src/lib/api.ts\ninit_git_response_error();\ninit_task_configuration_error();\ninit_check_is_repo();\ninit_clean();\ninit_config();\ninit_diff_name_status();\ninit_grep();\ninit_reset();\n\n// src/lib/plugins/abort-plugin.ts\nfunction abortPlugin(signal) {\n  if (!signal) {\n    return;\n  }\n  const onSpawnAfter = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      function kill() {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort signal received\"));\n      }\n      signal.addEventListener(\"abort\", kill);\n      context.spawned.on(\"close\", () => signal.removeEventListener(\"abort\", kill));\n    }\n  };\n  const onSpawnBefore = {\n    type: \"spawn.before\",\n    action(_data, context) {\n      if (signal.aborted) {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort already signaled\"));\n      }\n    }\n  };\n  return [onSpawnBefore, onSpawnAfter];\n}\n\n// src/lib/plugins/block-unsafe-operations-plugin.ts\nfunction isConfigSwitch(arg) {\n  return typeof arg === \"string\" && arg.trim().toLowerCase() === \"-c\";\n}\nfunction preventProtocolOverride(arg, next) {\n  if (!isConfigSwitch(arg)) {\n    return;\n  }\n  if (!/^\\s*protocol(.[a-z]+)?.allow/.test(next)) {\n    return;\n  }\n  throw new GitPluginError(\n    void 0,\n    \"unsafe\",\n    \"Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol\"\n  );\n}\nfunction preventUploadPack(arg, method) {\n  if (/^\\s*--(upload|receive)-pack/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`\n    );\n  }\n  if (method === \"clone\" && /^\\s*-u\\b/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of clone with option -u is not permitted without enabling allowUnsafePack`\n    );\n  }\n  if (method === \"push\" && /^\\s*--exec\\b/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of push with option --exec is not permitted without enabling allowUnsafePack`\n    );\n  }\n}\nfunction blockUnsafeOperationsPlugin({\n  allowUnsafeProtocolOverride = false,\n  allowUnsafePack = false\n} = {}) {\n  return {\n    type: \"spawn.args\",\n    action(args, context) {\n      args.forEach((current, index) => {\n        const next = index < args.length ? args[index + 1] : \"\";\n        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);\n        allowUnsafePack || preventUploadPack(current, context.method);\n      });\n      return args;\n    }\n  };\n}\n\n// src/lib/plugins/command-config-prefixing-plugin.ts\ninit_utils();\nfunction commandConfigPrefixingPlugin(configuration) {\n  const prefix = prefixedArray(configuration, \"-c\");\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      return [...prefix, ...data];\n    }\n  };\n}\n\n// src/lib/plugins/completion-detection.plugin.ts\ninit_utils();\n\nvar never = (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.deferred)().promise;\nfunction completionDetectionPlugin({\n  onClose = true,\n  onExit = 50\n} = {}) {\n  function createEvents() {\n    let exitCode = -1;\n    const events = {\n      close: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.deferred)(),\n      closeTimeout: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.deferred)(),\n      exit: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.deferred)(),\n      exitTimeout: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_4__.deferred)()\n    };\n    const result = Promise.race([\n      onClose === false ? never : events.closeTimeout.promise,\n      onExit === false ? never : events.exitTimeout.promise\n    ]);\n    configureTimeout(onClose, events.close, events.closeTimeout);\n    configureTimeout(onExit, events.exit, events.exitTimeout);\n    return {\n      close(code) {\n        exitCode = code;\n        events.close.done();\n      },\n      exit(code) {\n        exitCode = code;\n        events.exit.done();\n      },\n      get exitCode() {\n        return exitCode;\n      },\n      result\n    };\n  }\n  function configureTimeout(flag, event, timeout) {\n    if (flag === false) {\n      return;\n    }\n    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n  }\n  return {\n    type: \"spawn.after\",\n    async action(_data, { spawned, close }) {\n      const events = createEvents();\n      let deferClose = true;\n      let quickClose = () => void (deferClose = false);\n      spawned.stdout?.on(\"data\", quickClose);\n      spawned.stderr?.on(\"data\", quickClose);\n      spawned.on(\"error\", quickClose);\n      spawned.on(\"close\", (code) => events.close(code));\n      spawned.on(\"exit\", (code) => events.exit(code));\n      try {\n        await events.result;\n        if (deferClose) {\n          await delay(50);\n        }\n        close(events.exitCode);\n      } catch (err) {\n        close(events.exitCode, err);\n      }\n    }\n  };\n}\n\n// src/lib/plugins/custom-binary.plugin.ts\ninit_utils();\nvar WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;\nvar WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;\nfunction isBadArgument(arg) {\n  return !arg || !/^([a-z]:)?([a-z0-9/.\\\\_-]+)$/i.test(arg);\n}\nfunction toBinaryConfig(input, allowUnsafe) {\n  if (input.length < 1 || input.length > 2) {\n    throw new GitPluginError(void 0, \"binary\", WRONG_NUMBER_ERR);\n  }\n  const isBad = input.some(isBadArgument);\n  if (isBad) {\n    if (allowUnsafe) {\n      console.warn(WRONG_CHARS_ERR);\n    } else {\n      throw new GitPluginError(void 0, \"binary\", WRONG_CHARS_ERR);\n    }\n  }\n  const [binary, prefix] = input;\n  return {\n    binary,\n    prefix\n  };\n}\nfunction customBinaryPlugin(plugins, input = [\"git\"], allowUnsafe = false) {\n  let config = toBinaryConfig(asArray(input), allowUnsafe);\n  plugins.on(\"binary\", (input2) => {\n    config = toBinaryConfig(asArray(input2), allowUnsafe);\n  });\n  plugins.append(\"spawn.binary\", () => {\n    return config.binary;\n  });\n  plugins.append(\"spawn.args\", (data) => {\n    return config.prefix ? [config.prefix, ...data] : data;\n  });\n}\n\n// src/lib/plugins/error-detection.plugin.ts\ninit_git_error();\nfunction isTaskError(result) {\n  return !!(result.exitCode && result.stdErr.length);\n}\nfunction getErrorMessage(result) {\n  return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\nfunction errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {\n  return (error, result) => {\n    if (!overwrite && error || !isError(result)) {\n      return error;\n    }\n    return errorMessage(result);\n  };\n}\nfunction errorDetectionPlugin(config) {\n  return {\n    type: \"task.error\",\n    action(data, context) {\n      const error = config(data.error, {\n        stdErr: context.stdErr,\n        stdOut: context.stdOut,\n        exitCode: context.exitCode\n      });\n      if (Buffer.isBuffer(error)) {\n        return { error: new GitError(void 0, error.toString(\"utf-8\")) };\n      }\n      return {\n        error\n      };\n    }\n  };\n}\n\n// src/lib/plugins/plugin-store.ts\ninit_utils();\n\nvar PluginStore = class {\n  constructor() {\n    this.plugins = /* @__PURE__ */ new Set();\n    this.events = new node_events__WEBPACK_IMPORTED_MODULE_6__.EventEmitter();\n  }\n  on(type, listener) {\n    this.events.on(type, listener);\n  }\n  reconfigure(type, data) {\n    this.events.emit(type, data);\n  }\n  append(type, action) {\n    const plugin = append(this.plugins, { type, action });\n    return () => this.plugins.delete(plugin);\n  }\n  add(plugin) {\n    const plugins = [];\n    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));\n    return () => {\n      plugins.forEach((plugin2) => this.plugins.delete(plugin2));\n    };\n  }\n  exec(type, data, context) {\n    let output = data;\n    const contextual = Object.freeze(Object.create(context));\n    for (const plugin of this.plugins) {\n      if (plugin.type === type) {\n        output = plugin.action(output, contextual);\n      }\n    }\n    return output;\n  }\n};\n\n// src/lib/plugins/progress-monitor-plugin.ts\ninit_utils();\nfunction progressMonitorPlugin(progress) {\n  const progressCommand = \"--progress\";\n  const progressMethods = [\"checkout\", \"clone\", \"fetch\", \"pull\", \"push\"];\n  const onProgress = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      if (!context.commands.includes(progressCommand)) {\n        return;\n      }\n      context.spawned.stderr?.on(\"data\", (chunk) => {\n        const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString(\"utf8\"));\n        if (!message) {\n          return;\n        }\n        progress({\n          method: context.method,\n          stage: progressEventStage(message[1]),\n          progress: asNumber(message[2]),\n          processed: asNumber(message[3]),\n          total: asNumber(message[4])\n        });\n      });\n    }\n  };\n  const onArgs = {\n    type: \"spawn.args\",\n    action(args, context) {\n      if (!progressMethods.includes(context.method)) {\n        return args;\n      }\n      return including(args, progressCommand);\n    }\n  };\n  return [onArgs, onProgress];\n}\nfunction progressEventStage(input) {\n  return String(input.toLowerCase().split(\" \", 1)) || \"unknown\";\n}\n\n// src/lib/plugins/spawn-options-plugin.ts\ninit_utils();\nfunction spawnOptionsPlugin(spawnOptions) {\n  const options = pick(spawnOptions, [\"uid\", \"gid\"]);\n  return {\n    type: \"spawn.options\",\n    action(data) {\n      return { ...options, ...data };\n    }\n  };\n}\n\n// src/lib/plugins/timout-plugin.ts\nfunction timeoutPlugin({\n  block,\n  stdErr = true,\n  stdOut = true\n}) {\n  if (block > 0) {\n    return {\n      type: \"spawn.after\",\n      action(_data, context) {\n        let timeout;\n        function wait() {\n          timeout && clearTimeout(timeout);\n          timeout = setTimeout(kill, block);\n        }\n        function stop() {\n          context.spawned.stdout?.off(\"data\", wait);\n          context.spawned.stderr?.off(\"data\", wait);\n          context.spawned.off(\"exit\", stop);\n          context.spawned.off(\"close\", stop);\n          timeout && clearTimeout(timeout);\n        }\n        function kill() {\n          stop();\n          context.kill(new GitPluginError(void 0, \"timeout\", `block timeout reached`));\n        }\n        stdOut && context.spawned.stdout?.on(\"data\", wait);\n        stdErr && context.spawned.stderr?.on(\"data\", wait);\n        context.spawned.on(\"exit\", stop);\n        context.spawned.on(\"close\", stop);\n        wait();\n      }\n    };\n  }\n}\n\n// src/lib/plugins/suffix-paths.plugin.ts\ninit_pathspec();\nfunction suffixPathsPlugin() {\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      const prefix = [];\n      let suffix;\n      function append2(args) {\n        (suffix = suffix || []).push(...args);\n      }\n      for (let i = 0; i < data.length; i++) {\n        const param = data[i];\n        if (isPathSpec(param)) {\n          append2(toPaths(param));\n          continue;\n        }\n        if (param === \"--\") {\n          append2(\n            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)\n          );\n          break;\n        }\n        prefix.push(param);\n      }\n      return !suffix ? prefix : [...prefix, \"--\", ...suffix.map(String)];\n    }\n  };\n}\n\n// src/lib/git-factory.ts\ninit_utils();\nvar Git = require_git();\nfunction gitInstanceFactory(baseDir, options) {\n  const plugins = new PluginStore();\n  const config = createInstanceConfig(\n    baseDir && (typeof baseDir === \"string\" ? { baseDir } : baseDir) || {},\n    options\n  );\n  if (!folderExists(config.baseDir)) {\n    throw new GitConstructError(\n      config,\n      `Cannot use simple-git on a directory that does not exist`\n    );\n  }\n  if (Array.isArray(config.config)) {\n    plugins.add(commandConfigPrefixingPlugin(config.config));\n  }\n  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));\n  plugins.add(suffixPathsPlugin());\n  plugins.add(completionDetectionPlugin(config.completion));\n  config.abort && plugins.add(abortPlugin(config.abort));\n  config.progress && plugins.add(progressMonitorPlugin(config.progress));\n  config.timeout && plugins.add(timeoutPlugin(config.timeout));\n  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n  config.errors && plugins.add(errorDetectionPlugin(config.errors));\n  customBinaryPlugin(plugins, config.binary, config.unsafe?.allowUnsafeCustomBinary);\n  return new Git(config, plugins);\n}\n\n// src/lib/runners/promise-wrapped.ts\ninit_git_response_error();\nvar functionNamesBuilderApi = [\"customBinary\", \"env\", \"outputHandler\", \"silent\"];\nvar functionNamesPromiseApi = [\n  \"add\",\n  \"addAnnotatedTag\",\n  \"addConfig\",\n  \"addRemote\",\n  \"addTag\",\n  \"applyPatch\",\n  \"binaryCatFile\",\n  \"branch\",\n  \"branchLocal\",\n  \"catFile\",\n  \"checkIgnore\",\n  \"checkIsRepo\",\n  \"checkout\",\n  \"checkoutBranch\",\n  \"checkoutLatestTag\",\n  \"checkoutLocalBranch\",\n  \"clean\",\n  \"clone\",\n  \"commit\",\n  \"cwd\",\n  \"deleteLocalBranch\",\n  \"deleteLocalBranches\",\n  \"diff\",\n  \"diffSummary\",\n  \"exec\",\n  \"fetch\",\n  \"getRemotes\",\n  \"init\",\n  \"listConfig\",\n  \"listRemote\",\n  \"log\",\n  \"merge\",\n  \"mergeFromTo\",\n  \"mirror\",\n  \"mv\",\n  \"pull\",\n  \"push\",\n  \"pushTags\",\n  \"raw\",\n  \"rebase\",\n  \"remote\",\n  \"removeRemote\",\n  \"reset\",\n  \"revert\",\n  \"revparse\",\n  \"rm\",\n  \"rmKeepLocal\",\n  \"show\",\n  \"stash\",\n  \"stashList\",\n  \"status\",\n  \"subModule\",\n  \"submoduleAdd\",\n  \"submoduleInit\",\n  \"submoduleUpdate\",\n  \"tag\",\n  \"tags\",\n  \"updateServerInfo\"\n];\nfunction gitP(...args) {\n  let git;\n  let chain = Promise.resolve();\n  try {\n    git = gitInstanceFactory(...args);\n  } catch (e) {\n    chain = Promise.reject(e);\n  }\n  function builderReturn() {\n    return promiseApi;\n  }\n  function chainReturn() {\n    return chain;\n  }\n  const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce(\n    (api, name) => {\n      const isAsync = functionNamesPromiseApi.includes(name);\n      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n      const alternative = isAsync ? chainReturn : builderReturn;\n      Object.defineProperty(api, name, {\n        enumerable: false,\n        configurable: false,\n        value: git ? valid : alternative\n      });\n      return api;\n    },\n    {}\n  );\n  return promiseApi;\n  function asyncWrapper(fn, git2) {\n    return function(...args2) {\n      if (typeof args2[args2.length] === \"function\") {\n        throw new TypeError(\n          \"Promise interface requires that handlers are not supplied inline, trailing function not allowed in call to \" + fn\n        );\n      }\n      return chain.then(function() {\n        return new Promise(function(resolve, reject) {\n          const callback = (err, result) => {\n            if (err) {\n              return reject(toError(err));\n            }\n            resolve(result);\n          };\n          args2.push(callback);\n          git2[fn].apply(git2, args2);\n        });\n      });\n    };\n  }\n  function syncWrapper(fn, git2, api) {\n    return (...args2) => {\n      git2[fn](...args2);\n      return api;\n    };\n  }\n}\nfunction toError(error) {\n  if (error instanceof Error) {\n    return error;\n  }\n  if (typeof error === \"string\") {\n    return new Error(error);\n  }\n  return new GitResponseError(error);\n}\n\n// src/esm.mjs\nvar simpleGit = gitInstanceFactory;\nvar esm_default = gitInstanceFactory;\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNnRDtBQUNNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFNLE9BQU8sd0RBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQ0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssaUJBQWlCO0FBQ3RCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNEJBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsU0FBUztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdCQUF3QjtBQUM3QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1GQUFtRixLQUFLO0FBQ3hGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssaUJBQWlCO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQzBCO0FBQzFCO0FBQ0EsU0FBUyxrQ0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRCQUE0QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBLGlEQUFpRCxhQUFhLEVBQUUsV0FBVztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQWdCO0FBQ3BCLElBQUksNkNBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsaUJBQWlCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxHQUFHLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3NDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxNQUFNO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMEJBQTBCLG9EQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE1BQU0saUNBQWlDLEtBQUs7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsVUFBVTtBQUM1RTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlLEVBQUUsVUFBVSxFQUFFLGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlLEVBQUUsY0FBYyxFQUFFLGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDBCQUEwQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxHQUFHLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLCtCQUErQiw0Q0FBNEM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxXQUFXO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QztBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPLEVBQUUsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTSxFQUFFLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDLGtDQUFrQyxFQUFFO0FBQ3BDLHNEQUFzRCxFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXLEdBQUcsV0FBVyxHQUFHLFdBQVc7QUFDekQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUM7QUFDckQsbUJBQW1CLG9DQUFvQztBQUN2RCx1QkFBdUI7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMwRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0IsRUFBRSx5RUFBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3NDO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxPQUFPO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QyxVQUFVLDhCQUE4QjtBQUN4QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLGtEQUFrRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLGtDQUFrQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsb0NBQW9DO0FBQzlDLFVBQVUsb0NBQW9DO0FBQzlDLFVBQVUsMkRBQTJEO0FBQ3JFLFVBQVUseUZBQXlGO0FBQ25HLFVBQVUsb0NBQW9DO0FBQzlDLFVBQVUsd0JBQXdCO0FBQ2xDLFVBQVUsc0JBQXNCO0FBQ2hDLFVBQVUsc0JBQXNCO0FBQ2hDLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLHFEQUFxRDtBQUMvRCxVQUFVLGdDQUFnQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsZ0dBQWdHO0FBQzFHLFVBQVUsK0dBQStHO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQTBDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNENBQTRDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNxRDtBQUNyRCxZQUFZLG1FQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUVBQVE7QUFDckIsb0JBQW9CLG1FQUFRO0FBQzVCLFlBQVksbUVBQVE7QUFDcEIsbUJBQW1CLG1FQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVUsZ0JBQWdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFpQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2RldmVsb3Blci13cmFwcGVkLy4vbm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvZGlzdC9lc20vaW5kZXguanM/NmVlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2VzbSA9IChmbiwgcmVzKSA9PiBmdW5jdGlvbiBfX2luaXQoKSB7XG4gIHJldHVybiBmbiAmJiAocmVzID0gKDAsIGZuW19fZ2V0T3duUHJvcE5hbWVzKGZuKVswXV0pKGZuID0gMCkpLCByZXM7XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2xpYi9hcmdzL3BhdGhzcGVjLnRzXG5mdW5jdGlvbiBwYXRoc3BlYyguLi5wYXRocykge1xuICBjb25zdCBrZXkgPSBuZXcgU3RyaW5nKHBhdGhzKTtcbiAgY2FjaGUuc2V0KGtleSwgcGF0aHMpO1xuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gaXNQYXRoU3BlYyhwYXRoKSB7XG4gIHJldHVybiBwYXRoIGluc3RhbmNlb2YgU3RyaW5nICYmIGNhY2hlLmhhcyhwYXRoKTtcbn1cbmZ1bmN0aW9uIHRvUGF0aHMocGF0aFNwZWMpIHtcbiAgcmV0dXJuIGNhY2hlLmdldChwYXRoU3BlYykgfHwgW107XG59XG52YXIgY2FjaGU7XG52YXIgaW5pdF9wYXRoc3BlYyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL2FyZ3MvcGF0aHNwZWMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9lcnJvcnMvZ2l0LWVycm9yLnRzXG52YXIgR2l0RXJyb3I7XG52YXIgaW5pdF9naXRfZXJyb3IgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9lcnJvcnMvZ2l0LWVycm9yLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgR2l0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKHRhc2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvci50c1xudmFyIEdpdFJlc3BvbnNlRXJyb3I7XG52YXIgaW5pdF9naXRfcmVzcG9uc2VfZXJyb3IgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfZXJyb3IoKTtcbiAgICBHaXRSZXNwb25zZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBHaXRFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihnaXQsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodm9pZCAwLCBtZXNzYWdlIHx8IFN0cmluZyhnaXQpKTtcbiAgICAgICAgdGhpcy5naXQgPSBnaXQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvZXJyb3JzL3Rhc2stY29uZmlndXJhdGlvbi1lcnJvci50c1xudmFyIFRhc2tDb25maWd1cmF0aW9uRXJyb3I7XG52YXIgaW5pdF90YXNrX2NvbmZpZ3VyYXRpb25fZXJyb3IgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9lcnJvcnMvdGFzay1jb25maWd1cmF0aW9uLWVycm9yLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfZXJyb3IoKTtcbiAgICBUYXNrQ29uZmlndXJhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBHaXRFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKHZvaWQgMCwgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdXRpbHMvdXRpbC50c1xuaW1wb3J0IHsgQnVmZmVyIGFzIEJ1ZmZlcjIgfSBmcm9tIFwibm9kZTpidWZmZXJcIjtcbmltcG9ydCB7IGV4aXN0cywgRk9MREVSIH0gZnJvbSBcIkBrd3NpdGVzL2ZpbGUtZXhpc3RzXCI7XG5mdW5jdGlvbiBhc0Z1bmN0aW9uKHNvdXJjZSkge1xuICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIE5PT1A7XG4gIH1cbiAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGlzVXNlckZ1bmN0aW9uKHNvdXJjZSkge1xuICByZXR1cm4gdHlwZW9mIHNvdXJjZSA9PT0gXCJmdW5jdGlvblwiICYmIHNvdXJjZSAhPT0gTk9PUDtcbn1cbmZ1bmN0aW9uIHNwbGl0T24oaW5wdXQsIGNoYXIpIHtcbiAgY29uc3QgaW5kZXggPSBpbnB1dC5pbmRleE9mKGNoYXIpO1xuICBpZiAoaW5kZXggPD0gMCkge1xuICAgIHJldHVybiBbaW5wdXQsIFwiXCJdO1xuICB9XG4gIHJldHVybiBbaW5wdXQuc3Vic3RyKDAsIGluZGV4KSwgaW5wdXQuc3Vic3RyKGluZGV4ICsgMSldO1xufVxuZnVuY3Rpb24gZmlyc3QoaW5wdXQsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPiBvZmZzZXQgPyBpbnB1dFtvZmZzZXRdIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gbGFzdChpbnB1dCwgb2Zmc2V0ID0gMCkge1xuICBpZiAoaXNBcnJheUxpa2UoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA+IG9mZnNldCkge1xuICAgIHJldHVybiBpbnB1dFtpbnB1dC5sZW5ndGggLSAxIC0gb2Zmc2V0XTtcbiAgfVxufVxuZnVuY3Rpb24gaXNBcnJheUxpa2UoaW5wdXQpIHtcbiAgcmV0dXJuIGZpbHRlckhhc0xlbmd0aChpbnB1dCk7XG59XG5mdW5jdGlvbiB0b0xpbmVzV2l0aENvbnRlbnQoaW5wdXQgPSBcIlwiLCB0cmltbWVkMiA9IHRydWUsIHNlcGFyYXRvciA9IFwiXFxuXCIpIHtcbiAgcmV0dXJuIGlucHV0LnNwbGl0KHNlcGFyYXRvcikucmVkdWNlKChvdXRwdXQsIGxpbmUpID0+IHtcbiAgICBjb25zdCBsaW5lQ29udGVudCA9IHRyaW1tZWQyID8gbGluZS50cmltKCkgOiBsaW5lO1xuICAgIGlmIChsaW5lQ29udGVudCkge1xuICAgICAgb3V0cHV0LnB1c2gobGluZUNvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBmb3JFYWNoTGluZVdpdGhDb250ZW50KGlucHV0LCBjYWxsYmFjaykge1xuICByZXR1cm4gdG9MaW5lc1dpdGhDb250ZW50KGlucHV0LCB0cnVlKS5tYXAoKGxpbmUpID0+IGNhbGxiYWNrKGxpbmUpKTtcbn1cbmZ1bmN0aW9uIGZvbGRlckV4aXN0cyhwYXRoKSB7XG4gIHJldHVybiBleGlzdHMocGF0aCwgRk9MREVSKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIGl0ZW0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGlmICghdGFyZ2V0LmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmFkZChpdGVtKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGluZyh0YXJnZXQsIGl0ZW0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiAhdGFyZ2V0LmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHJlbW92ZSh0YXJnZXQsIGl0ZW0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGFyZ2V0LmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRhcmdldC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuZGVsZXRlKGl0ZW0pO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gYXNBcnJheShzb3VyY2UpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xufVxuZnVuY3Rpb24gYXNDYW1lbENhc2Uoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xccy1dKyguKS9nLCAoX2FsbCwgY2hyKSA9PiB7XG4gICAgcmV0dXJuIGNoci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFzU3RyaW5nQXJyYXkoc291cmNlKSB7XG4gIHJldHVybiBhc0FycmF5KHNvdXJjZSkubWFwKChpdGVtKSA9PiB7XG4gICAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBTdHJpbmcgPyBpdGVtIDogU3RyaW5nKGl0ZW0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFzTnVtYmVyKHNvdXJjZSwgb25OYU4gPSAwKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuICAgIHJldHVybiBvbk5hTjtcbiAgfVxuICBjb25zdCBudW0gPSBwYXJzZUludChzb3VyY2UsIDEwKTtcbiAgcmV0dXJuIE51bWJlci5pc05hTihudW0pID8gb25OYU4gOiBudW07XG59XG5mdW5jdGlvbiBwcmVmaXhlZEFycmF5KGlucHV0LCBwcmVmaXgpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBtYXggPSBpbnB1dC5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgIG91dHB1dC5wdXNoKHByZWZpeCwgaW5wdXRbaV0pO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBidWZmZXJUb1N0cmluZyhpbnB1dCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoaW5wdXQpID8gQnVmZmVyMi5jb25jYXQoaW5wdXQpIDogaW5wdXQpLnRvU3RyaW5nKFwidXRmLThcIik7XG59XG5mdW5jdGlvbiBwaWNrKHNvdXJjZSwgcHJvcGVydGllcykge1xuICBjb25zdCBvdXQgPSB7fTtcbiAgcHJvcGVydGllcy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoc291cmNlW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgb3V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gZGVsYXkoZHVyYXRpb24gPSAwKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoZG9uZSkgPT4gc2V0VGltZW91dChkb25lLCBkdXJhdGlvbikpO1xufVxuZnVuY3Rpb24gb3JWb2lkKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cbnZhciBOVUxMLCBOT09QLCBvYmplY3RUb1N0cmluZztcbnZhciBpbml0X3V0aWwgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy91dGlsLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9hcmd1bWVudF9maWx0ZXJzKCk7XG4gICAgTlVMTCA9IFwiXFwwXCI7XG4gICAgTk9PUCA9ICgpID0+IHtcbiAgICB9O1xuICAgIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL2FyZ3VtZW50LWZpbHRlcnMudHNcbmZ1bmN0aW9uIGZpbHRlclR5cGUoaW5wdXQsIGZpbHRlciwgZGVmKSB7XG4gIGlmIChmaWx0ZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGRlZiA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGZpbHRlclByaW1pdGl2ZXMoaW5wdXQsIG9taXQpIHtcbiAgY29uc3QgdHlwZSA9IGlzUGF0aFNwZWMoaW5wdXQpID8gXCJzdHJpbmdcIiA6IHR5cGVvZiBpbnB1dDtcbiAgcmV0dXJuIC9udW1iZXJ8c3RyaW5nfGJvb2xlYW4vLnRlc3QodHlwZSkgJiYgKCFvbWl0IHx8ICFvbWl0LmluY2x1ZGVzKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGZpbHRlclBsYWluT2JqZWN0KGlucHV0KSB7XG4gIHJldHVybiAhIWlucHV0ICYmIG9iamVjdFRvU3RyaW5nKGlucHV0KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgaW5wdXQgPT09IFwiZnVuY3Rpb25cIjtcbn1cbnZhciBmaWx0ZXJBcnJheSwgZmlsdGVyTnVtYmVyLCBmaWx0ZXJTdHJpbmcsIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXksIGZpbHRlckhhc0xlbmd0aDtcbnZhciBpbml0X2FyZ3VtZW50X2ZpbHRlcnMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy9hcmd1bWVudC1maWx0ZXJzLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9wYXRoc3BlYygpO1xuICAgIGluaXRfdXRpbCgpO1xuICAgIGZpbHRlckFycmF5ID0gKGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCk7XG4gICAgfTtcbiAgICBmaWx0ZXJOdW1iZXIgPSAoaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCI7XG4gICAgfTtcbiAgICBmaWx0ZXJTdHJpbmcgPSAoaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCI7XG4gICAgfTtcbiAgICBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5ID0gKGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyU3RyaW5nKGlucHV0KSB8fCBBcnJheS5pc0FycmF5KGlucHV0KSAmJiBpbnB1dC5ldmVyeShmaWx0ZXJTdHJpbmcpO1xuICAgIH07XG4gICAgZmlsdGVySGFzTGVuZ3RoID0gKGlucHV0KSA9PiB7XG4gICAgICBpZiAoaW5wdXQgPT0gbnVsbCB8fCBcIm51bWJlcnxib29sZWFufGZ1bmN0aW9uXCIuaW5jbHVkZXModHlwZW9mIGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGlucHV0Lmxlbmd0aCA9PT0gXCJudW1iZXJcIjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9leGl0LWNvZGVzLnRzXG52YXIgRXhpdENvZGVzO1xudmFyIGluaXRfZXhpdF9jb2RlcyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL2V4aXQtY29kZXMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBFeGl0Q29kZXMgPSAvKiBAX19QVVJFX18gKi8gKChFeGl0Q29kZXMyKSA9PiB7XG4gICAgICBFeGl0Q29kZXMyW0V4aXRDb2RlczJbXCJTVUNDRVNTXCJdID0gMF0gPSBcIlNVQ0NFU1NcIjtcbiAgICAgIEV4aXRDb2RlczJbRXhpdENvZGVzMltcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG4gICAgICBFeGl0Q29kZXMyW0V4aXRDb2RlczJbXCJOT1RfRk9VTkRcIl0gPSAtMl0gPSBcIk5PVF9GT1VORFwiO1xuICAgICAgRXhpdENvZGVzMltFeGl0Q29kZXMyW1wiVU5DTEVBTlwiXSA9IDEyOF0gPSBcIlVOQ0xFQU5cIjtcbiAgICAgIHJldHVybiBFeGl0Q29kZXMyO1xuICAgIH0pKEV4aXRDb2RlcyB8fCB7fSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL2dpdC1vdXRwdXQtc3RyZWFtcy50c1xudmFyIEdpdE91dHB1dFN0cmVhbXM7XG52YXIgaW5pdF9naXRfb3V0cHV0X3N0cmVhbXMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy9naXQtb3V0cHV0LXN0cmVhbXMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBHaXRPdXRwdXRTdHJlYW1zID0gY2xhc3MgX0dpdE91dHB1dFN0cmVhbXMge1xuICAgICAgY29uc3RydWN0b3Ioc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgICAgdGhpcy5zdGRPdXQgPSBzdGRPdXQ7XG4gICAgICAgIHRoaXMuc3RkRXJyID0gc3RkRXJyO1xuICAgICAgfVxuICAgICAgYXNTdHJpbmdzKCkge1xuICAgICAgICByZXR1cm4gbmV3IF9HaXRPdXRwdXRTdHJlYW1zKHRoaXMuc3RkT3V0LnRvU3RyaW5nKFwidXRmOFwiKSwgdGhpcy5zdGRFcnIudG9TdHJpbmcoXCJ1dGY4XCIpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9saW5lLXBhcnNlci50c1xuZnVuY3Rpb24gdXNlTWF0Y2hlc0RlZmF1bHQoKSB7XG4gIHRocm93IG5ldyBFcnJvcihgTGluZVBhcnNlcjp1c2VNYXRjaGVzIG5vdCBpbXBsZW1lbnRlZGApO1xufVxudmFyIExpbmVQYXJzZXIsIFJlbW90ZUxpbmVQYXJzZXI7XG52YXIgaW5pdF9saW5lX3BhcnNlciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL2xpbmUtcGFyc2VyLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgTGluZVBhcnNlciA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKHJlZ0V4cCwgdXNlTWF0Y2hlcykge1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBbXTtcbiAgICAgICAgdGhpcy51c2VNYXRjaGVzID0gdXNlTWF0Y2hlc0RlZmF1bHQ7XG4gICAgICAgIHRoaXMucGFyc2UgPSAobGluZSwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldE1hdGNoZXMoKTtcbiAgICAgICAgICBpZiAoIXRoaXMuX3JlZ0V4cC5ldmVyeSgocmVnLCBpbmRleCkgPT4gdGhpcy5hZGRNYXRjaChyZWcsIGluZGV4LCBsaW5lKGluZGV4KSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLnVzZU1hdGNoZXModGFyZ2V0LCB0aGlzLnByZXBhcmVNYXRjaGVzKCkpICE9PSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcmVnRXhwID0gQXJyYXkuaXNBcnJheShyZWdFeHApID8gcmVnRXhwIDogW3JlZ0V4cF07XG4gICAgICAgIGlmICh1c2VNYXRjaGVzKSB7XG4gICAgICAgICAgdGhpcy51c2VNYXRjaGVzID0gdXNlTWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzZXRNYXRjaGVzKCkge1xuICAgICAgICB0aGlzLm1hdGNoZXMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIHByZXBhcmVNYXRjaGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaGVzO1xuICAgICAgfVxuICAgICAgYWRkTWF0Y2gocmVnLCBpbmRleCwgbGluZSkge1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gbGluZSAmJiByZWcuZXhlYyhsaW5lKTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICB0aGlzLnB1c2hNYXRjaChpbmRleCwgbWF0Y2hlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhbWF0Y2hlZDtcbiAgICAgIH1cbiAgICAgIHB1c2hNYXRjaChfaW5kZXgsIG1hdGNoZWQpIHtcbiAgICAgICAgdGhpcy5tYXRjaGVzLnB1c2goLi4ubWF0Y2hlZC5zbGljZSgxKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBSZW1vdGVMaW5lUGFyc2VyID0gY2xhc3MgZXh0ZW5kcyBMaW5lUGFyc2VyIHtcbiAgICAgIGFkZE1hdGNoKHJlZywgaW5kZXgsIGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIC9ecmVtb3RlOlxccy8udGVzdChTdHJpbmcobGluZSkpICYmIHN1cGVyLmFkZE1hdGNoKHJlZywgaW5kZXgsIGxpbmUpO1xuICAgICAgfVxuICAgICAgcHVzaE1hdGNoKGluZGV4LCBtYXRjaGVkKSB7XG4gICAgICAgIGlmIChpbmRleCA+IDAgfHwgbWF0Y2hlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgc3VwZXIucHVzaE1hdGNoKGluZGV4LCBtYXRjaGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL3NpbXBsZS1naXQtb3B0aW9ucy50c1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VDb25maWcoLi4ub3B0aW9ucykge1xuICBjb25zdCBiYXNlRGlyID0gcHJvY2Vzcy5jd2QoKTtcbiAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbihcbiAgICB7IGJhc2VEaXIsIC4uLmRlZmF1bHRPcHRpb25zIH0sXG4gICAgLi4ub3B0aW9ucy5maWx0ZXIoKG8pID0+IHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIG8pXG4gICk7XG4gIGNvbmZpZy5iYXNlRGlyID0gY29uZmlnLmJhc2VEaXIgfHwgYmFzZURpcjtcbiAgY29uZmlnLnRyaW1tZWQgPSBjb25maWcudHJpbW1lZCA9PT0gdHJ1ZTtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbnZhciBkZWZhdWx0T3B0aW9ucztcbnZhciBpbml0X3NpbXBsZV9naXRfb3B0aW9ucyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL3NpbXBsZS1naXQtb3B0aW9ucy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYmluYXJ5OiBcImdpdFwiLFxuICAgICAgbWF4Q29uY3VycmVudFByb2Nlc3NlczogNSxcbiAgICAgIGNvbmZpZzogW10sXG4gICAgICB0cmltbWVkOiBmYWxzZVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL3Rhc2stb3B0aW9ucy50c1xuZnVuY3Rpb24gYXBwZW5kVGFza09wdGlvbnMob3B0aW9ucywgY29tbWFuZHMgPSBbXSkge1xuICBpZiAoIWZpbHRlclBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKS5yZWR1Y2UoKGNvbW1hbmRzMiwga2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgaWYgKGlzUGF0aFNwZWModmFsdWUpKSB7XG4gICAgICBjb21tYW5kczIucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJQcmltaXRpdmVzKHZhbHVlLCBbXCJib29sZWFuXCJdKSkge1xuICAgICAgY29tbWFuZHMyLnB1c2goa2V5ICsgXCI9XCIgKyB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgIGlmICghZmlsdGVyUHJpbWl0aXZlcyh2LCBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIl0pKSB7XG4gICAgICAgICAgY29tbWFuZHMyLnB1c2goa2V5ICsgXCI9XCIgKyB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21tYW5kczIucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMyO1xuICB9LCBjb21tYW5kcyk7XG59XG5mdW5jdGlvbiBnZXRUcmFpbGluZ09wdGlvbnMoYXJncywgaW5pdGlhbFByaW1pdGl2ZSA9IDAsIG9iamVjdE9ubHkgPSBmYWxzZSkge1xuICBjb25zdCBjb21tYW5kID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBtYXggPSBpbml0aWFsUHJpbWl0aXZlIDwgMCA/IGFyZ3MubGVuZ3RoIDogaW5pdGlhbFByaW1pdGl2ZTsgaSA8IG1heDsgaSsrKSB7XG4gICAgaWYgKFwic3RyaW5nfG51bWJlclwiLmluY2x1ZGVzKHR5cGVvZiBhcmdzW2ldKSkge1xuICAgICAgY29tbWFuZC5wdXNoKFN0cmluZyhhcmdzW2ldKSk7XG4gICAgfVxuICB9XG4gIGFwcGVuZFRhc2tPcHRpb25zKHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3MpLCBjb21tYW5kKTtcbiAgaWYgKCFvYmplY3RPbmx5KSB7XG4gICAgY29tbWFuZC5wdXNoKC4uLnRyYWlsaW5nQXJyYXlBcmd1bWVudChhcmdzKSk7XG4gIH1cbiAgcmV0dXJuIGNvbW1hbmQ7XG59XG5mdW5jdGlvbiB0cmFpbGluZ0FycmF5QXJndW1lbnQoYXJncykge1xuICBjb25zdCBoYXNUcmFpbGluZ0NhbGxiYWNrID0gdHlwZW9mIGxhc3QoYXJncykgPT09IFwiZnVuY3Rpb25cIjtcbiAgcmV0dXJuIGFzU3RyaW5nQXJyYXkoZmlsdGVyVHlwZShsYXN0KGFyZ3MsIGhhc1RyYWlsaW5nQ2FsbGJhY2sgPyAxIDogMCksIGZpbHRlckFycmF5LCBbXSkpO1xufVxuZnVuY3Rpb24gdHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJncykge1xuICBjb25zdCBoYXNUcmFpbGluZ0NhbGxiYWNrID0gZmlsdGVyRnVuY3Rpb24obGFzdChhcmdzKSk7XG4gIHJldHVybiBmaWx0ZXJUeXBlKGxhc3QoYXJncywgaGFzVHJhaWxpbmdDYWxsYmFjayA/IDEgOiAwKSwgZmlsdGVyUGxhaW5PYmplY3QpO1xufVxuZnVuY3Rpb24gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3MsIGluY2x1ZGVOb29wID0gdHJ1ZSkge1xuICBjb25zdCBjYWxsYmFjayA9IGFzRnVuY3Rpb24obGFzdChhcmdzKSk7XG4gIHJldHVybiBpbmNsdWRlTm9vcCB8fCBpc1VzZXJGdW5jdGlvbihjYWxsYmFjaykgPyBjYWxsYmFjayA6IHZvaWQgMDtcbn1cbnZhciBpbml0X3Rhc2tfb3B0aW9ucyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL3Rhc2stb3B0aW9ucy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfYXJndW1lbnRfZmlsdGVycygpO1xuICAgIGluaXRfdXRpbCgpO1xuICAgIGluaXRfcGF0aHNwZWMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdXRpbHMvdGFzay1wYXJzZXIudHNcbmZ1bmN0aW9uIGNhbGxUYXNrUGFyc2VyKHBhcnNlcjQsIHN0cmVhbXMpIHtcbiAgcmV0dXJuIHBhcnNlcjQoc3RyZWFtcy5zdGRPdXQsIHN0cmVhbXMuc3RkRXJyKTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nUmVzcG9uc2UocmVzdWx0LCBwYXJzZXJzMTIsIHRleHRzLCB0cmltID0gdHJ1ZSkge1xuICBhc0FycmF5KHRleHRzKS5mb3JFYWNoKCh0ZXh0KSA9PiB7XG4gICAgZm9yIChsZXQgbGluZXMgPSB0b0xpbmVzV2l0aENvbnRlbnQodGV4dCwgdHJpbSksIGkgPSAwLCBtYXggPSBsaW5lcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IChvZmZzZXQgPSAwKSA9PiB7XG4gICAgICAgIGlmIChpICsgb2Zmc2V0ID49IG1heCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXNbaSArIG9mZnNldF07XG4gICAgICB9O1xuICAgICAgcGFyc2VyczEyLnNvbWUoKHsgcGFyc2UgfSkgPT4gcGFyc2UobGluZSwgcmVzdWx0KSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBpbml0X3Rhc2tfcGFyc2VyID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvdGFzay1wYXJzZXIudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWwoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdXRpbHMvaW5kZXgudHNcbnZhciB1dGlsc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh1dGlsc19leHBvcnRzLCB7XG4gIEV4aXRDb2RlczogKCkgPT4gRXhpdENvZGVzLFxuICBHaXRPdXRwdXRTdHJlYW1zOiAoKSA9PiBHaXRPdXRwdXRTdHJlYW1zLFxuICBMaW5lUGFyc2VyOiAoKSA9PiBMaW5lUGFyc2VyLFxuICBOT09QOiAoKSA9PiBOT09QLFxuICBOVUxMOiAoKSA9PiBOVUxMLFxuICBSZW1vdGVMaW5lUGFyc2VyOiAoKSA9PiBSZW1vdGVMaW5lUGFyc2VyLFxuICBhcHBlbmQ6ICgpID0+IGFwcGVuZCxcbiAgYXBwZW5kVGFza09wdGlvbnM6ICgpID0+IGFwcGVuZFRhc2tPcHRpb25zLFxuICBhc0FycmF5OiAoKSA9PiBhc0FycmF5LFxuICBhc0NhbWVsQ2FzZTogKCkgPT4gYXNDYW1lbENhc2UsXG4gIGFzRnVuY3Rpb246ICgpID0+IGFzRnVuY3Rpb24sXG4gIGFzTnVtYmVyOiAoKSA9PiBhc051bWJlcixcbiAgYXNTdHJpbmdBcnJheTogKCkgPT4gYXNTdHJpbmdBcnJheSxcbiAgYnVmZmVyVG9TdHJpbmc6ICgpID0+IGJ1ZmZlclRvU3RyaW5nLFxuICBjYWxsVGFza1BhcnNlcjogKCkgPT4gY2FsbFRhc2tQYXJzZXIsXG4gIGNyZWF0ZUluc3RhbmNlQ29uZmlnOiAoKSA9PiBjcmVhdGVJbnN0YW5jZUNvbmZpZyxcbiAgZGVsYXk6ICgpID0+IGRlbGF5LFxuICBmaWx0ZXJBcnJheTogKCkgPT4gZmlsdGVyQXJyYXksXG4gIGZpbHRlckZ1bmN0aW9uOiAoKSA9PiBmaWx0ZXJGdW5jdGlvbixcbiAgZmlsdGVySGFzTGVuZ3RoOiAoKSA9PiBmaWx0ZXJIYXNMZW5ndGgsXG4gIGZpbHRlck51bWJlcjogKCkgPT4gZmlsdGVyTnVtYmVyLFxuICBmaWx0ZXJQbGFpbk9iamVjdDogKCkgPT4gZmlsdGVyUGxhaW5PYmplY3QsXG4gIGZpbHRlclByaW1pdGl2ZXM6ICgpID0+IGZpbHRlclByaW1pdGl2ZXMsXG4gIGZpbHRlclN0cmluZzogKCkgPT4gZmlsdGVyU3RyaW5nLFxuICBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5OiAoKSA9PiBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LFxuICBmaWx0ZXJUeXBlOiAoKSA9PiBmaWx0ZXJUeXBlLFxuICBmaXJzdDogKCkgPT4gZmlyc3QsXG4gIGZvbGRlckV4aXN0czogKCkgPT4gZm9sZGVyRXhpc3RzLFxuICBmb3JFYWNoTGluZVdpdGhDb250ZW50OiAoKSA9PiBmb3JFYWNoTGluZVdpdGhDb250ZW50LFxuICBnZXRUcmFpbGluZ09wdGlvbnM6ICgpID0+IGdldFRyYWlsaW5nT3B0aW9ucyxcbiAgaW5jbHVkaW5nOiAoKSA9PiBpbmNsdWRpbmcsXG4gIGlzVXNlckZ1bmN0aW9uOiAoKSA9PiBpc1VzZXJGdW5jdGlvbixcbiAgbGFzdDogKCkgPT4gbGFzdCxcbiAgb2JqZWN0VG9TdHJpbmc6ICgpID0+IG9iamVjdFRvU3RyaW5nLFxuICBvclZvaWQ6ICgpID0+IG9yVm9pZCxcbiAgcGFyc2VTdHJpbmdSZXNwb25zZTogKCkgPT4gcGFyc2VTdHJpbmdSZXNwb25zZSxcbiAgcGljazogKCkgPT4gcGljayxcbiAgcHJlZml4ZWRBcnJheTogKCkgPT4gcHJlZml4ZWRBcnJheSxcbiAgcmVtb3ZlOiAoKSA9PiByZW1vdmUsXG4gIHNwbGl0T246ICgpID0+IHNwbGl0T24sXG4gIHRvTGluZXNXaXRoQ29udGVudDogKCkgPT4gdG9MaW5lc1dpdGhDb250ZW50LFxuICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQ6ICgpID0+IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCxcbiAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQ6ICgpID0+IHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50XG59KTtcbnZhciBpbml0X3V0aWxzID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvaW5kZXgudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2FyZ3VtZW50X2ZpbHRlcnMoKTtcbiAgICBpbml0X2V4aXRfY29kZXMoKTtcbiAgICBpbml0X2dpdF9vdXRwdXRfc3RyZWFtcygpO1xuICAgIGluaXRfbGluZV9wYXJzZXIoKTtcbiAgICBpbml0X3NpbXBsZV9naXRfb3B0aW9ucygpO1xuICAgIGluaXRfdGFza19vcHRpb25zKCk7XG4gICAgaW5pdF90YXNrX3BhcnNlcigpO1xuICAgIGluaXRfdXRpbCgpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jaGVjay1pcy1yZXBvLnRzXG52YXIgY2hlY2tfaXNfcmVwb19leHBvcnRzID0ge307XG5fX2V4cG9ydChjaGVja19pc19yZXBvX2V4cG9ydHMsIHtcbiAgQ2hlY2tSZXBvQWN0aW9uczogKCkgPT4gQ2hlY2tSZXBvQWN0aW9ucyxcbiAgY2hlY2tJc0JhcmVSZXBvVGFzazogKCkgPT4gY2hlY2tJc0JhcmVSZXBvVGFzayxcbiAgY2hlY2tJc1JlcG9Sb290VGFzazogKCkgPT4gY2hlY2tJc1JlcG9Sb290VGFzayxcbiAgY2hlY2tJc1JlcG9UYXNrOiAoKSA9PiBjaGVja0lzUmVwb1Rhc2tcbn0pO1xuZnVuY3Rpb24gY2hlY2tJc1JlcG9UYXNrKGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbikge1xuICAgIGNhc2UgXCJiYXJlXCIgLyogQkFSRSAqLzpcbiAgICAgIHJldHVybiBjaGVja0lzQmFyZVJlcG9UYXNrKCk7XG4gICAgY2FzZSBcInJvb3RcIiAvKiBJU19SRVBPX1JPT1QgKi86XG4gICAgICByZXR1cm4gY2hlY2tJc1JlcG9Sb290VGFzaygpO1xuICB9XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wicmV2LXBhcnNlXCIsIFwiLS1pcy1pbnNpZGUtd29yay10cmVlXCJdO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIG9uRXJyb3IsXG4gICAgcGFyc2VyXG4gIH07XG59XG5mdW5jdGlvbiBjaGVja0lzUmVwb1Jvb3RUYXNrKCkge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInJldi1wYXJzZVwiLCBcIi0tZ2l0LWRpclwiXTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBvbkVycm9yLFxuICAgIHBhcnNlcihwYXRoKSB7XG4gICAgICByZXR1cm4gL15cXC4oZ2l0KT8kLy50ZXN0KHBhdGgudHJpbSgpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjaGVja0lzQmFyZVJlcG9UYXNrKCkge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInJldi1wYXJzZVwiLCBcIi0taXMtYmFyZS1yZXBvc2l0b3J5XCJdO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIG9uRXJyb3IsXG4gICAgcGFyc2VyXG4gIH07XG59XG5mdW5jdGlvbiBpc05vdFJlcG9NZXNzYWdlKGVycm9yKSB7XG4gIHJldHVybiAvKE5vdCBhIGdpdCByZXBvc2l0b3J5fEtlaW4gR2l0LVJlcG9zaXRvcnkpL2kudGVzdChTdHJpbmcoZXJyb3IpKTtcbn1cbnZhciBDaGVja1JlcG9BY3Rpb25zLCBvbkVycm9yLCBwYXJzZXI7XG52YXIgaW5pdF9jaGVja19pc19yZXBvID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY2hlY2staXMtcmVwby50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBDaGVja1JlcG9BY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoQ2hlY2tSZXBvQWN0aW9uczIpID0+IHtcbiAgICAgIENoZWNrUmVwb0FjdGlvbnMyW1wiQkFSRVwiXSA9IFwiYmFyZVwiO1xuICAgICAgQ2hlY2tSZXBvQWN0aW9uczJbXCJJTl9UUkVFXCJdID0gXCJ0cmVlXCI7XG4gICAgICBDaGVja1JlcG9BY3Rpb25zMltcIklTX1JFUE9fUk9PVFwiXSA9IFwicm9vdFwiO1xuICAgICAgcmV0dXJuIENoZWNrUmVwb0FjdGlvbnMyO1xuICAgIH0pKENoZWNrUmVwb0FjdGlvbnMgfHwge30pO1xuICAgIG9uRXJyb3IgPSAoeyBleGl0Q29kZSB9LCBlcnJvciwgZG9uZSwgZmFpbCkgPT4ge1xuICAgICAgaWYgKGV4aXRDb2RlID09PSAxMjggLyogVU5DTEVBTiAqLyAmJiBpc05vdFJlcG9NZXNzYWdlKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gZG9uZShCdWZmZXIuZnJvbShcImZhbHNlXCIpKTtcbiAgICAgIH1cbiAgICAgIGZhaWwoZXJyb3IpO1xuICAgIH07XG4gICAgcGFyc2VyID0gKHRleHQpID0+IHtcbiAgICAgIHJldHVybiB0ZXh0LnRyaW0oKSA9PT0gXCJ0cnVlXCI7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0NsZWFuU3VtbWFyeS50c1xuZnVuY3Rpb24gY2xlYW5TdW1tYXJ5UGFyc2VyKGRyeVJ1biwgdGV4dCkge1xuICBjb25zdCBzdW1tYXJ5ID0gbmV3IENsZWFuUmVzcG9uc2UoZHJ5UnVuKTtcbiAgY29uc3QgcmVnZXhwID0gZHJ5UnVuID8gZHJ5UnVuUmVtb3ZhbFJlZ2V4cCA6IHJlbW92YWxSZWdleHA7XG4gIHRvTGluZXNXaXRoQ29udGVudCh0ZXh0KS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlZCA9IGxpbmUucmVwbGFjZShyZWdleHAsIFwiXCIpO1xuICAgIHN1bW1hcnkucGF0aHMucHVzaChyZW1vdmVkKTtcbiAgICAoaXNGb2xkZXJSZWdleHAudGVzdChyZW1vdmVkKSA/IHN1bW1hcnkuZm9sZGVycyA6IHN1bW1hcnkuZmlsZXMpLnB1c2gocmVtb3ZlZCk7XG4gIH0pO1xuICByZXR1cm4gc3VtbWFyeTtcbn1cbnZhciBDbGVhblJlc3BvbnNlLCByZW1vdmFsUmVnZXhwLCBkcnlSdW5SZW1vdmFsUmVnZXhwLCBpc0ZvbGRlclJlZ2V4cDtcbnZhciBpbml0X0NsZWFuU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9DbGVhblN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgQ2xlYW5SZXNwb25zZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGRyeVJ1bikge1xuICAgICAgICB0aGlzLmRyeVJ1biA9IGRyeVJ1bjtcbiAgICAgICAgdGhpcy5wYXRocyA9IFtdO1xuICAgICAgICB0aGlzLmZpbGVzID0gW107XG4gICAgICAgIHRoaXMuZm9sZGVycyA9IFtdO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVtb3ZhbFJlZ2V4cCA9IC9eW2Etel0rXFxzKi9pO1xuICAgIGRyeVJ1blJlbW92YWxSZWdleHAgPSAvXlthLXpdK1xccytbYS16XStcXHMqL2k7XG4gICAgaXNGb2xkZXJSZWdleHAgPSAvXFwvJC87XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3Rhc2sudHNcbnZhciB0YXNrX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHRhc2tfZXhwb3J0cywge1xuICBFTVBUWV9DT01NQU5EUzogKCkgPT4gRU1QVFlfQ09NTUFORFMsXG4gIGFkaG9jRXhlY1Rhc2s6ICgpID0+IGFkaG9jRXhlY1Rhc2ssXG4gIGNvbmZpZ3VyYXRpb25FcnJvclRhc2s6ICgpID0+IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssXG4gIGlzQnVmZmVyVGFzazogKCkgPT4gaXNCdWZmZXJUYXNrLFxuICBpc0VtcHR5VGFzazogKCkgPT4gaXNFbXB0eVRhc2ssXG4gIHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2s6ICgpID0+IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2ssXG4gIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2s6ICgpID0+IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2tcbn0pO1xuZnVuY3Rpb24gYWRob2NFeGVjVGFzayhwYXJzZXI0KSB7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHM6IEVNUFRZX0NPTU1BTkRTLFxuICAgIGZvcm1hdDogXCJlbXB0eVwiLFxuICAgIHBhcnNlcjogcGFyc2VyNFxuICB9O1xufVxuZnVuY3Rpb24gY29uZmlndXJhdGlvbkVycm9yVGFzayhlcnJvcikge1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzOiBFTVBUWV9DT01NQU5EUyxcbiAgICBmb3JtYXQ6IFwiZW1wdHlcIixcbiAgICBwYXJzZXIoKSB7XG4gICAgICB0aHJvdyB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIgPyBuZXcgVGFza0NvbmZpZ3VyYXRpb25FcnJvcihlcnJvcikgOiBlcnJvcjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzLCB0cmltbWVkMiA9IGZhbHNlKSB7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiB0cmltbWVkMiA/IFN0cmluZyh0ZXh0KS50cmltKCkgOiB0ZXh0O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2soY29tbWFuZHMpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwiYnVmZmVyXCIsXG4gICAgcGFyc2VyKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc0J1ZmZlclRhc2sodGFzaykge1xuICByZXR1cm4gdGFzay5mb3JtYXQgPT09IFwiYnVmZmVyXCI7XG59XG5mdW5jdGlvbiBpc0VtcHR5VGFzayh0YXNrKSB7XG4gIHJldHVybiB0YXNrLmZvcm1hdCA9PT0gXCJlbXB0eVwiIHx8ICF0YXNrLmNvbW1hbmRzLmxlbmd0aDtcbn1cbnZhciBFTVBUWV9DT01NQU5EUztcbnZhciBpbml0X3Rhc2sgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy90YXNrLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF90YXNrX2NvbmZpZ3VyYXRpb25fZXJyb3IoKTtcbiAgICBFTVBUWV9DT01NQU5EUyA9IFtdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jbGVhbi50c1xudmFyIGNsZWFuX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNsZWFuX2V4cG9ydHMsIHtcbiAgQ09ORklHX0VSUk9SX0lOVEVSQUNUSVZFX01PREU6ICgpID0+IENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFLFxuICBDT05GSUdfRVJST1JfTU9ERV9SRVFVSVJFRDogKCkgPT4gQ09ORklHX0VSUk9SX01PREVfUkVRVUlSRUQsXG4gIENPTkZJR19FUlJPUl9VTktOT1dOX09QVElPTjogKCkgPT4gQ09ORklHX0VSUk9SX1VOS05PV05fT1BUSU9OLFxuICBDbGVhbk9wdGlvbnM6ICgpID0+IENsZWFuT3B0aW9ucyxcbiAgY2xlYW5UYXNrOiAoKSA9PiBjbGVhblRhc2ssXG4gIGNsZWFuV2l0aE9wdGlvbnNUYXNrOiAoKSA9PiBjbGVhbldpdGhPcHRpb25zVGFzayxcbiAgaXNDbGVhbk9wdGlvbnNBcnJheTogKCkgPT4gaXNDbGVhbk9wdGlvbnNBcnJheVxufSk7XG5mdW5jdGlvbiBjbGVhbldpdGhPcHRpb25zVGFzayhtb2RlLCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IHsgY2xlYW5Nb2RlLCBvcHRpb25zLCB2YWxpZCB9ID0gZ2V0Q2xlYW5PcHRpb25zKG1vZGUpO1xuICBpZiAoIWNsZWFuTW9kZSkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVEKTtcbiAgfVxuICBpZiAoIXZhbGlkLm9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT04gKyBKU09OLnN0cmluZ2lmeShtb2RlKSk7XG4gIH1cbiAgb3B0aW9ucy5wdXNoKC4uLmN1c3RvbUFyZ3MpO1xuICBpZiAob3B0aW9ucy5zb21lKGlzSW50ZXJhY3RpdmVNb2RlKSkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFKTtcbiAgfVxuICByZXR1cm4gY2xlYW5UYXNrKGNsZWFuTW9kZSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjbGVhblRhc2sobW9kZSwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImNsZWFuXCIsIGAtJHttb2RlfWAsIC4uLmN1c3RvbUFyZ3NdO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICByZXR1cm4gY2xlYW5TdW1tYXJ5UGFyc2VyKG1vZGUgPT09IFwiblwiIC8qIERSWV9SVU4gKi8sIHRleHQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQ2xlYW5PcHRpb25zQXJyYXkoaW5wdXQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0LmV2ZXJ5KCh0ZXN0KSA9PiBDbGVhbk9wdGlvblZhbHVlcy5oYXModGVzdCkpO1xufVxuZnVuY3Rpb24gZ2V0Q2xlYW5PcHRpb25zKGlucHV0KSB7XG4gIGxldCBjbGVhbk1vZGU7XG4gIGxldCBvcHRpb25zID0gW107XG4gIGxldCB2YWxpZCA9IHsgY2xlYW5Nb2RlOiBmYWxzZSwgb3B0aW9uczogdHJ1ZSB9O1xuICBpbnB1dC5yZXBsYWNlKC9bXmEtel1pL2csIFwiXCIpLnNwbGl0KFwiXCIpLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICBpZiAoaXNDbGVhbk1vZGUoY2hhcikpIHtcbiAgICAgIGNsZWFuTW9kZSA9IGNoYXI7XG4gICAgICB2YWxpZC5jbGVhbk1vZGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZC5vcHRpb25zID0gdmFsaWQub3B0aW9ucyAmJiBpc0tub3duT3B0aW9uKG9wdGlvbnNbb3B0aW9ucy5sZW5ndGhdID0gYC0ke2NoYXJ9YCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGVhbk1vZGUsXG4gICAgb3B0aW9ucyxcbiAgICB2YWxpZFxuICB9O1xufVxuZnVuY3Rpb24gaXNDbGVhbk1vZGUoY2xlYW5Nb2RlKSB7XG4gIHJldHVybiBjbGVhbk1vZGUgPT09IFwiZlwiIC8qIEZPUkNFICovIHx8IGNsZWFuTW9kZSA9PT0gXCJuXCIgLyogRFJZX1JVTiAqLztcbn1cbmZ1bmN0aW9uIGlzS25vd25PcHRpb24ob3B0aW9uKSB7XG4gIHJldHVybiAvXi1bYS16XSQvaS50ZXN0KG9wdGlvbikgJiYgQ2xlYW5PcHRpb25WYWx1ZXMuaGFzKG9wdGlvbi5jaGFyQXQoMSkpO1xufVxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZU1vZGUob3B0aW9uKSB7XG4gIGlmICgvXi1bXlxcLV0vLnRlc3Qob3B0aW9uKSkge1xuICAgIHJldHVybiBvcHRpb24uaW5kZXhPZihcImlcIikgPiAwO1xuICB9XG4gIHJldHVybiBvcHRpb24gPT09IFwiLS1pbnRlcmFjdGl2ZVwiO1xufVxudmFyIENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFLCBDT05GSUdfRVJST1JfTU9ERV9SRVFVSVJFRCwgQ09ORklHX0VSUk9SX1VOS05PV05fT1BUSU9OLCBDbGVhbk9wdGlvbnMsIENsZWFuT3B0aW9uVmFsdWVzO1xudmFyIGluaXRfY2xlYW4gPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jbGVhbi50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfQ2xlYW5TdW1tYXJ5KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICAgIENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFID0gXCJHaXQgY2xlYW4gaW50ZXJhY3RpdmUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkXCI7XG4gICAgQ09ORklHX0VSUk9SX01PREVfUkVRVUlSRUQgPSAnR2l0IGNsZWFuIG1vZGUgcGFyYW1ldGVyIChcIm5cIiBvciBcImZcIikgaXMgcmVxdWlyZWQnO1xuICAgIENPTkZJR19FUlJPUl9VTktOT1dOX09QVElPTiA9IFwiR2l0IGNsZWFuIHVua25vd24gb3B0aW9uIGZvdW5kIGluOiBcIjtcbiAgICBDbGVhbk9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKChDbGVhbk9wdGlvbnMyKSA9PiB7XG4gICAgICBDbGVhbk9wdGlvbnMyW1wiRFJZX1JVTlwiXSA9IFwiblwiO1xuICAgICAgQ2xlYW5PcHRpb25zMltcIkZPUkNFXCJdID0gXCJmXCI7XG4gICAgICBDbGVhbk9wdGlvbnMyW1wiSUdOT1JFRF9JTkNMVURFRFwiXSA9IFwieFwiO1xuICAgICAgQ2xlYW5PcHRpb25zMltcIklHTk9SRURfT05MWVwiXSA9IFwiWFwiO1xuICAgICAgQ2xlYW5PcHRpb25zMltcIkVYQ0xVRElOR1wiXSA9IFwiZVwiO1xuICAgICAgQ2xlYW5PcHRpb25zMltcIlFVSUVUXCJdID0gXCJxXCI7XG4gICAgICBDbGVhbk9wdGlvbnMyW1wiUkVDVVJTSVZFXCJdID0gXCJkXCI7XG4gICAgICByZXR1cm4gQ2xlYW5PcHRpb25zMjtcbiAgICB9KShDbGVhbk9wdGlvbnMgfHwge30pO1xuICAgIENsZWFuT3B0aW9uVmFsdWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgICAgXCJpXCIsXG4gICAgICAuLi5hc1N0cmluZ0FycmF5KE9iamVjdC52YWx1ZXMoQ2xlYW5PcHRpb25zKSlcbiAgICBdKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0NvbmZpZ0xpc3QudHNcbmZ1bmN0aW9uIGNvbmZpZ0xpc3RQYXJzZXIodGV4dCkge1xuICBjb25zdCBjb25maWcgPSBuZXcgQ29uZmlnTGlzdCgpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZmlnUGFyc2VyKHRleHQpKSB7XG4gICAgY29uZmlnLmFkZFZhbHVlKGl0ZW0uZmlsZSwgU3RyaW5nKGl0ZW0ua2V5KSwgaXRlbS52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn1cbmZ1bmN0aW9uIGNvbmZpZ0dldFBhcnNlcih0ZXh0LCBrZXkpIHtcbiAgbGV0IHZhbHVlID0gbnVsbDtcbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGNvbnN0IHNjb3BlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBjb25maWdQYXJzZXIodGV4dCwga2V5KSkge1xuICAgIGlmIChpdGVtLmtleSAhPT0ga2V5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWVzLnB1c2godmFsdWUgPSBpdGVtLnZhbHVlKTtcbiAgICBpZiAoIXNjb3Blcy5oYXMoaXRlbS5maWxlKSkge1xuICAgICAgc2NvcGVzLnNldChpdGVtLmZpbGUsIFtdKTtcbiAgICB9XG4gICAgc2NvcGVzLmdldChpdGVtLmZpbGUpLnB1c2godmFsdWUpO1xuICB9XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHBhdGhzOiBBcnJheS5mcm9tKHNjb3Blcy5rZXlzKCkpLFxuICAgIHNjb3BlcyxcbiAgICB2YWx1ZSxcbiAgICB2YWx1ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ0ZpbGVQYXRoKGZpbGVQYXRoKSB7XG4gIHJldHVybiBmaWxlUGF0aC5yZXBsYWNlKC9eKGZpbGUpOi8sIFwiXCIpO1xufVxuZnVuY3Rpb24qIGNvbmZpZ1BhcnNlcih0ZXh0LCByZXF1ZXN0ZWRLZXkgPSBudWxsKSB7XG4gIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChcIlxcMFwiKTtcbiAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPCBtYXg7ICkge1xuICAgIGNvbnN0IGZpbGUgPSBjb25maWdGaWxlUGF0aChsaW5lc1tpKytdKTtcbiAgICBsZXQgdmFsdWUgPSBsaW5lc1tpKytdO1xuICAgIGxldCBrZXkgPSByZXF1ZXN0ZWRLZXk7XG4gICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICBjb25zdCBsaW5lID0gc3BsaXRPbih2YWx1ZSwgXCJcXG5cIik7XG4gICAgICBrZXkgPSBsaW5lWzBdO1xuICAgICAgdmFsdWUgPSBsaW5lWzFdO1xuICAgIH1cbiAgICB5aWVsZCB7IGZpbGUsIGtleSwgdmFsdWUgfTtcbiAgfVxufVxudmFyIENvbmZpZ0xpc3Q7XG52YXIgaW5pdF9Db25maWdMaXN0ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0NvbmZpZ0xpc3QudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgQ29uZmlnTGlzdCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZpbGVzID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICBnZXQgYWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2FsbCkge1xuICAgICAgICAgIHRoaXMuX2FsbCA9IHRoaXMuZmlsZXMucmVkdWNlKChhbGwsIGZpbGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFsbCwgdGhpcy52YWx1ZXNbZmlsZV0pO1xuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWxsO1xuICAgICAgfVxuICAgICAgYWRkRmlsZShmaWxlKSB7XG4gICAgICAgIGlmICghKGZpbGUgaW4gdGhpcy52YWx1ZXMpKSB7XG4gICAgICAgICAgY29uc3QgbGF0ZXN0ID0gbGFzdCh0aGlzLmZpbGVzKTtcbiAgICAgICAgICB0aGlzLnZhbHVlc1tmaWxlXSA9IGxhdGVzdCA/IE9iamVjdC5jcmVhdGUodGhpcy52YWx1ZXNbbGF0ZXN0XSkgOiB7fTtcbiAgICAgICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2ZpbGVdO1xuICAgICAgfVxuICAgICAgYWRkVmFsdWUoZmlsZSwga2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmFkZEZpbGUoZmlsZSk7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bih2YWx1ZXMsIGtleSkpIHtcbiAgICAgICAgICB2YWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzW2tleV0pKSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVzW2tleV0gPSBbdmFsdWVzW2tleV0sIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbGwgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY29uZmlnLnRzXG5mdW5jdGlvbiBhc0NvbmZpZ1Njb3BlKHNjb3BlLCBmYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSBcInN0cmluZ1wiICYmIE9iamVjdC5oYXNPd24oR2l0Q29uZmlnU2NvcGUsIHNjb3BlKSkge1xuICAgIHJldHVybiBzY29wZTtcbiAgfVxuICByZXR1cm4gZmFsbGJhY2s7XG59XG5mdW5jdGlvbiBhZGRDb25maWdUYXNrKGtleSwgdmFsdWUsIGFwcGVuZDIsIHNjb3BlKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiY29uZmlnXCIsIGAtLSR7c2NvcGV9YF07XG4gIGlmIChhcHBlbmQyKSB7XG4gICAgY29tbWFuZHMucHVzaChcIi0tYWRkXCIpO1xuICB9XG4gIGNvbW1hbmRzLnB1c2goa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbmZpZ1Rhc2soa2V5LCBzY29wZSkge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImNvbmZpZ1wiLCBcIi0tbnVsbFwiLCBcIi0tc2hvdy1vcmlnaW5cIiwgXCItLWdldC1hbGxcIiwga2V5XTtcbiAgaWYgKHNjb3BlKSB7XG4gICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIGAtLSR7c2NvcGV9YCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXIodGV4dCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ0dldFBhcnNlcih0ZXh0LCBrZXkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RDb25maWdUYXNrKHNjb3BlKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiY29uZmlnXCIsIFwiLS1saXN0XCIsIFwiLS1zaG93LW9yaWdpblwiLCBcIi0tbnVsbFwiXTtcbiAgaWYgKHNjb3BlKSB7XG4gICAgY29tbWFuZHMucHVzaChgLS0ke3Njb3BlfWApO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiBjb25maWdMaXN0UGFyc2VyKHRleHQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ19kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIGFkZENvbmZpZyhrZXksIHZhbHVlLCAuLi5yZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgYWRkQ29uZmlnVGFzayhcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgcmVzdFswXSA9PT0gdHJ1ZSxcbiAgICAgICAgICBhc0NvbmZpZ1Njb3BlKHJlc3RbMV0sIFwibG9jYWxcIiAvKiBsb2NhbCAqLylcbiAgICAgICAgKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfSxcbiAgICBnZXRDb25maWcoa2V5LCBzY29wZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGdldENvbmZpZ1Rhc2soa2V5LCBhc0NvbmZpZ1Njb3BlKHNjb3BlLCB2b2lkIDApKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfSxcbiAgICBsaXN0Q29uZmlnKC4uLnJlc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBsaXN0Q29uZmlnVGFzayhhc0NvbmZpZ1Njb3BlKHJlc3RbMF0sIHZvaWQgMCkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgR2l0Q29uZmlnU2NvcGU7XG52YXIgaW5pdF9jb25maWcgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jb25maWcudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0NvbmZpZ0xpc3QoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgR2l0Q29uZmlnU2NvcGUgPSAvKiBAX19QVVJFX18gKi8gKChHaXRDb25maWdTY29wZTIpID0+IHtcbiAgICAgIEdpdENvbmZpZ1Njb3BlMltcInN5c3RlbVwiXSA9IFwic3lzdGVtXCI7XG4gICAgICBHaXRDb25maWdTY29wZTJbXCJnbG9iYWxcIl0gPSBcImdsb2JhbFwiO1xuICAgICAgR2l0Q29uZmlnU2NvcGUyW1wibG9jYWxcIl0gPSBcImxvY2FsXCI7XG4gICAgICBHaXRDb25maWdTY29wZTJbXCJ3b3JrdHJlZVwiXSA9IFwid29ya3RyZWVcIjtcbiAgICAgIHJldHVybiBHaXRDb25maWdTY29wZTI7XG4gICAgfSkoR2l0Q29uZmlnU2NvcGUgfHwge30pO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9kaWZmLW5hbWUtc3RhdHVzLnRzXG5mdW5jdGlvbiBpc0RpZmZOYW1lU3RhdHVzKGlucHV0KSB7XG4gIHJldHVybiBkaWZmTmFtZVN0YXR1cy5oYXMoaW5wdXQpO1xufVxudmFyIERpZmZOYW1lU3RhdHVzLCBkaWZmTmFtZVN0YXR1cztcbnZhciBpbml0X2RpZmZfbmFtZV9zdGF0dXMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9kaWZmLW5hbWUtc3RhdHVzLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgRGlmZk5hbWVTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChEaWZmTmFtZVN0YXR1czIpID0+IHtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIkFEREVEXCJdID0gXCJBXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJDT1BJRURcIl0gPSBcIkNcIjtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIkRFTEVURURcIl0gPSBcIkRcIjtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIk1PRElGSUVEXCJdID0gXCJNXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJSRU5BTUVEXCJdID0gXCJSXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJDSEFOR0VEXCJdID0gXCJUXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJVTk1FUkdFRFwiXSA9IFwiVVwiO1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiVU5LTk9XTlwiXSA9IFwiWFwiO1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiQlJPS0VOXCJdID0gXCJCXCI7XG4gICAgICByZXR1cm4gRGlmZk5hbWVTdGF0dXMyO1xuICAgIH0pKERpZmZOYW1lU3RhdHVzIHx8IHt9KTtcbiAgICBkaWZmTmFtZVN0YXR1cyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhEaWZmTmFtZVN0YXR1cykpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9ncmVwLnRzXG5mdW5jdGlvbiBncmVwUXVlcnlCdWlsZGVyKC4uLnBhcmFtcykge1xuICByZXR1cm4gbmV3IEdyZXBRdWVyeSgpLnBhcmFtKC4uLnBhcmFtcyk7XG59XG5mdW5jdGlvbiBwYXJzZUdyZXAoZ3JlcCkge1xuICBjb25zdCBwYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgZm9yRWFjaExpbmVXaXRoQ29udGVudChncmVwLCAoaW5wdXQpID0+IHtcbiAgICBjb25zdCBbcGF0aCwgbGluZSwgcHJldmlld10gPSBpbnB1dC5zcGxpdChOVUxMKTtcbiAgICBwYXRocy5hZGQocGF0aCk7XG4gICAgKHJlc3VsdHNbcGF0aF0gPSByZXN1bHRzW3BhdGhdIHx8IFtdKS5wdXNoKHtcbiAgICAgIGxpbmU6IGFzTnVtYmVyKGxpbmUpLFxuICAgICAgcGF0aCxcbiAgICAgIHByZXZpZXdcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcGF0aHMsXG4gICAgcmVzdWx0c1xuICB9O1xufVxuZnVuY3Rpb24gZ3JlcF9kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIGdyZXAoc2VhcmNoVGVybSkge1xuICAgICAgY29uc3QgdGhlbiA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpO1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGlzYWxsb3dlZE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZXMob3B0aW9uKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LmdyZXA6IHVzZSBvZiBcIiR7b3B0aW9ufVwiIGlzIG5vdCBzdXBwb3J0ZWQuYCksXG4gICAgICAgICAgICB0aGVuXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZWFyY2hUZXJtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNlYXJjaFRlcm0gPSBncmVwUXVlcnlCdWlsZGVyKCkucGFyYW0oc2VhcmNoVGVybSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21tYW5kcyA9IFtcImdyZXBcIiwgXCItLW51bGxcIiwgXCItblwiLCBcIi0tZnVsbC1uYW1lXCIsIC4uLm9wdGlvbnMsIC4uLnNlYXJjaFRlcm1dO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHtcbiAgICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICAgICAgICBwYXJzZXIoc3RkT3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VHcmVwKHN0ZE91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aGVuXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbnZhciBkaXNhbGxvd2VkT3B0aW9ucywgUXVlcnksIF9hLCBHcmVwUXVlcnk7XG52YXIgaW5pdF9ncmVwID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvZ3JlcC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgICBkaXNhbGxvd2VkT3B0aW9ucyA9IFtcIi1oXCJdO1xuICAgIFF1ZXJ5ID0gU3ltYm9sKFwiZ3JlcFF1ZXJ5XCIpO1xuICAgIEdyZXBRdWVyeSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzW19hXSA9IFtdO1xuICAgICAgfVxuICAgICAgKlsoX2EgPSBRdWVyeSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgdGhpc1tRdWVyeV0pIHtcbiAgICAgICAgICB5aWVsZCBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYW5kKC4uLmFuZCkge1xuICAgICAgICBhbmQubGVuZ3RoICYmIHRoaXNbUXVlcnldLnB1c2goXCItLWFuZFwiLCBcIihcIiwgLi4ucHJlZml4ZWRBcnJheShhbmQsIFwiLWVcIiksIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBwYXJhbSguLi5wYXJhbSkge1xuICAgICAgICB0aGlzW1F1ZXJ5XS5wdXNoKC4uLnByZWZpeGVkQXJyYXkocGFyYW0sIFwiLWVcIikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9yZXNldC50c1xudmFyIHJlc2V0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJlc2V0X2V4cG9ydHMsIHtcbiAgUmVzZXRNb2RlOiAoKSA9PiBSZXNldE1vZGUsXG4gIGdldFJlc2V0TW9kZTogKCkgPT4gZ2V0UmVzZXRNb2RlLFxuICByZXNldFRhc2s6ICgpID0+IHJlc2V0VGFza1xufSk7XG5mdW5jdGlvbiByZXNldFRhc2sobW9kZSwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInJlc2V0XCJdO1xuICBpZiAoaXNWYWxpZFJlc2V0TW9kZShtb2RlKSkge1xuICAgIGNvbW1hbmRzLnB1c2goYC0tJHttb2RlfWApO1xuICB9XG4gIGNvbW1hbmRzLnB1c2goLi4uY3VzdG9tQXJncyk7XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cbmZ1bmN0aW9uIGdldFJlc2V0TW9kZShtb2RlKSB7XG4gIGlmIChpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpKSB7XG4gICAgcmV0dXJuIG1vZGU7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgbW9kZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gXCJzb2Z0XCIgLyogU09GVCAqLztcbiAgfVxuICByZXR1cm47XG59XG5mdW5jdGlvbiBpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBtb2RlID09PSBcInN0cmluZ1wiICYmIHZhbGlkUmVzZXRNb2Rlcy5pbmNsdWRlcyhtb2RlKTtcbn1cbnZhciBSZXNldE1vZGUsIHZhbGlkUmVzZXRNb2RlcztcbnZhciBpbml0X3Jlc2V0ID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvcmVzZXQudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gICAgUmVzZXRNb2RlID0gLyogQF9fUFVSRV9fICovICgoUmVzZXRNb2RlMikgPT4ge1xuICAgICAgUmVzZXRNb2RlMltcIk1JWEVEXCJdID0gXCJtaXhlZFwiO1xuICAgICAgUmVzZXRNb2RlMltcIlNPRlRcIl0gPSBcInNvZnRcIjtcbiAgICAgIFJlc2V0TW9kZTJbXCJIQVJEXCJdID0gXCJoYXJkXCI7XG4gICAgICBSZXNldE1vZGUyW1wiTUVSR0VcIl0gPSBcIm1lcmdlXCI7XG4gICAgICBSZXNldE1vZGUyW1wiS0VFUFwiXSA9IFwia2VlcFwiO1xuICAgICAgcmV0dXJuIFJlc2V0TW9kZTI7XG4gICAgfSkoUmVzZXRNb2RlIHx8IHt9KTtcbiAgICB2YWxpZFJlc2V0TW9kZXMgPSBhc1N0cmluZ0FycmF5KE9iamVjdC52YWx1ZXMoUmVzZXRNb2RlKSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2dpdC1sb2dnZXIudHNcbmltcG9ydCBkZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmZ1bmN0aW9uIGNyZWF0ZUxvZygpIHtcbiAgcmV0dXJuIGRlYnVnKFwic2ltcGxlLWdpdFwiKTtcbn1cbmZ1bmN0aW9uIHByZWZpeGVkTG9nZ2VyKHRvLCBwcmVmaXgsIGZvcndhcmQpIHtcbiAgaWYgKCFwcmVmaXggfHwgIVN0cmluZyhwcmVmaXgpLnJlcGxhY2UoL1xccyovLCBcIlwiKSkge1xuICAgIHJldHVybiAhZm9yd2FyZCA/IHRvIDogKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICAgIHRvKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgZm9yd2FyZChtZXNzYWdlLCAuLi5hcmdzKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICAgIHRvKGAlcyAke21lc3NhZ2V9YCwgcHJlZml4LCAuLi5hcmdzKTtcbiAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgZm9yd2FyZChtZXNzYWdlLCAuLi5hcmdzKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjaGlsZExvZ2dlck5hbWUobmFtZSwgY2hpbGREZWJ1Z2dlciwgeyBuYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSB9KSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIGNvbnN0IGNoaWxkTmFtZXNwYWNlID0gY2hpbGREZWJ1Z2dlciAmJiBjaGlsZERlYnVnZ2VyLm5hbWVzcGFjZSB8fCBcIlwiO1xuICBpZiAoY2hpbGROYW1lc3BhY2Uuc3RhcnRzV2l0aChwYXJlbnROYW1lc3BhY2UpKSB7XG4gICAgcmV0dXJuIGNoaWxkTmFtZXNwYWNlLnN1YnN0cihwYXJlbnROYW1lc3BhY2UubGVuZ3RoICsgMSk7XG4gIH1cbiAgcmV0dXJuIGNoaWxkTmFtZXNwYWNlIHx8IHBhcmVudE5hbWVzcGFjZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlcihsYWJlbCwgdmVyYm9zZSwgaW5pdGlhbFN0ZXAsIGluZm9EZWJ1Z2dlciA9IGNyZWF0ZUxvZygpKSB7XG4gIGNvbnN0IGxhYmVsUHJlZml4ID0gbGFiZWwgJiYgYFske2xhYmVsfV1gIHx8IFwiXCI7XG4gIGNvbnN0IHNwYXduZWQgPSBbXTtcbiAgY29uc3QgZGVidWdEZWJ1Z2dlciA9IHR5cGVvZiB2ZXJib3NlID09PSBcInN0cmluZ1wiID8gaW5mb0RlYnVnZ2VyLmV4dGVuZCh2ZXJib3NlKSA6IHZlcmJvc2U7XG4gIGNvbnN0IGtleSA9IGNoaWxkTG9nZ2VyTmFtZShmaWx0ZXJUeXBlKHZlcmJvc2UsIGZpbHRlclN0cmluZyksIGRlYnVnRGVidWdnZXIsIGluZm9EZWJ1Z2dlcik7XG4gIHJldHVybiBzdGVwKGluaXRpYWxTdGVwKTtcbiAgZnVuY3Rpb24gc2libGluZyhuYW1lLCBpbml0aWFsKSB7XG4gICAgcmV0dXJuIGFwcGVuZChcbiAgICAgIHNwYXduZWQsXG4gICAgICBjcmVhdGVMb2dnZXIobGFiZWwsIGtleS5yZXBsYWNlKC9eW146XSsvLCBuYW1lKSwgaW5pdGlhbCwgaW5mb0RlYnVnZ2VyKVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gc3RlcChwaGFzZSkge1xuICAgIGNvbnN0IHN0ZXBQcmVmaXggPSBwaGFzZSAmJiBgWyR7cGhhc2V9XWAgfHwgXCJcIjtcbiAgICBjb25zdCBkZWJ1ZzIgPSBkZWJ1Z0RlYnVnZ2VyICYmIHByZWZpeGVkTG9nZ2VyKGRlYnVnRGVidWdnZXIsIHN0ZXBQcmVmaXgpIHx8IE5PT1A7XG4gICAgY29uc3QgaW5mbyA9IHByZWZpeGVkTG9nZ2VyKGluZm9EZWJ1Z2dlciwgYCR7bGFiZWxQcmVmaXh9ICR7c3RlcFByZWZpeH1gLCBkZWJ1ZzIpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlYnVnRGVidWdnZXIgPyBkZWJ1ZzIgOiBpbmZvLCB7XG4gICAgICBsYWJlbCxcbiAgICAgIHNpYmxpbmcsXG4gICAgICBpbmZvLFxuICAgICAgc3RlcFxuICAgIH0pO1xuICB9XG59XG52YXIgaW5pdF9naXRfbG9nZ2VyID0gX19lc20oe1xuICBcInNyYy9saWIvZ2l0LWxvZ2dlci50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBkZWJ1Zy5mb3JtYXR0ZXJzLkwgPSAodmFsdWUpID0+IFN0cmluZyhmaWx0ZXJIYXNMZW5ndGgodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogXCItXCIpO1xuICAgIGRlYnVnLmZvcm1hdHRlcnMuQiA9ICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcnVubmVycy90YXNrcy1wZW5kaW5nLXF1ZXVlLnRzXG52YXIgVGFza3NQZW5kaW5nUXVldWU7XG52YXIgaW5pdF90YXNrc19wZW5kaW5nX3F1ZXVlID0gX19lc20oe1xuICBcInNyYy9saWIvcnVubmVycy90YXNrcy1wZW5kaW5nLXF1ZXVlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfZXJyb3IoKTtcbiAgICBpbml0X2dpdF9sb2dnZXIoKTtcbiAgICBUYXNrc1BlbmRpbmdRdWV1ZSA9IGNsYXNzIF9UYXNrc1BlbmRpbmdRdWV1ZSB7XG4gICAgICBjb25zdHJ1Y3Rvcihsb2dMYWJlbCA9IFwiR2l0RXhlY3V0b3JcIikge1xuICAgICAgICB0aGlzLmxvZ0xhYmVsID0gbG9nTGFiZWw7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIHdpdGhQcm9ncmVzcyh0YXNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5nZXQodGFzayk7XG4gICAgICB9XG4gICAgICBjcmVhdGVQcm9ncmVzcyh0YXNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBfVGFza3NQZW5kaW5nUXVldWUuZ2V0TmFtZSh0YXNrLmNvbW1hbmRzWzBdKTtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHRoaXMubG9nTGFiZWwsIG5hbWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgbG9nZ2VyLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHB1c2godGFzaykge1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMuY3JlYXRlUHJvZ3Jlc3ModGFzayk7XG4gICAgICAgIHByb2dyZXNzLmxvZ2dlcihcIkFkZGluZyB0YXNrIHRvIHRoZSBxdWV1ZSwgY29tbWFuZHMgPSAlb1wiLCB0YXNrLmNvbW1hbmRzKTtcbiAgICAgICAgdGhpcy5fcXVldWUuc2V0KHRhc2ssIHByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgICAgfVxuICAgICAgZmF0YWwoZXJyKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3Rhc2ssIHsgbG9nZ2VyIH1dIG9mIEFycmF5LmZyb20odGhpcy5fcXVldWUuZW50cmllcygpKSkge1xuICAgICAgICAgIGlmICh0YXNrID09PSBlcnIudGFzaykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEZhaWxlZCAlb2AsIGVycik7XG4gICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgIGBGYXRhbCBleGNlcHRpb24sIGFueSBhcy15ZXQgdW4tc3RhcnRlZCB0YXNrcyBydW4gdGhyb3VnaCB0aGlzIGV4ZWN1dG9yIHdpbGwgbm90IGJlIGF0dGVtcHRlZGBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICBgQSBmYXRhbCBleGNlcHRpb24gb2NjdXJyZWQgaW4gYSBwcmV2aW91cyB0YXNrLCB0aGUgcXVldWUgaGFzIGJlZW4gcHVyZ2VkOiAlb2AsXG4gICAgICAgICAgICAgIGVyci5tZXNzYWdlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBRdWV1ZSBzaXplIHNob3VsZCBiZSB6ZXJvIGFmdGVyIGZhdGFsOiAke3RoaXMuX3F1ZXVlLnNpemV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbXBsZXRlKHRhc2spIHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLndpdGhQcm9ncmVzcyh0YXNrKTtcbiAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgdGhpcy5fcXVldWUuZGVsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhdHRlbXB0KHRhc2spIHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLndpdGhQcm9ncmVzcyh0YXNrKTtcbiAgICAgICAgaWYgKCFwcm9ncmVzcykge1xuICAgICAgICAgIHRocm93IG5ldyBHaXRFcnJvcih2b2lkIDAsIFwiVGFza3NQZW5kaW5nUXVldWU6IGF0dGVtcHQgY2FsbGVkIGZvciBhbiB1bmtub3duIHRhc2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcHJvZ3Jlc3MubG9nZ2VyKFwiU3RhcnRpbmcgdGFza1wiKTtcbiAgICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgICAgfVxuICAgICAgc3RhdGljIGdldE5hbWUobmFtZSA9IFwiZW1wdHlcIikge1xuICAgICAgICByZXR1cm4gYHRhc2s6JHtuYW1lfTokeysrX1Rhc2tzUGVuZGluZ1F1ZXVlLmNvdW50ZXJ9YDtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyB7XG4gICAgICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcnVubmVycy9naXQtZXhlY3V0b3ItY2hhaW4udHNcbmltcG9ydCB7IHNwYXduIH0gZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmZ1bmN0aW9uIHBsdWdpbkNvbnRleHQodGFzaywgY29tbWFuZHMpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IGZpcnN0KHRhc2suY29tbWFuZHMpIHx8IFwiXCIsXG4gICAgY29tbWFuZHNcbiAgfTtcbn1cbmZ1bmN0aW9uIG9uRXJyb3JSZWNlaXZlZCh0YXJnZXQsIGxvZ2dlcikge1xuICByZXR1cm4gKGVycikgPT4ge1xuICAgIGxvZ2dlcihgW0VSUk9SXSBjaGlsZCBwcm9jZXNzIGV4Y2VwdGlvbiAlb2AsIGVycik7XG4gICAgdGFyZ2V0LnB1c2goQnVmZmVyLmZyb20oU3RyaW5nKGVyci5zdGFjayksIFwiYXNjaWlcIikpO1xuICB9O1xufVxuZnVuY3Rpb24gb25EYXRhUmVjZWl2ZWQodGFyZ2V0LCBuYW1lLCBsb2dnZXIsIG91dHB1dCkge1xuICByZXR1cm4gKGJ1ZmZlcikgPT4ge1xuICAgIGxvZ2dlcihgJXMgcmVjZWl2ZWQgJUwgYnl0ZXNgLCBuYW1lLCBidWZmZXIpO1xuICAgIG91dHB1dChgJUJgLCBidWZmZXIpO1xuICAgIHRhcmdldC5wdXNoKGJ1ZmZlcik7XG4gIH07XG59XG52YXIgR2l0RXhlY3V0b3JDaGFpbjtcbnZhciBpbml0X2dpdF9leGVjdXRvcl9jaGFpbiA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3J1bm5lcnMvZ2l0LWV4ZWN1dG9yLWNoYWluLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfZXJyb3IoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrc19wZW5kaW5nX3F1ZXVlKCk7XG4gICAgR2l0RXhlY3V0b3JDaGFpbiA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKF9leGVjdXRvciwgX3NjaGVkdWxlciwgX3BsdWdpbnMpIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0b3IgPSBfZXhlY3V0b3I7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlciA9IF9zY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBfcGx1Z2lucztcbiAgICAgICAgdGhpcy5fY2hhaW4gPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgVGFza3NQZW5kaW5nUXVldWUoKTtcbiAgICAgIH1cbiAgICAgIGdldCBjd2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jd2QgfHwgdGhpcy5fZXhlY3V0b3IuY3dkO1xuICAgICAgfVxuICAgICAgc2V0IGN3ZChjd2QpIHtcbiAgICAgICAgdGhpcy5fY3dkID0gY3dkO1xuICAgICAgfVxuICAgICAgZ2V0IGVudigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4ZWN1dG9yLmVudjtcbiAgICAgIH1cbiAgICAgIGdldCBvdXRwdXRIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhlY3V0b3Iub3V0cHV0SGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGNoYWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHB1c2godGFzaykge1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW4gPSB0aGlzLl9jaGFpbi50aGVuKCgpID0+IHRoaXMuYXR0ZW1wdFRhc2sodGFzaykpO1xuICAgICAgfVxuICAgICAgYXN5bmMgYXR0ZW1wdFRhc2sodGFzaykge1xuICAgICAgICBjb25zdCBvblNjaGVkdWxlQ29tcGxldGUgPSBhd2FpdCB0aGlzLl9zY2hlZHVsZXIubmV4dCgpO1xuICAgICAgICBjb25zdCBvblF1ZXVlQ29tcGxldGUgPSAoKSA9PiB0aGlzLl9xdWV1ZS5jb21wbGV0ZSh0YXNrKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGxvZ2dlciB9ID0gdGhpcy5fcXVldWUuYXR0ZW1wdCh0YXNrKTtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgKGlzRW1wdHlUYXNrKHRhc2spID8gdGhpcy5hdHRlbXB0RW1wdHlUYXNrKHRhc2ssIGxvZ2dlcikgOiB0aGlzLmF0dGVtcHRSZW1vdGVUYXNrKHRhc2ssIGxvZ2dlcikpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5vbkZhdGFsRXhjZXB0aW9uKHRhc2ssIGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIG9uUXVldWVDb21wbGV0ZSgpO1xuICAgICAgICAgIG9uU2NoZWR1bGVDb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkZhdGFsRXhjZXB0aW9uKHRhc2ssIGUpIHtcbiAgICAgICAgY29uc3QgZ2l0RXJyb3IgPSBlIGluc3RhbmNlb2YgR2l0RXJyb3IgPyBPYmplY3QuYXNzaWduKGUsIHsgdGFzayB9KSA6IG5ldyBHaXRFcnJvcih0YXNrLCBlICYmIFN0cmluZyhlKSk7XG4gICAgICAgIHRoaXMuX2NoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLmZhdGFsKGdpdEVycm9yKTtcbiAgICAgICAgcmV0dXJuIGdpdEVycm9yO1xuICAgICAgfVxuICAgICAgYXN5bmMgYXR0ZW1wdFJlbW90ZVRhc2sodGFzaywgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IGJpbmFyeSA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcInNwYXduLmJpbmFyeVwiLCBcIlwiLCBwbHVnaW5Db250ZXh0KHRhc2ssIHRhc2suY29tbWFuZHMpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICBcInNwYXduLmFyZ3NcIixcbiAgICAgICAgICBbLi4udGFzay5jb21tYW5kc10sXG4gICAgICAgICAgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCByYXcgPSBhd2FpdCB0aGlzLmdpdFJlc3BvbnNlKFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgYmluYXJ5LFxuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgdGhpcy5vdXRwdXRIYW5kbGVyLFxuICAgICAgICAgIGxvZ2dlci5zdGVwKFwiU1BBV05cIilcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0U3RyZWFtcyA9IGF3YWl0IHRoaXMuaGFuZGxlVGFza0RhdGEodGFzaywgYXJncywgcmF3LCBsb2dnZXIuc3RlcChcIkhBTkRMRVwiKSk7XG4gICAgICAgIGxvZ2dlcihgcGFzc2luZyByZXNwb25zZSB0byB0YXNrJ3MgcGFyc2VyIGFzIGEgJXNgLCB0YXNrLmZvcm1hdCk7XG4gICAgICAgIGlmIChpc0J1ZmZlclRhc2sodGFzaykpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbFRhc2tQYXJzZXIodGFzay5wYXJzZXIsIG91dHB1dFN0cmVhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsVGFza1BhcnNlcih0YXNrLnBhcnNlciwgb3V0cHV0U3RyZWFtcy5hc1N0cmluZ3MoKSk7XG4gICAgICB9XG4gICAgICBhc3luYyBhdHRlbXB0RW1wdHlUYXNrKHRhc2ssIGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIoYGVtcHR5IHRhc2sgYnlwYXNzaW5nIGNoaWxkIHByb2Nlc3MgdG8gY2FsbCB0byB0YXNrJ3MgcGFyc2VyYCk7XG4gICAgICAgIHJldHVybiB0YXNrLnBhcnNlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZVRhc2tEYXRhKHRhc2ssIGFyZ3MsIHJlc3VsdCwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IHsgZXhpdENvZGUsIHJlamVjdGlvbiwgc3RkT3V0LCBzdGRFcnIgfSA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChkb25lLCBmYWlsKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyKGBQcmVwYXJpbmcgdG8gaGFuZGxlIHByb2Nlc3MgcmVzcG9uc2UgZXhpdENvZGU9JWQgc3RkT3V0PWAsIGV4aXRDb2RlKTtcbiAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSB0aGlzLl9wbHVnaW5zLmV4ZWMoXG4gICAgICAgICAgICBcInRhc2suZXJyb3JcIixcbiAgICAgICAgICAgIHsgZXJyb3I6IHJlamVjdGlvbiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAgICAuLi5yZXN1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChlcnJvciAmJiB0YXNrLm9uRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBleGl0Q29kZT0lcyBoYW5kbGluZyB3aXRoIGN1c3RvbSBlcnJvciBoYW5kbGVyYCk7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5vbkVycm9yKFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAobmV3U3RkT3V0KSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYGN1c3RvbSBlcnJvciBoYW5kbGVyIHRyZWF0ZWQgYXMgc3VjY2Vzc2ApO1xuICAgICAgICAgICAgICAgIGxvZ2dlcihgY3VzdG9tIGVycm9yIHJldHVybmVkIGEgJXNgLCBvYmplY3RUb1N0cmluZyhuZXdTdGRPdXQpKTtcbiAgICAgICAgICAgICAgICBkb25lKFxuICAgICAgICAgICAgICAgICAgbmV3IEdpdE91dHB1dFN0cmVhbXMoXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkobmV3U3RkT3V0KSA/IEJ1ZmZlci5jb25jYXQobmV3U3RkT3V0KSA6IG5ld1N0ZE91dCxcbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmNvbmNhdChzdGRFcnIpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZmFpbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgYGhhbmRsaW5nIGFzIGVycm9yOiBleGl0Q29kZT0lcyBzdGRFcnI9JXMgcmVqZWN0aW9uPSVvYCxcbiAgICAgICAgICAgICAgZXhpdENvZGUsXG4gICAgICAgICAgICAgIHN0ZEVyci5sZW5ndGgsXG4gICAgICAgICAgICAgIHJlamVjdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYHJldHJpZXZpbmcgdGFzayBvdXRwdXQgY29tcGxldGVgKTtcbiAgICAgICAgICBkb25lKG5ldyBHaXRPdXRwdXRTdHJlYW1zKEJ1ZmZlci5jb25jYXQoc3RkT3V0KSwgQnVmZmVyLmNvbmNhdChzdGRFcnIpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXN5bmMgZ2l0UmVzcG9uc2UodGFzaywgY29tbWFuZCwgYXJncywgb3V0cHV0SGFuZGxlciwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dExvZ2dlciA9IGxvZ2dlci5zaWJsaW5nKFwib3V0cHV0XCIpO1xuICAgICAgICBjb25zdCBzcGF3bk9wdGlvbnMgPSB0aGlzLl9wbHVnaW5zLmV4ZWMoXG4gICAgICAgICAgXCJzcGF3bi5vcHRpb25zXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgICAgICAgIGVudjogdGhpcy5lbnYsXG4gICAgICAgICAgICB3aW5kb3dzSGlkZTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGRPdXQgPSBbXTtcbiAgICAgICAgICBjb25zdCBzdGRFcnIgPSBbXTtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgJXMgJW9gLCBjb21tYW5kLCBhcmdzKTtcbiAgICAgICAgICBsb2dnZXIoXCIlT1wiLCBzcGF3bk9wdGlvbnMpO1xuICAgICAgICAgIGxldCByZWplY3Rpb24gPSB0aGlzLl9iZWZvcmVTcGF3bih0YXNrLCBhcmdzKTtcbiAgICAgICAgICBpZiAocmVqZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSh7XG4gICAgICAgICAgICAgIHN0ZE91dCxcbiAgICAgICAgICAgICAgc3RkRXJyLFxuICAgICAgICAgICAgICBleGl0Q29kZTogOTkwMSxcbiAgICAgICAgICAgICAgcmVqZWN0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcGx1Z2lucy5leGVjKFwic3Bhd24uYmVmb3JlXCIsIHZvaWQgMCwge1xuICAgICAgICAgICAgLi4ucGx1Z2luQ29udGV4dCh0YXNrLCBhcmdzKSxcbiAgICAgICAgICAgIGtpbGwocmVhc29uKSB7XG4gICAgICAgICAgICAgIHJlamVjdGlvbiA9IHJlYXNvbiB8fCByZWplY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgc3Bhd25lZCA9IHNwYXduKGNvbW1hbmQsIGFyZ3MsIHNwYXduT3B0aW9ucyk7XG4gICAgICAgICAgc3Bhd25lZC5zdGRvdXQub24oXG4gICAgICAgICAgICBcImRhdGFcIixcbiAgICAgICAgICAgIG9uRGF0YVJlY2VpdmVkKHN0ZE91dCwgXCJzdGRPdXRcIiwgbG9nZ2VyLCBvdXRwdXRMb2dnZXIuc3RlcChcInN0ZE91dFwiKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHNwYXduZWQuc3RkZXJyLm9uKFxuICAgICAgICAgICAgXCJkYXRhXCIsXG4gICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRFcnIsIFwic3RkRXJyXCIsIGxvZ2dlciwgb3V0cHV0TG9nZ2VyLnN0ZXAoXCJzdGRFcnJcIikpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzcGF3bmVkLm9uKFwiZXJyb3JcIiwgb25FcnJvclJlY2VpdmVkKHN0ZEVyciwgbG9nZ2VyKSk7XG4gICAgICAgICAgaWYgKG91dHB1dEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlcihgUGFzc2luZyBjaGlsZCBwcm9jZXNzIHN0ZE91dC9zdGRFcnIgdG8gY3VzdG9tIG91dHB1dEhhbmRsZXJgKTtcbiAgICAgICAgICAgIG91dHB1dEhhbmRsZXIoY29tbWFuZCwgc3Bhd25lZC5zdGRvdXQsIHNwYXduZWQuc3RkZXJyLCBbLi4uYXJnc10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9wbHVnaW5zLmV4ZWMoXCJzcGF3bi5hZnRlclwiLCB2b2lkIDAsIHtcbiAgICAgICAgICAgIC4uLnBsdWdpbkNvbnRleHQodGFzaywgYXJncyksXG4gICAgICAgICAgICBzcGF3bmVkLFxuICAgICAgICAgICAgY2xvc2UoZXhpdENvZGUsIHJlYXNvbikge1xuICAgICAgICAgICAgICBkb25lKHtcbiAgICAgICAgICAgICAgICBzdGRPdXQsXG4gICAgICAgICAgICAgICAgc3RkRXJyLFxuICAgICAgICAgICAgICAgIGV4aXRDb2RlLFxuICAgICAgICAgICAgICAgIHJlamVjdGlvbjogcmVqZWN0aW9uIHx8IHJlYXNvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBraWxsKHJlYXNvbikge1xuICAgICAgICAgICAgICBpZiAoc3Bhd25lZC5raWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uO1xuICAgICAgICAgICAgICBzcGF3bmVkLmtpbGwoXCJTSUdJTlRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgX2JlZm9yZVNwYXduKHRhc2ssIGFyZ3MpIHtcbiAgICAgICAgbGV0IHJlamVjdGlvbjtcbiAgICAgICAgdGhpcy5fcGx1Z2lucy5leGVjKFwic3Bhd24uYmVmb3JlXCIsIHZvaWQgMCwge1xuICAgICAgICAgIC4uLnBsdWdpbkNvbnRleHQodGFzaywgYXJncyksXG4gICAgICAgICAga2lsbChyZWFzb24pIHtcbiAgICAgICAgICAgIHJlamVjdGlvbiA9IHJlYXNvbiB8fCByZWplY3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlamVjdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvci50c1xudmFyIGdpdF9leGVjdXRvcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChnaXRfZXhlY3V0b3JfZXhwb3J0cywge1xuICBHaXRFeGVjdXRvcjogKCkgPT4gR2l0RXhlY3V0b3Jcbn0pO1xudmFyIEdpdEV4ZWN1dG9yO1xudmFyIGluaXRfZ2l0X2V4ZWN1dG9yID0gX19lc20oe1xuICBcInNyYy9saWIvcnVubmVycy9naXQtZXhlY3V0b3IudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2dpdF9leGVjdXRvcl9jaGFpbigpO1xuICAgIEdpdEV4ZWN1dG9yID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoY3dkLCBfc2NoZWR1bGVyLCBfcGx1Z2lucykge1xuICAgICAgICB0aGlzLmN3ZCA9IGN3ZDtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVyID0gX3NjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5fcGx1Z2lucyA9IF9wbHVnaW5zO1xuICAgICAgICB0aGlzLl9jaGFpbiA9IG5ldyBHaXRFeGVjdXRvckNoYWluKHRoaXMsIHRoaXMuX3NjaGVkdWxlciwgdGhpcy5fcGx1Z2lucyk7XG4gICAgICB9XG4gICAgICBjaGFpbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHaXRFeGVjdXRvckNoYWluKHRoaXMsIHRoaXMuX3NjaGVkdWxlciwgdGhpcy5fcGx1Z2lucyk7XG4gICAgICB9XG4gICAgICBwdXNoKHRhc2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluLnB1c2godGFzayk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFzay1jYWxsYmFjay50c1xuZnVuY3Rpb24gdGFza0NhbGxiYWNrKHRhc2ssIHJlc3BvbnNlLCBjYWxsYmFjayA9IE5PT1ApIHtcbiAgY29uc3Qgb25TdWNjZXNzID0gKGRhdGEpID0+IHtcbiAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgfTtcbiAgY29uc3Qgb25FcnJvcjIgPSAoZXJyKSA9PiB7XG4gICAgaWYgKGVycj8udGFzayA9PT0gdGFzaykge1xuICAgICAgY2FsbGJhY2soXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEdpdFJlc3BvbnNlRXJyb3IgPyBhZGREZXByZWNhdGlvbk5vdGljZVRvRXJyb3IoZXJyKSA6IGVycixcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgcmVzcG9uc2UudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IyKTtcbn1cbmZ1bmN0aW9uIGFkZERlcHJlY2F0aW9uTm90aWNlVG9FcnJvcihlcnIpIHtcbiAgbGV0IGxvZyA9IChuYW1lKSA9PiB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYHNpbXBsZS1naXQgZGVwcmVjYXRpb24gbm90aWNlOiBhY2Nlc3NpbmcgR2l0UmVzcG9uc2VFcnJvci4ke25hbWV9IHNob3VsZCBiZSBHaXRSZXNwb25zZUVycm9yLmdpdC4ke25hbWV9LCB0aGlzIHdpbGwgbm8gbG9uZ2VyIGJlIGF2YWlsYWJsZSBpbiB2ZXJzaW9uIDNgXG4gICAgKTtcbiAgICBsb2cgPSBOT09QO1xuICB9O1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShlcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVyci5naXQpLnJlZHVjZShkZXNjcmlwdG9yUmVkdWNlciwge30pKTtcbiAgZnVuY3Rpb24gZGVzY3JpcHRvclJlZHVjZXIoYWxsLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gZXJyKSB7XG4gICAgICByZXR1cm4gYWxsO1xuICAgIH1cbiAgICBhbGxbbmFtZV0gPSB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGxvZyhuYW1lKTtcbiAgICAgICAgcmV0dXJuIGVyci5naXRbbmFtZV07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYWxsO1xuICB9XG59XG52YXIgaW5pdF90YXNrX2NhbGxiYWNrID0gX19lc20oe1xuICBcInNyYy9saWIvdGFzay1jYWxsYmFjay50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG4gICAgaW5pdF91dGlscygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jaGFuZ2Utd29ya2luZy1kaXJlY3RvcnkudHNcbmZ1bmN0aW9uIGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKGRpcmVjdG9yeSwgcm9vdCkge1xuICByZXR1cm4gYWRob2NFeGVjVGFzaygoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAoIWZvbGRlckV4aXN0cyhkaXJlY3RvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdpdC5jd2Q6IGNhbm5vdCBjaGFuZ2UgdG8gbm9uLWRpcmVjdG9yeSBcIiR7ZGlyZWN0b3J5fVwiYCk7XG4gICAgfVxuICAgIHJldHVybiAocm9vdCB8fCBpbnN0YW5jZSkuY3dkID0gZGlyZWN0b3J5O1xuICB9KTtcbn1cbnZhciBpbml0X2NoYW5nZV93b3JraW5nX2RpcmVjdG9yeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NoYW5nZS13b3JraW5nLWRpcmVjdG9yeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY2hlY2tvdXQudHNcbmZ1bmN0aW9uIGNoZWNrb3V0VGFzayhhcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiY2hlY2tvdXRcIiwgLi4uYXJnc107XG4gIGlmIChjb21tYW5kc1sxXSA9PT0gXCItYlwiICYmIGNvbW1hbmRzLmluY2x1ZGVzKFwiLUJcIikpIHtcbiAgICBjb21tYW5kc1sxXSA9IHJlbW92ZShjb21tYW5kcywgXCItQlwiKTtcbiAgfVxuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5mdW5jdGlvbiBjaGVja291dF9kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIGNoZWNrb3V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNoZWNrb3V0VGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAxKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH0sXG4gICAgY2hlY2tvdXRCcmFuY2goYnJhbmNoTmFtZSwgc3RhcnRQb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNoZWNrb3V0VGFzayhbXCItYlwiLCBicmFuY2hOYW1lLCBzdGFydFBvaW50LCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGNoZWNrb3V0TG9jYWxCcmFuY2goYnJhbmNoTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNoZWNrb3V0VGFzayhbXCItYlwiLCBicmFuY2hOYW1lLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9jaGVja291dCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NoZWNrb3V0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jb3VudC1vYmplY3RzLnRzXG5mdW5jdGlvbiBjb3VudE9iamVjdHNSZXNwb25zZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb3VudDogMCxcbiAgICBnYXJiYWdlOiAwLFxuICAgIGluUGFjazogMCxcbiAgICBwYWNrczogMCxcbiAgICBwcnVuZVBhY2thYmxlOiAwLFxuICAgIHNpemU6IDAsXG4gICAgc2l6ZUdhcmJhZ2U6IDAsXG4gICAgc2l6ZVBhY2s6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvdW50X29iamVjdHNfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb3VudE9iamVjdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh7XG4gICAgICAgIGNvbW1hbmRzOiBbXCJjb3VudC1vYmplY3RzXCIsIFwiLS12ZXJib3NlXCJdLFxuICAgICAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICAgICAgcGFyc2VyKHN0ZE91dCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKGNvdW50T2JqZWN0c1Jlc3BvbnNlKCksIFtwYXJzZXIyXSwgc3RkT3V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxudmFyIHBhcnNlcjI7XG52YXIgaW5pdF9jb3VudF9vYmplY3RzID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY291bnQtb2JqZWN0cy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBwYXJzZXIyID0gbmV3IExpbmVQYXJzZXIoXG4gICAgICAvKFthLXotXSspOiAoXFxkKykkLyxcbiAgICAgIChyZXN1bHQsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGFzQ2FtZWxDYXNlKGtleSk7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHJlc3VsdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IGFzTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtY29tbWl0LnRzXG5mdW5jdGlvbiBwYXJzZUNvbW1pdFJlc3VsdChzdGRPdXQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGF1dGhvcjogbnVsbCxcbiAgICBicmFuY2g6IFwiXCIsXG4gICAgY29tbWl0OiBcIlwiLFxuICAgIHJvb3Q6IGZhbHNlLFxuICAgIHN1bW1hcnk6IHtcbiAgICAgIGNoYW5nZXM6IDAsXG4gICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgZGVsZXRpb25zOiAwXG4gICAgfVxuICB9O1xuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShyZXN1bHQsIHBhcnNlcnMsIHN0ZE91dCk7XG59XG52YXIgcGFyc2VycztcbnZhciBpbml0X3BhcnNlX2NvbW1pdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtY29tbWl0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIHBhcnNlcnMgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcigvXlxcWyhbXlxcc10rKSggXFwoW14pXStcXCkpPyAoW15cXF1dKykvLCAocmVzdWx0LCBbYnJhbmNoLCByb290LCBjb21taXRdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5icmFuY2ggPSBicmFuY2g7XG4gICAgICAgIHJlc3VsdC5jb21taXQgPSBjb21taXQ7XG4gICAgICAgIHJlc3VsdC5yb290ID0gISFyb290O1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXFxzKkF1dGhvcjpcXHMoLispL2ksIChyZXN1bHQsIFthdXRob3JdKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYXV0aG9yLnNwbGl0KFwiPFwiKTtcbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgaWYgKCFlbWFpbCB8fCAhZW1haWwuaW5jbHVkZXMoXCJAXCIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5hdXRob3IgPSB7XG4gICAgICAgICAgZW1haWw6IGVtYWlsLnN1YnN0cigwLCBlbWFpbC5sZW5ndGggLSAxKSxcbiAgICAgICAgICBuYW1lOiBwYXJ0cy5qb2luKFwiPFwiKS50cmltKClcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC8oXFxkKylbXixdKig/OixcXHMqKFxcZCspW14sXSopKD86LFxccyooXFxkKykpL2csXG4gICAgICAgIChyZXN1bHQsIFtjaGFuZ2VzLCBpbnNlcnRpb25zLCBkZWxldGlvbnNdKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LnN1bW1hcnkuY2hhbmdlcyA9IHBhcnNlSW50KGNoYW5nZXMsIDEwKSB8fCAwO1xuICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSBwYXJzZUludChpbnNlcnRpb25zLCAxMCkgfHwgMDtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBwYXJzZUludChkZWxldGlvbnMsIDEwKSB8fCAwO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eKFxcZCspW14sXSooPzosXFxzKihcXGQrKVteKF0rXFwoKFsrLV0pKT8vLFxuICAgICAgICAocmVzdWx0LCBbY2hhbmdlcywgbGluZXMsIGRpcmVjdGlvbl0pID0+IHtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5jaGFuZ2VzID0gcGFyc2VJbnQoY2hhbmdlcywgMTApIHx8IDA7XG4gICAgICAgICAgY29uc3QgY291bnQgPSBwYXJzZUludChsaW5lcywgMTApIHx8IDA7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmRlbGV0aW9ucyA9IGNvdW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcIitcIikge1xuICAgICAgICAgICAgcmVzdWx0LnN1bW1hcnkuaW5zZXJ0aW9ucyA9IGNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2NvbW1pdC50c1xuZnVuY3Rpb24gY29tbWl0VGFzayhtZXNzYWdlLCBmaWxlcywgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcbiAgICBcIi1jXCIsXG4gICAgXCJjb3JlLmFiYnJldj00MFwiLFxuICAgIFwiY29tbWl0XCIsXG4gICAgLi4ucHJlZml4ZWRBcnJheShtZXNzYWdlLCBcIi1tXCIpLFxuICAgIC4uLmZpbGVzLFxuICAgIC4uLmN1c3RvbUFyZ3NcbiAgXTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHBhcnNlQ29tbWl0UmVzdWx0XG4gIH07XG59XG5mdW5jdGlvbiBjb21taXRfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21taXQobWVzc2FnZSwgLi4ucmVzdCkge1xuICAgICAgY29uc3QgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuICAgICAgY29uc3QgdGFzayA9IHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKG1lc3NhZ2UpIHx8IGNvbW1pdFRhc2soXG4gICAgICAgIGFzQXJyYXkobWVzc2FnZSksXG4gICAgICAgIGFzQXJyYXkoZmlsdGVyVHlwZShyZXN0WzBdLCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LCBbXSkpLFxuICAgICAgICBbXG4gICAgICAgICAgLi4uYXNTdHJpbmdBcnJheShmaWx0ZXJUeXBlKHJlc3RbMV0sIGZpbHRlckFycmF5LCBbXSkpLFxuICAgICAgICAgIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDAsIHRydWUpXG4gICAgICAgIF1cbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBuZXh0KTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gIWZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkobWVzc2FnZSkgJiYgY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgIGBnaXQuY29tbWl0OiByZXF1aXJlcyB0aGUgY29tbWl0IG1lc3NhZ2UgdG8gYmUgc3VwcGxpZWQgYXMgYSBzdHJpbmcvc3RyaW5nW11gXG4gICAgKTtcbiAgfVxufVxudmFyIGluaXRfY29tbWl0ID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY29tbWl0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9wYXJzZV9jb21taXQoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2ZpcnN0LWNvbW1pdC50c1xuZnVuY3Rpb24gZmlyc3RfY29tbWl0X2RlZmF1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgZmlyc3RDb21taXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbXCJyZXYtbGlzdFwiLCBcIi0tbWF4LXBhcmVudHM9MFwiLCBcIkhFQURcIl0sIHRydWUpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9maXJzdF9jb21taXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9maXJzdC1jb21taXQudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2hhc2gtb2JqZWN0LnRzXG5mdW5jdGlvbiBoYXNoT2JqZWN0VGFzayhmaWxlUGF0aCwgd3JpdGUpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJoYXNoLW9iamVjdFwiLCBmaWxlUGF0aF07XG4gIGlmICh3cml0ZSkge1xuICAgIGNvbW1hbmRzLnB1c2goXCItd1wiKTtcbiAgfVxuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcywgdHJ1ZSk7XG59XG52YXIgaW5pdF9oYXNoX29iamVjdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2hhc2gtb2JqZWN0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9Jbml0U3VtbWFyeS50c1xuZnVuY3Rpb24gcGFyc2VJbml0KGJhcmUsIHBhdGgsIHRleHQpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBTdHJpbmcodGV4dCkudHJpbSgpO1xuICBsZXQgcmVzdWx0O1xuICBpZiAocmVzdWx0ID0gaW5pdFJlc3BvbnNlUmVnZXguZXhlYyhyZXNwb25zZSkpIHtcbiAgICByZXR1cm4gbmV3IEluaXRTdW1tYXJ5KGJhcmUsIHBhdGgsIGZhbHNlLCByZXN1bHRbMV0pO1xuICB9XG4gIGlmIChyZXN1bHQgPSByZUluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCB0cnVlLCByZXN1bHRbMV0pO1xuICB9XG4gIGxldCBnaXREaXIgPSBcIlwiO1xuICBjb25zdCB0b2tlbnMgPSByZXNwb25zZS5zcGxpdChcIiBcIik7XG4gIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcbiAgICBpZiAodG9rZW4gPT09IFwiaW5cIikge1xuICAgICAgZ2l0RGlyID0gdG9rZW5zLmpvaW4oXCIgXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgSW5pdFN1bW1hcnkoYmFyZSwgcGF0aCwgL15yZS9pLnRlc3QocmVzcG9uc2UpLCBnaXREaXIpO1xufVxudmFyIEluaXRTdW1tYXJ5LCBpbml0UmVzcG9uc2VSZWdleCwgcmVJbml0UmVzcG9uc2VSZWdleDtcbnZhciBpbml0X0luaXRTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0luaXRTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgSW5pdFN1bW1hcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihiYXJlLCBwYXRoLCBleGlzdGluZywgZ2l0RGlyKSB7XG4gICAgICAgIHRoaXMuYmFyZSA9IGJhcmU7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuZXhpc3RpbmcgPSBleGlzdGluZztcbiAgICAgICAgdGhpcy5naXREaXIgPSBnaXREaXI7XG4gICAgICB9XG4gICAgfTtcbiAgICBpbml0UmVzcG9uc2VSZWdleCA9IC9eSW5pdC4rIHJlcG9zaXRvcnkgaW4gKC4rKSQvO1xuICAgIHJlSW5pdFJlc3BvbnNlUmVnZXggPSAvXlJlaW4uKyBpbiAoLispJC87XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2luaXQudHNcbmZ1bmN0aW9uIGhhc0JhcmVDb21tYW5kKGNvbW1hbmQpIHtcbiAgcmV0dXJuIGNvbW1hbmQuaW5jbHVkZXMoYmFyZUNvbW1hbmQpO1xufVxuZnVuY3Rpb24gaW5pdFRhc2soYmFyZSA9IGZhbHNlLCBwYXRoLCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiaW5pdFwiLCAuLi5jdXN0b21BcmdzXTtcbiAgaWYgKGJhcmUgJiYgIWhhc0JhcmVDb21tYW5kKGNvbW1hbmRzKSkge1xuICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCBiYXJlQ29tbWFuZCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXIodGV4dCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW5pdChjb21tYW5kcy5pbmNsdWRlcyhcIi0tYmFyZVwiKSwgcGF0aCwgdGV4dCk7XG4gICAgfVxuICB9O1xufVxudmFyIGJhcmVDb21tYW5kO1xudmFyIGluaXRfaW5pdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2luaXQudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0luaXRTdW1tYXJ5KCk7XG4gICAgYmFyZUNvbW1hbmQgPSBcIi0tYmFyZVwiO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hcmdzL2xvZy1mb3JtYXQudHNcbmZ1bmN0aW9uIGxvZ0Zvcm1hdEZyb21Db21tYW5kKGN1c3RvbUFyZ3MpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXN0b21BcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gbG9nRm9ybWF0UmVnZXguZXhlYyhjdXN0b21BcmdzW2ldKTtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICByZXR1cm4gYC0tJHtmb3JtYXRbMV19YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiXCIgLyogTk9ORSAqLztcbn1cbmZ1bmN0aW9uIGlzTG9nRm9ybWF0KGN1c3RvbUFyZykge1xuICByZXR1cm4gbG9nRm9ybWF0UmVnZXgudGVzdChjdXN0b21BcmcpO1xufVxudmFyIGxvZ0Zvcm1hdFJlZ2V4O1xudmFyIGluaXRfbG9nX2Zvcm1hdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL2FyZ3MvbG9nLWZvcm1hdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGxvZ0Zvcm1hdFJlZ2V4ID0gL14tLShzdGF0fG51bXN0YXR8bmFtZS1vbmx5fG5hbWUtc3RhdHVzKSg9fCQpLztcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0RpZmZTdW1tYXJ5LnRzXG52YXIgRGlmZlN1bW1hcnk7XG52YXIgaW5pdF9EaWZmU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9EaWZmU3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIERpZmZTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IDA7XG4gICAgICAgIHRoaXMuZGVsZXRpb25zID0gMDtcbiAgICAgICAgdGhpcy5pbnNlcnRpb25zID0gMDtcbiAgICAgICAgdGhpcy5maWxlcyA9IFtdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtZGlmZi1zdW1tYXJ5LnRzXG5mdW5jdGlvbiBnZXREaWZmUGFyc2VyKGZvcm1hdCA9IFwiXCIgLyogTk9ORSAqLykge1xuICBjb25zdCBwYXJzZXI0ID0gZGlmZlN1bW1hcnlQYXJzZXJzW2Zvcm1hdF07XG4gIHJldHVybiAoc3RkT3V0KSA9PiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBEaWZmU3VtbWFyeSgpLCBwYXJzZXI0LCBzdGRPdXQsIGZhbHNlKTtcbn1cbnZhciBzdGF0UGFyc2VyLCBudW1TdGF0UGFyc2VyLCBuYW1lT25seVBhcnNlciwgbmFtZVN0YXR1c1BhcnNlciwgZGlmZlN1bW1hcnlQYXJzZXJzO1xudmFyIGluaXRfcGFyc2VfZGlmZl9zdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1kaWZmLXN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2xvZ19mb3JtYXQoKTtcbiAgICBpbml0X0RpZmZTdW1tYXJ5KCk7XG4gICAgaW5pdF9kaWZmX25hbWVfc3RhdHVzKCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIHN0YXRQYXJzZXIgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL14oLispXFxzK1xcfFxccysoXFxkKykoXFxzK1srXFwtXSspPyQvLFxuICAgICAgICAocmVzdWx0LCBbZmlsZSwgY2hhbmdlcywgYWx0ZXJhdGlvbnMgPSBcIlwiXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUudHJpbSgpLFxuICAgICAgICAgICAgY2hhbmdlczogYXNOdW1iZXIoY2hhbmdlcyksXG4gICAgICAgICAgICBpbnNlcnRpb25zOiBhbHRlcmF0aW9ucy5yZXBsYWNlKC9bXitdL2csIFwiXCIpLmxlbmd0aCxcbiAgICAgICAgICAgIGRlbGV0aW9uczogYWx0ZXJhdGlvbnMucmVwbGFjZSgvW14tXS9nLCBcIlwiKS5sZW5ndGgsXG4gICAgICAgICAgICBiaW5hcnk6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL14oLispIFxcfFxccytCaW4gKFswLTkuXSspIC0+IChbMC05Ll0rKSAoW2Etel0rKS8sXG4gICAgICAgIChyZXN1bHQsIFtmaWxlLCBiZWZvcmUsIGFmdGVyXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUudHJpbSgpLFxuICAgICAgICAgICAgYmVmb3JlOiBhc051bWJlcihiZWZvcmUpLFxuICAgICAgICAgICAgYWZ0ZXI6IGFzTnVtYmVyKGFmdGVyKSxcbiAgICAgICAgICAgIGJpbmFyeTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC8oXFxkKykgZmlsZXM/IGNoYW5nZWRcXHMqKCg/OiwgXFxkKyBbXixdKyl7MCwyfSkvLFxuICAgICAgICAocmVzdWx0LCBbY2hhbmdlZCwgc3VtbWFyeV0pID0+IHtcbiAgICAgICAgICBjb25zdCBpbnNlcnRlZCA9IC8oXFxkKykgaS8uZXhlYyhzdW1tYXJ5KTtcbiAgICAgICAgICBjb25zdCBkZWxldGVkID0gLyhcXGQrKSBkLy5leGVjKHN1bW1hcnkpO1xuICAgICAgICAgIHJlc3VsdC5jaGFuZ2VkID0gYXNOdW1iZXIoY2hhbmdlZCk7XG4gICAgICAgICAgcmVzdWx0Lmluc2VydGlvbnMgPSBhc051bWJlcihpbnNlcnRlZD8uWzFdKTtcbiAgICAgICAgICByZXN1bHQuZGVsZXRpb25zID0gYXNOdW1iZXIoZGVsZXRlZD8uWzFdKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gICAgbnVtU3RhdFBhcnNlciA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvKFxcZCspXFx0KFxcZCspXFx0KC4rKSQvLFxuICAgICAgICAocmVzdWx0LCBbY2hhbmdlc0luc2VydCwgY2hhbmdlc0RlbGV0ZSwgZmlsZV0pID0+IHtcbiAgICAgICAgICBjb25zdCBpbnNlcnRpb25zID0gYXNOdW1iZXIoY2hhbmdlc0luc2VydCk7XG4gICAgICAgICAgY29uc3QgZGVsZXRpb25zID0gYXNOdW1iZXIoY2hhbmdlc0RlbGV0ZSk7XG4gICAgICAgICAgcmVzdWx0LmNoYW5nZWQrKztcbiAgICAgICAgICByZXN1bHQuaW5zZXJ0aW9ucyArPSBpbnNlcnRpb25zO1xuICAgICAgICAgIHJlc3VsdC5kZWxldGlvbnMgKz0gZGVsZXRpb25zO1xuICAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBjaGFuZ2VzOiBpbnNlcnRpb25zICsgZGVsZXRpb25zLFxuICAgICAgICAgICAgaW5zZXJ0aW9ucyxcbiAgICAgICAgICAgIGRlbGV0aW9ucyxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC8tXFx0LVxcdCguKykkLywgKHJlc3VsdCwgW2ZpbGVdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICBmaWxlLFxuICAgICAgICAgIGFmdGVyOiAwLFxuICAgICAgICAgIGJlZm9yZTogMCxcbiAgICAgICAgICBiaW5hcnk6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgIF07XG4gICAgbmFtZU9ubHlQYXJzZXIgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcigvKC4rKSQvLCAocmVzdWx0LCBbZmlsZV0pID0+IHtcbiAgICAgICAgcmVzdWx0LmNoYW5nZWQrKztcbiAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgICAgICBiaW5hcnk6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICBdO1xuICAgIG5hbWVTdGF0dXNQYXJzZXIgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgLyhbQUNETVJUVVhCXSkoWzAtOV17MCwzfSlcXHQoLlteXFx0XSopKFxcdCguW15cXHRdKikpPyQvLFxuICAgICAgICAocmVzdWx0LCBbc3RhdHVzLCBzaW1pbGFyaXR5LCBmcm9tLCBfdG8sIHRvXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgICAgZmlsZTogdG8gPz8gZnJvbSxcbiAgICAgICAgICAgIGNoYW5nZXM6IDAsXG4gICAgICAgICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgICAgICAgZGVsZXRpb25zOiAwLFxuICAgICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXR1czogb3JWb2lkKGlzRGlmZk5hbWVTdGF0dXMoc3RhdHVzKSAmJiBzdGF0dXMpLFxuICAgICAgICAgICAgZnJvbTogb3JWb2lkKCEhdG8gJiYgZnJvbSAhPT0gdG8gJiYgZnJvbSksXG4gICAgICAgICAgICBzaW1pbGFyaXR5OiBhc051bWJlcihzaW1pbGFyaXR5KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgICBkaWZmU3VtbWFyeVBhcnNlcnMgPSB7XG4gICAgICBbXCJcIiAvKiBOT05FICovXTogc3RhdFBhcnNlcixcbiAgICAgIFtcIi0tc3RhdFwiIC8qIFNUQVQgKi9dOiBzdGF0UGFyc2VyLFxuICAgICAgW1wiLS1udW1zdGF0XCIgLyogTlVNX1NUQVQgKi9dOiBudW1TdGF0UGFyc2VyLFxuICAgICAgW1wiLS1uYW1lLXN0YXR1c1wiIC8qIE5BTUVfU1RBVFVTICovXTogbmFtZVN0YXR1c1BhcnNlcixcbiAgICAgIFtcIi0tbmFtZS1vbmx5XCIgLyogTkFNRV9PTkxZICovXTogbmFtZU9ubHlQYXJzZXJcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWxpc3QtbG9nLXN1bW1hcnkudHNcbmZ1bmN0aW9uIGxpbmVCdWlsZGVyKHRva2VucywgZmllbGRzKSB7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKFxuICAgIChsaW5lLCBmaWVsZCwgaW5kZXgpID0+IHtcbiAgICAgIGxpbmVbZmllbGRdID0gdG9rZW5zW2luZGV4XSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZSh7IGRpZmY6IG51bGwgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyKHNwbGl0dGVyID0gU1BMSVRURVIsIGZpZWxkcyA9IGRlZmF1bHRGaWVsZE5hbWVzLCBsb2dGb3JtYXQgPSBcIlwiIC8qIE5PTkUgKi8pIHtcbiAgY29uc3QgcGFyc2VEaWZmUmVzdWx0ID0gZ2V0RGlmZlBhcnNlcihsb2dGb3JtYXQpO1xuICByZXR1cm4gZnVuY3Rpb24oc3RkT3V0KSB7XG4gICAgY29uc3QgYWxsID0gdG9MaW5lc1dpdGhDb250ZW50KFxuICAgICAgc3RkT3V0LnRyaW0oKSxcbiAgICAgIGZhbHNlLFxuICAgICAgU1RBUlRfQk9VTkRBUllcbiAgICApLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBjb25zdCBsaW5lRGV0YWlsID0gaXRlbS5zcGxpdChDT01NSVRfQk9VTkRBUlkpO1xuICAgICAgY29uc3QgbGlzdExvZ0xpbmUgPSBsaW5lQnVpbGRlcihsaW5lRGV0YWlsWzBdLnNwbGl0KHNwbGl0dGVyKSwgZmllbGRzKTtcbiAgICAgIGlmIChsaW5lRGV0YWlsLmxlbmd0aCA+IDEgJiYgISFsaW5lRGV0YWlsWzFdLnRyaW0oKSkge1xuICAgICAgICBsaXN0TG9nTGluZS5kaWZmID0gcGFyc2VEaWZmUmVzdWx0KGxpbmVEZXRhaWxbMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RMb2dMaW5lO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBhbGwsXG4gICAgICBsYXRlc3Q6IGFsbC5sZW5ndGggJiYgYWxsWzBdIHx8IG51bGwsXG4gICAgICB0b3RhbDogYWxsLmxlbmd0aFxuICAgIH07XG4gIH07XG59XG52YXIgU1RBUlRfQk9VTkRBUlksIENPTU1JVF9CT1VOREFSWSwgU1BMSVRURVIsIGRlZmF1bHRGaWVsZE5hbWVzO1xudmFyIGluaXRfcGFyc2VfbGlzdF9sb2dfc3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3BhcnNlX2RpZmZfc3VtbWFyeSgpO1xuICAgIGluaXRfbG9nX2Zvcm1hdCgpO1xuICAgIFNUQVJUX0JPVU5EQVJZID0gXCJcXHhGMlxceEYyXFx4RjJcXHhGMlxceEYyXFx4RjIgXCI7XG4gICAgQ09NTUlUX0JPVU5EQVJZID0gXCIgXFx4RjJcXHhGMlwiO1xuICAgIFNQTElUVEVSID0gXCIgXFx4RjIgXCI7XG4gICAgZGVmYXVsdEZpZWxkTmFtZXMgPSBbXCJoYXNoXCIsIFwiZGF0ZVwiLCBcIm1lc3NhZ2VcIiwgXCJyZWZzXCIsIFwiYXV0aG9yX25hbWVcIiwgXCJhdXRob3JfZW1haWxcIl07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2RpZmYudHNcbnZhciBkaWZmX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGRpZmZfZXhwb3J0cywge1xuICBkaWZmU3VtbWFyeVRhc2s6ICgpID0+IGRpZmZTdW1tYXJ5VGFzayxcbiAgdmFsaWRhdGVMb2dGb3JtYXRDb25maWc6ICgpID0+IHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnXG59KTtcbmZ1bmN0aW9uIGRpZmZTdW1tYXJ5VGFzayhjdXN0b21BcmdzKSB7XG4gIGxldCBsb2dGb3JtYXQgPSBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKTtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJkaWZmXCJdO1xuICBpZiAobG9nRm9ybWF0ID09PSBcIlwiIC8qIE5PTkUgKi8pIHtcbiAgICBsb2dGb3JtYXQgPSBcIi0tc3RhdFwiIC8qIFNUQVQgKi87XG4gICAgY29tbWFuZHMucHVzaChcIi0tc3RhdD00MDk2XCIpO1xuICB9XG4gIGNvbW1hbmRzLnB1c2goLi4uY3VzdG9tQXJncyk7XG4gIHJldHVybiB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhjb21tYW5kcykgfHwge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogZ2V0RGlmZlBhcnNlcihsb2dGb3JtYXQpXG4gIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGZsYWdzID0gY3VzdG9tQXJncy5maWx0ZXIoaXNMb2dGb3JtYXQpO1xuICBpZiAoZmxhZ3MubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgYFN1bW1hcnkgZmxhZ3MgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSAtIHBpY2sgb25lIG9mICR7ZmxhZ3Muam9pbihcIixcIil9YFxuICAgICk7XG4gIH1cbiAgaWYgKGZsYWdzLmxlbmd0aCAmJiBjdXN0b21BcmdzLmluY2x1ZGVzKFwiLXpcIikpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgIGBTdW1tYXJ5IGZsYWcgJHtmbGFnc30gcGFyc2luZyBpcyBub3QgY29tcGF0aWJsZSB3aXRoIG51bGwgdGVybWluYXRpb24gb3B0aW9uICcteidgXG4gICAgKTtcbiAgfVxufVxudmFyIGluaXRfZGlmZiA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2RpZmYudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2xvZ19mb3JtYXQoKTtcbiAgICBpbml0X3BhcnNlX2RpZmZfc3VtbWFyeSgpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9sb2cudHNcbmZ1bmN0aW9uIHByZXR0eUZvcm1hdChmb3JtYXQsIHNwbGl0dGVyKSB7XG4gIGNvbnN0IGZpZWxkcyA9IFtdO1xuICBjb25zdCBmb3JtYXRTdHIgPSBbXTtcbiAgT2JqZWN0LmtleXMoZm9ybWF0KS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICBmb3JtYXRTdHIucHVzaChTdHJpbmcoZm9ybWF0W2ZpZWxkXSkpO1xuICB9KTtcbiAgcmV0dXJuIFtmaWVsZHMsIGZvcm1hdFN0ci5qb2luKHNwbGl0dGVyKV07XG59XG5mdW5jdGlvbiB1c2VyT3B0aW9ucyhpbnB1dCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaW5wdXQpLnJlZHVjZSgob3V0LCBrZXkpID0+IHtcbiAgICBpZiAoIShrZXkgaW4gZXhjbHVkZU9wdGlvbnMpKSB7XG4gICAgICBvdXRba2V5XSA9IGlucHV0W2tleV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlTG9nT3B0aW9ucyhvcHQgPSB7fSwgY3VzdG9tQXJncyA9IFtdKSB7XG4gIGNvbnN0IHNwbGl0dGVyID0gZmlsdGVyVHlwZShvcHQuc3BsaXR0ZXIsIGZpbHRlclN0cmluZywgU1BMSVRURVIpO1xuICBjb25zdCBmb3JtYXQgPSBmaWx0ZXJQbGFpbk9iamVjdChvcHQuZm9ybWF0KSA/IG9wdC5mb3JtYXQgOiB7XG4gICAgaGFzaDogXCIlSFwiLFxuICAgIGRhdGU6IG9wdC5zdHJpY3REYXRlID09PSBmYWxzZSA/IFwiJWFpXCIgOiBcIiVhSVwiLFxuICAgIG1lc3NhZ2U6IFwiJXNcIixcbiAgICByZWZzOiBcIiVEXCIsXG4gICAgYm9keTogb3B0Lm11bHRpTGluZSA/IFwiJUJcIiA6IFwiJWJcIixcbiAgICBhdXRob3JfbmFtZTogb3B0Lm1haWxNYXAgIT09IGZhbHNlID8gXCIlYU5cIiA6IFwiJWFuXCIsXG4gICAgYXV0aG9yX2VtYWlsOiBvcHQubWFpbE1hcCAhPT0gZmFsc2UgPyBcIiVhRVwiIDogXCIlYWVcIlxuICB9O1xuICBjb25zdCBbZmllbGRzLCBmb3JtYXRTdHJdID0gcHJldHR5Rm9ybWF0KGZvcm1hdCwgc3BsaXR0ZXIpO1xuICBjb25zdCBzdWZmaXggPSBbXTtcbiAgY29uc3QgY29tbWFuZCA9IFtcbiAgICBgLS1wcmV0dHk9Zm9ybWF0OiR7U1RBUlRfQk9VTkRBUll9JHtmb3JtYXRTdHJ9JHtDT01NSVRfQk9VTkRBUll9YCxcbiAgICAuLi5jdXN0b21BcmdzXG4gIF07XG4gIGNvbnN0IG1heENvdW50ID0gb3B0Lm4gfHwgb3B0W1wibWF4LWNvdW50XCJdIHx8IG9wdC5tYXhDb3VudDtcbiAgaWYgKG1heENvdW50KSB7XG4gICAgY29tbWFuZC5wdXNoKGAtLW1heC1jb3VudD0ke21heENvdW50fWApO1xuICB9XG4gIGlmIChvcHQuZnJvbSB8fCBvcHQudG8pIHtcbiAgICBjb25zdCByYW5nZU9wZXJhdG9yID0gb3B0LnN5bW1ldHJpYyAhPT0gZmFsc2UgPyBcIi4uLlwiIDogXCIuLlwiO1xuICAgIHN1ZmZpeC5wdXNoKGAke29wdC5mcm9tIHx8IFwiXCJ9JHtyYW5nZU9wZXJhdG9yfSR7b3B0LnRvIHx8IFwiXCJ9YCk7XG4gIH1cbiAgaWYgKGZpbHRlclN0cmluZyhvcHQuZmlsZSkpIHtcbiAgICBjb21tYW5kLnB1c2goXCItLWZvbGxvd1wiLCBwYXRoc3BlYyhvcHQuZmlsZSkpO1xuICB9XG4gIGFwcGVuZFRhc2tPcHRpb25zKHVzZXJPcHRpb25zKG9wdCksIGNvbW1hbmQpO1xuICByZXR1cm4ge1xuICAgIGZpZWxkcyxcbiAgICBzcGxpdHRlcixcbiAgICBjb21tYW5kczogWy4uLmNvbW1hbmQsIC4uLnN1ZmZpeF1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ1Rhc2soc3BsaXR0ZXIsIGZpZWxkcywgY3VzdG9tQXJncykge1xuICBjb25zdCBwYXJzZXI0ID0gY3JlYXRlTGlzdExvZ1N1bW1hcnlQYXJzZXIoc3BsaXR0ZXIsIGZpZWxkcywgbG9nRm9ybWF0RnJvbUNvbW1hbmQoY3VzdG9tQXJncykpO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzOiBbXCJsb2dcIiwgLi4uY3VzdG9tQXJnc10sXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiBwYXJzZXI0XG4gIH07XG59XG5mdW5jdGlvbiBsb2dfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2coLi4ucmVzdCkge1xuICAgICAgY29uc3QgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHBhcnNlTG9nT3B0aW9ucyhcbiAgICAgICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJndW1lbnRzKSxcbiAgICAgICAgYXNTdHJpbmdBcnJheShmaWx0ZXJUeXBlKGFyZ3VtZW50c1swXSwgZmlsdGVyQXJyYXksIFtdKSlcbiAgICAgICk7XG4gICAgICBjb25zdCB0YXNrID0gcmVqZWN0RGVwcmVjYXRlZFNpZ25hdHVyZXMoLi4ucmVzdCkgfHwgdmFsaWRhdGVMb2dGb3JtYXRDb25maWcob3B0aW9ucy5jb21tYW5kcykgfHwgY3JlYXRlTG9nVGFzayhvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIG5leHQpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gY3JlYXRlTG9nVGFzayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxvZ1Rhc2sob3B0aW9ucy5zcGxpdHRlciwgb3B0aW9ucy5maWVsZHMsIG9wdGlvbnMuY29tbWFuZHMpO1xuICB9XG4gIGZ1bmN0aW9uIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGZpbHRlclN0cmluZyhmcm9tKSAmJiBmaWx0ZXJTdHJpbmcodG8pICYmIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICBgZ2l0LmxvZyhzdHJpbmcsIHN0cmluZykgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggZ2l0LmxvZyh7IGZyb206IHN0cmluZywgdG86IHN0cmluZyB9KWBcbiAgICApO1xuICB9XG59XG52YXIgZXhjbHVkZU9wdGlvbnM7XG52YXIgaW5pdF9sb2cgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9sb2cudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2xvZ19mb3JtYXQoKTtcbiAgICBpbml0X3BhdGhzcGVjKCk7XG4gICAgaW5pdF9wYXJzZV9saXN0X2xvZ19zdW1tYXJ5KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICAgIGluaXRfZGlmZigpO1xuICAgIGV4Y2x1ZGVPcHRpb25zID0gLyogQF9fUFVSRV9fICovICgoZXhjbHVkZU9wdGlvbnMyKSA9PiB7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wiLS1wcmV0dHlcIl0gPSAwXSA9IFwiLS1wcmV0dHlcIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJtYXgtY291bnRcIl0gPSAxXSA9IFwibWF4LWNvdW50XCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wibWF4Q291bnRcIl0gPSAyXSA9IFwibWF4Q291bnRcIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJuXCJdID0gM10gPSBcIm5cIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJmaWxlXCJdID0gNF0gPSBcImZpbGVcIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJmb3JtYXRcIl0gPSA1XSA9IFwiZm9ybWF0XCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wiZnJvbVwiXSA9IDZdID0gXCJmcm9tXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1widG9cIl0gPSA3XSA9IFwidG9cIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJzcGxpdHRlclwiXSA9IDhdID0gXCJzcGxpdHRlclwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcInN5bW1ldHJpY1wiXSA9IDldID0gXCJzeW1tZXRyaWNcIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJtYWlsTWFwXCJdID0gMTBdID0gXCJtYWlsTWFwXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wibXVsdGlMaW5lXCJdID0gMTFdID0gXCJtdWx0aUxpbmVcIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJzdHJpY3REYXRlXCJdID0gMTJdID0gXCJzdHJpY3REYXRlXCI7XG4gICAgICByZXR1cm4gZXhjbHVkZU9wdGlvbnMyO1xuICAgIH0pKGV4Y2x1ZGVPcHRpb25zIHx8IHt9KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL01lcmdlU3VtbWFyeS50c1xudmFyIE1lcmdlU3VtbWFyeUNvbmZsaWN0LCBNZXJnZVN1bW1hcnlEZXRhaWw7XG52YXIgaW5pdF9NZXJnZVN1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvTWVyZ2VTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgTWVyZ2VTdW1tYXJ5Q29uZmxpY3QgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihyZWFzb24sIGZpbGUgPSBudWxsLCBtZXRhKSB7XG4gICAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgICAgfVxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmZpbGV9OiR7dGhpcy5yZWFzb259YDtcbiAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlU3VtbWFyeURldGFpbCA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbmZsaWN0cyA9IFtdO1xuICAgICAgICB0aGlzLm1lcmdlcyA9IFtdO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IFwic3VjY2Vzc1wiO1xuICAgICAgfVxuICAgICAgZ2V0IGZhaWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmxpY3RzLmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgICBnZXQgcmVhc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgICB9XG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmxpY3RzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBgQ09ORkxJQ1RTOiAke3RoaXMuY29uZmxpY3RzLmpvaW4oXCIsIFwiKX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIk9LXCI7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL1B1bGxTdW1tYXJ5LnRzXG52YXIgUHVsbFN1bW1hcnksIFB1bGxGYWlsZWRTdW1tYXJ5O1xudmFyIGluaXRfUHVsbFN1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvUHVsbFN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBQdWxsU3VtbWFyeSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlbW90ZU1lc3NhZ2VzID0ge1xuICAgICAgICAgIGFsbDogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVkID0gW107XG4gICAgICAgIHRoaXMuZGVsZXRlZCA9IFtdO1xuICAgICAgICB0aGlzLmZpbGVzID0gW107XG4gICAgICAgIHRoaXMuZGVsZXRpb25zID0ge307XG4gICAgICAgIHRoaXMuaW5zZXJ0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnN1bW1hcnkgPSB7XG4gICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgICBkZWxldGlvbnM6IDAsXG4gICAgICAgICAgaW5zZXJ0aW9uczogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgUHVsbEZhaWxlZFN1bW1hcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZW1vdGUgPSBcIlwiO1xuICAgICAgICB0aGlzLmhhc2ggPSB7XG4gICAgICAgICAgbG9jYWw6IFwiXCIsXG4gICAgICAgICAgcmVtb3RlOiBcIlwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYnJhbmNoID0ge1xuICAgICAgICAgIGxvY2FsOiBcIlwiLFxuICAgICAgICAgIHJlbW90ZTogXCJcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlwiO1xuICAgICAgfVxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1yZW1vdGUtb2JqZWN0cy50c1xuZnVuY3Rpb24gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQocmVtb3RlTWVzc2FnZXMpIHtcbiAgcmV0dXJuIHJlbW90ZU1lc3NhZ2VzLm9iamVjdHMgPSByZW1vdGVNZXNzYWdlcy5vYmplY3RzIHx8IHtcbiAgICBjb21wcmVzc2luZzogMCxcbiAgICBjb3VudGluZzogMCxcbiAgICBlbnVtZXJhdGluZzogMCxcbiAgICBwYWNrUmV1c2VkOiAwLFxuICAgIHJldXNlZDogeyBjb3VudDogMCwgZGVsdGE6IDAgfSxcbiAgICB0b3RhbDogeyBjb3VudDogMCwgZGVsdGE6IDAgfVxuICB9O1xufVxuZnVuY3Rpb24gYXNPYmplY3RDb3VudChzb3VyY2UpIHtcbiAgY29uc3QgY291bnQgPSAvXlxccyooXFxkKykvLmV4ZWMoc291cmNlKTtcbiAgY29uc3QgZGVsdGEgPSAvZGVsdGEgKFxcZCspL2kuZXhlYyhzb3VyY2UpO1xuICByZXR1cm4ge1xuICAgIGNvdW50OiBhc051bWJlcihjb3VudCAmJiBjb3VudFsxXSB8fCBcIjBcIiksXG4gICAgZGVsdGE6IGFzTnVtYmVyKGRlbHRhICYmIGRlbHRhWzFdIHx8IFwiMFwiKVxuICB9O1xufVxudmFyIHJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VycztcbnZhciBpbml0X3BhcnNlX3JlbW90ZV9vYmplY3RzID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1yZW1vdGUtb2JqZWN0cy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICByZW1vdGVNZXNzYWdlc09iamVjdFBhcnNlcnMgPSBbXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgL15yZW1vdGU6XFxzKihlbnVtZXJhdGluZ3xjb3VudGluZ3xjb21wcmVzc2luZykgb2JqZWN0czogKFxcZCspLC9pLFxuICAgICAgICAocmVzdWx0LCBbYWN0aW9uLCBjb3VudF0pID0+IHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBhY3Rpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBjb25zdCBlbnVtZXJhdGlvbiA9IG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlc3VsdC5yZW1vdGVNZXNzYWdlcyk7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihlbnVtZXJhdGlvbiwgeyBba2V5XTogYXNOdW1iZXIoY291bnQpIH0pO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IFxcZCslIFxcKFxcZCtcXC8oXFxkKylcXCksL2ksXG4gICAgICAgIChyZXN1bHQsIFthY3Rpb24sIGNvdW50XSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGFjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGNvbnN0IGVudW1lcmF0aW9uID0gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQocmVzdWx0LnJlbW90ZU1lc3NhZ2VzKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGVudW1lcmF0aW9uLCB7IFtrZXldOiBhc051bWJlcihjb3VudCkgfSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgL3RvdGFsIChbXixdKyksIHJldXNlZCAoW14sXSspLCBwYWNrLXJldXNlZCAoXFxkKykvaSxcbiAgICAgICAgKHJlc3VsdCwgW3RvdGFsLCByZXVzZWQsIHBhY2tSZXVzZWRdKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0cyA9IG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlc3VsdC5yZW1vdGVNZXNzYWdlcyk7XG4gICAgICAgICAgb2JqZWN0cy50b3RhbCA9IGFzT2JqZWN0Q291bnQodG90YWwpO1xuICAgICAgICAgIG9iamVjdHMucmV1c2VkID0gYXNPYmplY3RDb3VudChyZXVzZWQpO1xuICAgICAgICAgIG9iamVjdHMucGFja1JldXNlZCA9IGFzTnVtYmVyKHBhY2tSZXVzZWQpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1yZW1vdGUtbWVzc2FnZXMudHNcbmZ1bmN0aW9uIHBhcnNlUmVtb3RlTWVzc2FnZXMoX3N0ZE91dCwgc3RkRXJyKSB7XG4gIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHsgcmVtb3RlTWVzc2FnZXM6IG5ldyBSZW1vdGVNZXNzYWdlU3VtbWFyeSgpIH0sIHBhcnNlcnMyLCBzdGRFcnIpO1xufVxudmFyIHBhcnNlcnMyLCBSZW1vdGVNZXNzYWdlU3VtbWFyeTtcbnZhciBpbml0X3BhcnNlX3JlbW90ZV9tZXNzYWdlcyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW1lc3NhZ2VzLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfcGFyc2VfcmVtb3RlX29iamVjdHMoKTtcbiAgICBwYXJzZXJzMiA9IFtcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKC9ecmVtb3RlOlxccyooLispJC8sIChyZXN1bHQsIFt0ZXh0XSkgPT4ge1xuICAgICAgICByZXN1bHQucmVtb3RlTWVzc2FnZXMuYWxsLnB1c2godGV4dC50cmltKCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSxcbiAgICAgIC4uLnJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VycyxcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKFxuICAgICAgICBbL2NyZWF0ZSBhICg/OnB1bGx8bWVyZ2UpIHJlcXVlc3QvaSwgL1xccyhodHRwcz86XFwvXFwvXFxTKykkL10sXG4gICAgICAgIChyZXN1bHQsIFtwdWxsUmVxdWVzdFVybF0pID0+IHtcbiAgICAgICAgICByZXN1bHQucmVtb3RlTWVzc2FnZXMucHVsbFJlcXVlc3RVcmwgPSBwdWxsUmVxdWVzdFVybDtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKFxuICAgICAgICBbL2ZvdW5kIChcXGQrKSB2dWxuZXJhYmlsaXRpZXMuK1xcKChbXildKylcXCkvaSwgL1xccyhodHRwcz86XFwvXFwvXFxTKykkL10sXG4gICAgICAgIChyZXN1bHQsIFtjb3VudCwgc3VtbWFyeSwgdXJsXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5yZW1vdGVNZXNzYWdlcy52dWxuZXJhYmlsaXRpZXMgPSB7XG4gICAgICAgICAgICBjb3VudDogYXNOdW1iZXIoY291bnQpLFxuICAgICAgICAgICAgc3VtbWFyeSxcbiAgICAgICAgICAgIHVybFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICAgIFJlbW90ZU1lc3NhZ2VTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWxsID0gW107XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1wdWxsLnRzXG5mdW5jdGlvbiBwYXJzZVB1bGxFcnJvclJlc3VsdChzdGRPdXQsIHN0ZEVycikge1xuICBjb25zdCBwdWxsRXJyb3IgPSBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBQdWxsRmFpbGVkU3VtbWFyeSgpLCBlcnJvclBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xuICByZXR1cm4gcHVsbEVycm9yLm1lc3NhZ2UgJiYgcHVsbEVycm9yO1xufVxudmFyIEZJTEVfVVBEQVRFX1JFR0VYLCBTVU1NQVJZX1JFR0VYLCBBQ1RJT05fUkVHRVgsIHBhcnNlcnMzLCBlcnJvclBhcnNlcnMsIHBhcnNlUHVsbERldGFpbCwgcGFyc2VQdWxsUmVzdWx0O1xudmFyIGluaXRfcGFyc2VfcHVsbCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtcHVsbC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfUHVsbFN1bW1hcnkoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9wYXJzZV9yZW1vdGVfbWVzc2FnZXMoKTtcbiAgICBGSUxFX1VQREFURV9SRUdFWCA9IC9eXFxzKiguKz8pXFxzK1xcfFxccytcXGQrXFxzKihcXCsqKSgtKikvO1xuICAgIFNVTU1BUllfUkVHRVggPSAvKFxcZCspXFxEKygoXFxkKylcXEQrXFwoXFwrXFwpKT8oXFxEKyhcXGQrKVxcRCtcXCgtXFwpKT8vO1xuICAgIEFDVElPTl9SRUdFWCA9IC9eKGNyZWF0ZXxkZWxldGUpIG1vZGUgXFxkKyAoLispLztcbiAgICBwYXJzZXJzMyA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKEZJTEVfVVBEQVRFX1JFR0VYLCAocmVzdWx0LCBbZmlsZSwgaW5zZXJ0aW9ucywgZGVsZXRpb25zXSkgPT4ge1xuICAgICAgICByZXN1bHQuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgaWYgKGluc2VydGlvbnMpIHtcbiAgICAgICAgICByZXN1bHQuaW5zZXJ0aW9uc1tmaWxlXSA9IGluc2VydGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxldGlvbnMpIHtcbiAgICAgICAgICByZXN1bHQuZGVsZXRpb25zW2ZpbGVdID0gZGVsZXRpb25zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcihTVU1NQVJZX1JFR0VYLCAocmVzdWx0LCBbY2hhbmdlcywgLCBpbnNlcnRpb25zLCAsIGRlbGV0aW9uc10pID0+IHtcbiAgICAgICAgaWYgKGluc2VydGlvbnMgIT09IHZvaWQgMCB8fCBkZWxldGlvbnMgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmNoYW5nZXMgPSArY2hhbmdlcyB8fCAwO1xuICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSAraW5zZXJ0aW9ucyB8fCAwO1xuICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmRlbGV0aW9ucyA9ICtkZWxldGlvbnMgfHwgMDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKEFDVElPTl9SRUdFWCwgKHJlc3VsdCwgW2FjdGlvbiwgZmlsZV0pID0+IHtcbiAgICAgICAgYXBwZW5kKHJlc3VsdC5maWxlcywgZmlsZSk7XG4gICAgICAgIGFwcGVuZChhY3Rpb24gPT09IFwiY3JlYXRlXCIgPyByZXN1bHQuY3JlYXRlZCA6IHJlc3VsdC5kZWxldGVkLCBmaWxlKTtcbiAgICAgIH0pXG4gICAgXTtcbiAgICBlcnJvclBhcnNlcnMgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcigvXmZyb21cXHMoLispJC9pLCAocmVzdWx0LCBbcmVtb3RlXSkgPT4gdm9pZCAocmVzdWx0LnJlbW90ZSA9IHJlbW90ZSkpLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL15mYXRhbDpcXHMoLispJC8sIChyZXN1bHQsIFttZXNzYWdlXSkgPT4gdm9pZCAocmVzdWx0Lm1lc3NhZ2UgPSBtZXNzYWdlKSksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgLyhbYS16MC05XSspXFwuXFwuKFthLXowLTldKylcXHMrKFxcUyspXFxzKy0+XFxzKyhcXFMrKSQvLFxuICAgICAgICAocmVzdWx0LCBbaGFzaExvY2FsLCBoYXNoUmVtb3RlLCBicmFuY2hMb2NhbCwgYnJhbmNoUmVtb3RlXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5icmFuY2gubG9jYWwgPSBicmFuY2hMb2NhbDtcbiAgICAgICAgICByZXN1bHQuaGFzaC5sb2NhbCA9IGhhc2hMb2NhbDtcbiAgICAgICAgICByZXN1bHQuYnJhbmNoLnJlbW90ZSA9IGJyYW5jaFJlbW90ZTtcbiAgICAgICAgICByZXN1bHQuaGFzaC5yZW1vdGUgPSBoYXNoUmVtb3RlO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgICBwYXJzZVB1bGxEZXRhaWwgPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBQdWxsU3VtbWFyeSgpLCBwYXJzZXJzMywgW3N0ZE91dCwgc3RkRXJyXSk7XG4gICAgfTtcbiAgICBwYXJzZVB1bGxSZXN1bHQgPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICBuZXcgUHVsbFN1bW1hcnkoKSxcbiAgICAgICAgcGFyc2VQdWxsRGV0YWlsKHN0ZE91dCwgc3RkRXJyKSxcbiAgICAgICAgcGFyc2VSZW1vdGVNZXNzYWdlcyhzdGRPdXQsIHN0ZEVycilcbiAgICAgICk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1tZXJnZS50c1xudmFyIHBhcnNlcnM0LCBwYXJzZU1lcmdlUmVzdWx0LCBwYXJzZU1lcmdlRGV0YWlsO1xudmFyIGluaXRfcGFyc2VfbWVyZ2UgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLW1lcmdlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9NZXJnZVN1bW1hcnkoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9wYXJzZV9wdWxsKCk7XG4gICAgcGFyc2VyczQgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcigvXkF1dG8tbWVyZ2luZ1xccysoLispJC8sIChzdW1tYXJ5LCBbYXV0b01lcmdlXSkgPT4ge1xuICAgICAgICBzdW1tYXJ5Lm1lcmdlcy5wdXNoKGF1dG9NZXJnZSk7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eQ09ORkxJQ1RcXHMrXFwoKC4rKVxcKTogTWVyZ2UgY29uZmxpY3QgaW4gKC4rKSQvLCAoc3VtbWFyeSwgW3JlYXNvbiwgZmlsZV0pID0+IHtcbiAgICAgICAgc3VtbWFyeS5jb25mbGljdHMucHVzaChuZXcgTWVyZ2VTdW1tYXJ5Q29uZmxpY3QocmVhc29uLCBmaWxlKSk7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvXkNPTkZMSUNUXFxzK1xcKCguK1xcL2RlbGV0ZSlcXCk6ICguKykgZGVsZXRlZCBpbiAoLispIGFuZC8sXG4gICAgICAgIChzdW1tYXJ5LCBbcmVhc29uLCBmaWxlLCBkZWxldGVSZWZdKSA9PiB7XG4gICAgICAgICAgc3VtbWFyeS5jb25mbGljdHMucHVzaChuZXcgTWVyZ2VTdW1tYXJ5Q29uZmxpY3QocmVhc29uLCBmaWxlLCB7IGRlbGV0ZVJlZiB9KSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXkNPTkZMSUNUXFxzK1xcKCguKylcXCk6LywgKHN1bW1hcnksIFtyZWFzb25dKSA9PiB7XG4gICAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgbnVsbCkpO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXkF1dG9tYXRpYyBtZXJnZSBmYWlsZWQ7XFxzKyguKykkLywgKHN1bW1hcnksIFtyZXN1bHRdKSA9PiB7XG4gICAgICAgIHN1bW1hcnkucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgfSlcbiAgICBdO1xuICAgIHBhcnNlTWVyZ2VSZXN1bHQgPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHBhcnNlTWVyZ2VEZXRhaWwoc3RkT3V0LCBzdGRFcnIpLCBwYXJzZVB1bGxSZXN1bHQoc3RkT3V0LCBzdGRFcnIpKTtcbiAgICB9O1xuICAgIHBhcnNlTWVyZ2VEZXRhaWwgPSAoc3RkT3V0KSA9PiB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgTWVyZ2VTdW1tYXJ5RGV0YWlsKCksIHBhcnNlcnM0LCBzdGRPdXQpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL21lcmdlLnRzXG5mdW5jdGlvbiBtZXJnZVRhc2soY3VzdG9tQXJncykge1xuICBpZiAoIWN1c3RvbUFyZ3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXCJHaXQubWVyZ2UgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIG9wdGlvblwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzOiBbXCJtZXJnZVwiLCAuLi5jdXN0b21BcmdzXSxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgIGNvbnN0IG1lcmdlID0gcGFyc2VNZXJnZVJlc3VsdChzdGRPdXQsIHN0ZEVycik7XG4gICAgICBpZiAobWVyZ2UuZmFpbGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBHaXRSZXNwb25zZUVycm9yKG1lcmdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9tZXJnZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL21lcmdlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfcmVzcG9uc2VfZXJyb3IoKTtcbiAgICBpbml0X3BhcnNlX21lcmdlKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtcHVzaC50c1xuZnVuY3Rpb24gcHVzaFJlc3VsdFB1c2hlZEl0ZW0obG9jYWwsIHJlbW90ZSwgc3RhdHVzKSB7XG4gIGNvbnN0IGRlbGV0ZWQgPSBzdGF0dXMuaW5jbHVkZXMoXCJkZWxldGVkXCIpO1xuICBjb25zdCB0YWcgPSBzdGF0dXMuaW5jbHVkZXMoXCJ0YWdcIikgfHwgL15yZWZzXFwvdGFncy8udGVzdChsb2NhbCk7XG4gIGNvbnN0IGFscmVhZHlVcGRhdGVkID0gIXN0YXR1cy5pbmNsdWRlcyhcIm5ld1wiKTtcbiAgcmV0dXJuIHtcbiAgICBkZWxldGVkLFxuICAgIHRhZyxcbiAgICBicmFuY2g6ICF0YWcsXG4gICAgbmV3OiAhYWxyZWFkeVVwZGF0ZWQsXG4gICAgYWxyZWFkeVVwZGF0ZWQsXG4gICAgbG9jYWwsXG4gICAgcmVtb3RlXG4gIH07XG59XG52YXIgcGFyc2VyczUsIHBhcnNlUHVzaFJlc3VsdCwgcGFyc2VQdXNoRGV0YWlsO1xudmFyIGluaXRfcGFyc2VfcHVzaCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtcHVzaC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3BhcnNlX3JlbW90ZV9tZXNzYWdlcygpO1xuICAgIHBhcnNlcnM1ID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoL15QdXNoaW5nIHRvICguKykkLywgKHJlc3VsdCwgW3JlcG9dKSA9PiB7XG4gICAgICAgIHJlc3VsdC5yZXBvID0gcmVwbztcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL151cGRhdGluZyBsb2NhbCB0cmFja2luZyByZWYgJyguKyknLywgKHJlc3VsdCwgW2xvY2FsXSkgPT4ge1xuICAgICAgICByZXN1bHQucmVmID0ge1xuICAgICAgICAgIC4uLnJlc3VsdC5yZWYgfHwge30sXG4gICAgICAgICAgbG9jYWxcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL15bPSotXVxccysoW146XSspOihcXFMrKVxccytcXFsoLispXSQvLCAocmVzdWx0LCBbbG9jYWwsIHJlbW90ZSwgdHlwZV0pID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2hlZC5wdXNoKHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsLCByZW1vdGUsIHR5cGUpKTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eQnJhbmNoICcoW14nXSspJyBzZXQgdXAgdG8gdHJhY2sgcmVtb3RlIGJyYW5jaCAnKFteJ10rKScgZnJvbSAnKFteJ10rKScvLFxuICAgICAgICAocmVzdWx0LCBbbG9jYWwsIHJlbW90ZSwgcmVtb3RlTmFtZV0pID0+IHtcbiAgICAgICAgICByZXN1bHQuYnJhbmNoID0ge1xuICAgICAgICAgICAgLi4ucmVzdWx0LmJyYW5jaCB8fCB7fSxcbiAgICAgICAgICAgIGxvY2FsLFxuICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgcmVtb3RlTmFtZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL14oW146XSspOihcXFMrKVxccysoW2EtejAtOV0rKVxcLlxcLihbYS16MC05XSspJC8sXG4gICAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCBmcm9tLCB0b10pID0+IHtcbiAgICAgICAgICByZXN1bHQudXBkYXRlID0ge1xuICAgICAgICAgICAgaGVhZDoge1xuICAgICAgICAgICAgICBsb2NhbCxcbiAgICAgICAgICAgICAgcmVtb3RlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzaDoge1xuICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICB0b1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICAgIHBhcnNlUHVzaFJlc3VsdCA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgICAgY29uc3QgcHVzaERldGFpbCA9IHBhcnNlUHVzaERldGFpbChzdGRPdXQsIHN0ZEVycik7XG4gICAgICBjb25zdCByZXNwb25zZURldGFpbCA9IHBhcnNlUmVtb3RlTWVzc2FnZXMoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHVzaERldGFpbCxcbiAgICAgICAgLi4ucmVzcG9uc2VEZXRhaWxcbiAgICAgIH07XG4gICAgfTtcbiAgICBwYXJzZVB1c2hEZXRhaWwgPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHsgcHVzaGVkOiBbXSB9LCBwYXJzZXJzNSwgW3N0ZE91dCwgc3RkRXJyXSk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvcHVzaC50c1xudmFyIHB1c2hfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocHVzaF9leHBvcnRzLCB7XG4gIHB1c2hUYWdzVGFzazogKCkgPT4gcHVzaFRhZ3NUYXNrLFxuICBwdXNoVGFzazogKCkgPT4gcHVzaFRhc2tcbn0pO1xuZnVuY3Rpb24gcHVzaFRhZ3NUYXNrKHJlZiA9IHt9LCBjdXN0b21BcmdzKSB7XG4gIGFwcGVuZChjdXN0b21BcmdzLCBcIi0tdGFnc1wiKTtcbiAgcmV0dXJuIHB1c2hUYXNrKHJlZiwgY3VzdG9tQXJncyk7XG59XG5mdW5jdGlvbiBwdXNoVGFzayhyZWYgPSB7fSwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInB1c2hcIiwgLi4uY3VzdG9tQXJnc107XG4gIGlmIChyZWYuYnJhbmNoKSB7XG4gICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIHJlZi5icmFuY2gpO1xuICB9XG4gIGlmIChyZWYucmVtb3RlKSB7XG4gICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIHJlZi5yZW1vdGUpO1xuICB9XG4gIHJlbW92ZShjb21tYW5kcywgXCItdlwiKTtcbiAgYXBwZW5kKGNvbW1hbmRzLCBcIi0tdmVyYm9zZVwiKTtcbiAgYXBwZW5kKGNvbW1hbmRzLCBcIi0tcG9yY2VsYWluXCIpO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogcGFyc2VQdXNoUmVzdWx0XG4gIH07XG59XG52YXIgaW5pdF9wdXNoID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvcHVzaC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfcGFyc2VfcHVzaCgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3Mvc2hvdy50c1xuZnVuY3Rpb24gc2hvd19kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIHNob3dCdWZmZXIoKSB7XG4gICAgICBjb25zdCBjb21tYW5kcyA9IFtcInNob3dcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSldO1xuICAgICAgaWYgKCFjb21tYW5kcy5pbmNsdWRlcyhcIi0tYmluYXJ5XCIpKSB7XG4gICAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCBcIi0tYmluYXJ5XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2soY29tbWFuZHMpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9LFxuICAgIHNob3coKSB7XG4gICAgICBjb25zdCBjb21tYW5kcyA9IFtcInNob3dcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSldO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9zaG93ID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3Mvc2hvdy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0ZpbGVTdGF0dXNTdW1tYXJ5LnRzXG52YXIgZnJvbVBhdGhSZWdleCwgRmlsZVN0YXR1c1N1bW1hcnk7XG52YXIgaW5pdF9GaWxlU3RhdHVzU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9GaWxlU3RhdHVzU3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZyb21QYXRoUmVnZXggPSAvXiguKylcXDAoLispJC87XG4gICAgRmlsZVN0YXR1c1N1bW1hcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihwYXRoLCBpbmRleCwgd29ya2luZ19kaXIpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLndvcmtpbmdfZGlyID0gd29ya2luZ19kaXI7XG4gICAgICAgIGlmIChpbmRleCA9PT0gXCJSXCIgfHwgd29ya2luZ19kaXIgPT09IFwiUlwiKSB7XG4gICAgICAgICAgY29uc3QgZGV0YWlsID0gZnJvbVBhdGhSZWdleC5leGVjKHBhdGgpIHx8IFtudWxsLCBwYXRoLCBwYXRoXTtcbiAgICAgICAgICB0aGlzLmZyb20gPSBkZXRhaWxbMl0gfHwgXCJcIjtcbiAgICAgICAgICB0aGlzLnBhdGggPSBkZXRhaWxbMV0gfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9TdGF0dXNTdW1tYXJ5LnRzXG5mdW5jdGlvbiByZW5hbWVkRmlsZShsaW5lKSB7XG4gIGNvbnN0IFt0bywgZnJvbV0gPSBsaW5lLnNwbGl0KE5VTEwpO1xuICByZXR1cm4ge1xuICAgIGZyb206IGZyb20gfHwgdG8sXG4gICAgdG9cbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlcjMoaW5kZXhYLCBpbmRleFksIGhhbmRsZXIpIHtcbiAgcmV0dXJuIFtgJHtpbmRleFh9JHtpbmRleFl9YCwgaGFuZGxlcl07XG59XG5mdW5jdGlvbiBjb25mbGljdHMoaW5kZXhYLCAuLi5pbmRleFkpIHtcbiAgcmV0dXJuIGluZGV4WS5tYXAoKHkpID0+IHBhcnNlcjMoaW5kZXhYLCB5LCAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmNvbmZsaWN0ZWQsIGZpbGUpKSk7XG59XG5mdW5jdGlvbiBzcGxpdExpbmUocmVzdWx0LCBsaW5lU3RyKSB7XG4gIGNvbnN0IHRyaW1tZWQyID0gbGluZVN0ci50cmltKCk7XG4gIHN3aXRjaCAoXCIgXCIpIHtcbiAgICBjYXNlIHRyaW1tZWQyLmNoYXJBdCgyKTpcbiAgICAgIHJldHVybiBkYXRhKHRyaW1tZWQyLmNoYXJBdCgwKSwgdHJpbW1lZDIuY2hhckF0KDEpLCB0cmltbWVkMi5zdWJzdHIoMykpO1xuICAgIGNhc2UgdHJpbW1lZDIuY2hhckF0KDEpOlxuICAgICAgcmV0dXJuIGRhdGEoXCIgXCIgLyogTk9ORSAqLywgdHJpbW1lZDIuY2hhckF0KDApLCB0cmltbWVkMi5zdWJzdHIoMikpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm47XG4gIH1cbiAgZnVuY3Rpb24gZGF0YShpbmRleCwgd29ya2luZ0RpciwgcGF0aCkge1xuICAgIGNvbnN0IHJhdyA9IGAke2luZGV4fSR7d29ya2luZ0Rpcn1gO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXJzNi5nZXQocmF3KTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcihyZXN1bHQsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAocmF3ICE9PSBcIiMjXCIgJiYgcmF3ICE9PSBcIiEhXCIpIHtcbiAgICAgIHJlc3VsdC5maWxlcy5wdXNoKG5ldyBGaWxlU3RhdHVzU3VtbWFyeShwYXRoLCBpbmRleCwgd29ya2luZ0RpcikpO1xuICAgIH1cbiAgfVxufVxudmFyIFN0YXR1c1N1bW1hcnksIHBhcnNlcnM2LCBwYXJzZVN0YXR1c1N1bW1hcnk7XG52YXIgaW5pdF9TdGF0dXNTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL1N0YXR1c1N1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9GaWxlU3RhdHVzU3VtbWFyeSgpO1xuICAgIFN0YXR1c1N1bW1hcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ub3RfYWRkZWQgPSBbXTtcbiAgICAgICAgdGhpcy5jb25mbGljdGVkID0gW107XG4gICAgICAgIHRoaXMuY3JlYXRlZCA9IFtdO1xuICAgICAgICB0aGlzLmRlbGV0ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5pZ25vcmVkID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gW107XG4gICAgICAgIHRoaXMucmVuYW1lZCA9IFtdO1xuICAgICAgICB0aGlzLmZpbGVzID0gW107XG4gICAgICAgIHRoaXMuc3RhZ2VkID0gW107XG4gICAgICAgIHRoaXMuYWhlYWQgPSAwO1xuICAgICAgICB0aGlzLmJlaGluZCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudHJhY2tpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDbGVhbiA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gIXRoaXMuZmlsZXMubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyc2VyczYgPSBuZXcgTWFwKFtcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiIFwiIC8qIE5PTkUgKi8sXG4gICAgICAgIFwiQVwiIC8qIEFEREVEICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmNyZWF0ZWQsIGZpbGUpXG4gICAgICApLFxuICAgICAgcGFyc2VyMyhcbiAgICAgICAgXCIgXCIgLyogTk9ORSAqLyxcbiAgICAgICAgXCJEXCIgLyogREVMRVRFRCAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5kZWxldGVkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiIFwiIC8qIE5PTkUgKi8sXG4gICAgICAgIFwiTVwiIC8qIE1PRElGSUVEICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0Lm1vZGlmaWVkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiQVwiIC8qIEFEREVEICovLFxuICAgICAgICBcIiBcIiAvKiBOT05FICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmNyZWF0ZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiQVwiIC8qIEFEREVEICovLFxuICAgICAgICBcIk1cIiAvKiBNT0RJRklFRCAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jcmVhdGVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSlcbiAgICAgICksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIkRcIiAvKiBERUxFVEVEICovLFxuICAgICAgICBcIiBcIiAvKiBOT05FICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmRlbGV0ZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiTVwiIC8qIE1PRElGSUVEICovLFxuICAgICAgICBcIiBcIiAvKiBOT05FICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0Lm1vZGlmaWVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSlcbiAgICAgICksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIk1cIiAvKiBNT0RJRklFRCAqLyxcbiAgICAgICAgXCJNXCIgLyogTU9ESUZJRUQgKi8sXG4gICAgICAgIChyZXN1bHQsIGZpbGUpID0+IGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXCJSXCIgLyogUkVOQU1FRCAqLywgXCIgXCIgLyogTk9ORSAqLywgKHJlc3VsdCwgZmlsZSkgPT4ge1xuICAgICAgICBhcHBlbmQocmVzdWx0LnJlbmFtZWQsIHJlbmFtZWRGaWxlKGZpbGUpKTtcbiAgICAgIH0pLFxuICAgICAgcGFyc2VyMyhcIlJcIiAvKiBSRU5BTUVEICovLCBcIk1cIiAvKiBNT0RJRklFRCAqLywgKHJlc3VsdCwgZmlsZSkgPT4ge1xuICAgICAgICBjb25zdCByZW5hbWVkID0gcmVuYW1lZEZpbGUoZmlsZSk7XG4gICAgICAgIGFwcGVuZChyZXN1bHQucmVuYW1lZCwgcmVuYW1lZCk7XG4gICAgICAgIGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIHJlbmFtZWQudG8pO1xuICAgICAgfSksXG4gICAgICBwYXJzZXIzKFwiIVwiIC8qIElHTk9SRUQgKi8sIFwiIVwiIC8qIElHTk9SRUQgKi8sIChfcmVzdWx0LCBfZmlsZSkgPT4ge1xuICAgICAgICBhcHBlbmQoX3Jlc3VsdC5pZ25vcmVkID0gX3Jlc3VsdC5pZ25vcmVkIHx8IFtdLCBfZmlsZSk7XG4gICAgICB9KSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiP1wiIC8qIFVOVFJBQ0tFRCAqLyxcbiAgICAgICAgXCI/XCIgLyogVU5UUkFDS0VEICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0Lm5vdF9hZGRlZCwgZmlsZSlcbiAgICAgICksXG4gICAgICAuLi5jb25mbGljdHMoXCJBXCIgLyogQURERUQgKi8sIFwiQVwiIC8qIEFEREVEICovLCBcIlVcIiAvKiBVTk1FUkdFRCAqLyksXG4gICAgICAuLi5jb25mbGljdHMoXG4gICAgICAgIFwiRFwiIC8qIERFTEVURUQgKi8sXG4gICAgICAgIFwiRFwiIC8qIERFTEVURUQgKi8sXG4gICAgICAgIFwiVVwiIC8qIFVOTUVSR0VEICovXG4gICAgICApLFxuICAgICAgLi4uY29uZmxpY3RzKFxuICAgICAgICBcIlVcIiAvKiBVTk1FUkdFRCAqLyxcbiAgICAgICAgXCJBXCIgLyogQURERUQgKi8sXG4gICAgICAgIFwiRFwiIC8qIERFTEVURUQgKi8sXG4gICAgICAgIFwiVVwiIC8qIFVOTUVSR0VEICovXG4gICAgICApLFxuICAgICAgW1xuICAgICAgICBcIiMjXCIsXG4gICAgICAgIChyZXN1bHQsIGxpbmUpID0+IHtcbiAgICAgICAgICBjb25zdCBhaGVhZFJlZyA9IC9haGVhZCAoXFxkKykvO1xuICAgICAgICAgIGNvbnN0IGJlaGluZFJlZyA9IC9iZWhpbmQgKFxcZCspLztcbiAgICAgICAgICBjb25zdCBjdXJyZW50UmVnID0gL14oLis/KD89KD86XFwuezN9fFxcc3wkKSkpLztcbiAgICAgICAgICBjb25zdCB0cmFja2luZ1JlZyA9IC9cXC57M30oXFxTKikvO1xuICAgICAgICAgIGNvbnN0IG9uRW1wdHlCcmFuY2hSZWcgPSAvXFxzb25cXHMoXFxTKz8pKD89XFwuezN9fCQpLztcbiAgICAgICAgICBsZXQgcmVnZXhSZXN1bHQgPSBhaGVhZFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgIHJlc3VsdC5haGVhZCA9IHJlZ2V4UmVzdWx0ICYmICtyZWdleFJlc3VsdFsxXSB8fCAwO1xuICAgICAgICAgIHJlZ2V4UmVzdWx0ID0gYmVoaW5kUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICAgcmVzdWx0LmJlaGluZCA9IHJlZ2V4UmVzdWx0ICYmICtyZWdleFJlc3VsdFsxXSB8fCAwO1xuICAgICAgICAgIHJlZ2V4UmVzdWx0ID0gY3VycmVudFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgIHJlc3VsdC5jdXJyZW50ID0gZmlsdGVyVHlwZShyZWdleFJlc3VsdD8uWzFdLCBmaWx0ZXJTdHJpbmcsIG51bGwpO1xuICAgICAgICAgIHJlZ2V4UmVzdWx0ID0gdHJhY2tpbmdSZWcuZXhlYyhsaW5lKTtcbiAgICAgICAgICByZXN1bHQudHJhY2tpbmcgPSBmaWx0ZXJUeXBlKHJlZ2V4UmVzdWx0Py5bMV0sIGZpbHRlclN0cmluZywgbnVsbCk7XG4gICAgICAgICAgcmVnZXhSZXN1bHQgPSBvbkVtcHR5QnJhbmNoUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICAgaWYgKHJlZ2V4UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuY3VycmVudCA9IGZpbHRlclR5cGUocmVnZXhSZXN1bHQ/LlsxXSwgZmlsdGVyU3RyaW5nLCByZXN1bHQuY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5kZXRhY2hlZCA9IC9cXChubyBicmFuY2hcXCkvLnRlc3QobGluZSk7XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICBdKTtcbiAgICBwYXJzZVN0YXR1c1N1bW1hcnkgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoTlVMTCk7XG4gICAgICBjb25zdCBzdGF0dXMgPSBuZXcgU3RhdHVzU3VtbWFyeSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyApIHtcbiAgICAgICAgbGV0IGxpbmUgPSBsaW5lc1tpKytdLnRyaW0oKTtcbiAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUuY2hhckF0KDApID09PSBcIlJcIiAvKiBSRU5BTUVEICovKSB7XG4gICAgICAgICAgbGluZSArPSBOVUxMICsgKGxpbmVzW2krK10gfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3BsaXRMaW5lKHN0YXR1cywgbGluZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3N0YXR1cy50c1xuZnVuY3Rpb24gc3RhdHVzVGFzayhjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1xuICAgIFwic3RhdHVzXCIsXG4gICAgXCItLXBvcmNlbGFpblwiLFxuICAgIFwiLWJcIixcbiAgICBcIi11XCIsXG4gICAgXCItLW51bGxcIixcbiAgICAuLi5jdXN0b21BcmdzLmZpbHRlcigoYXJnKSA9PiAhaWdub3JlZE9wdGlvbnMuaW5jbHVkZXMoYXJnKSlcbiAgXTtcbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBjb21tYW5kcyxcbiAgICBwYXJzZXIodGV4dCkge1xuICAgICAgcmV0dXJuIHBhcnNlU3RhdHVzU3VtbWFyeSh0ZXh0KTtcbiAgICB9XG4gIH07XG59XG52YXIgaWdub3JlZE9wdGlvbnM7XG52YXIgaW5pdF9zdGF0dXMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9zdGF0dXMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X1N0YXR1c1N1bW1hcnkoKTtcbiAgICBpZ25vcmVkT3B0aW9ucyA9IFtcIi0tbnVsbFwiLCBcIi16XCJdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy92ZXJzaW9uLnRzXG5mdW5jdGlvbiB2ZXJzaW9uUmVzcG9uc2UobWFqb3IgPSAwLCBtaW5vciA9IDAsIHBhdGNoID0gMCwgYWdlbnQgPSBcIlwiLCBpbnN0YWxsZWQgPSB0cnVlKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAge1xuICAgICAgbWFqb3IsXG4gICAgICBtaW5vcixcbiAgICAgIHBhdGNoLFxuICAgICAgYWdlbnQsXG4gICAgICBpbnN0YWxsZWRcbiAgICB9LFxuICAgIFwidG9TdHJpbmdcIixcbiAgICB7XG4gICAgICB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubWFqb3J9LiR7dGhpcy5taW5vcn0uJHt0aGlzLnBhdGNofWA7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gbm90SW5zdGFsbGVkUmVzcG9uc2UoKSB7XG4gIHJldHVybiB2ZXJzaW9uUmVzcG9uc2UoMCwgMCwgMCwgXCJcIiwgZmFsc2UpO1xufVxuZnVuY3Rpb24gdmVyc2lvbl9kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIHZlcnNpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh7XG4gICAgICAgIGNvbW1hbmRzOiBbXCItLXZlcnNpb25cIl0sXG4gICAgICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgICAgICBwYXJzZXI6IHZlcnNpb25QYXJzZXIsXG4gICAgICAgIG9uRXJyb3IocmVzdWx0LCBlcnJvciwgZG9uZSwgZmFpbCkge1xuICAgICAgICAgIGlmIChyZXN1bHQuZXhpdENvZGUgPT09IC0yIC8qIE5PVF9GT1VORCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoQnVmZmVyLmZyb20oTk9UX0lOU1RBTExFRCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmYWlsKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdmVyc2lvblBhcnNlcihzdGRPdXQpIHtcbiAgaWYgKHN0ZE91dCA9PT0gTk9UX0lOU1RBTExFRCkge1xuICAgIHJldHVybiBub3RJbnN0YWxsZWRSZXNwb25zZSgpO1xuICB9XG4gIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHZlcnNpb25SZXNwb25zZSgwLCAwLCAwLCBzdGRPdXQpLCBwYXJzZXJzNywgc3RkT3V0KTtcbn1cbnZhciBOT1RfSU5TVEFMTEVELCBwYXJzZXJzNztcbnZhciBpbml0X3ZlcnNpb24gPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy92ZXJzaW9uLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIE5PVF9JTlNUQUxMRUQgPSBcImluc3RhbGxlZD1mYWxzZVwiO1xuICAgIHBhcnNlcnM3ID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC92ZXJzaW9uIChcXGQrKVxcLihcXGQrKVxcLihcXGQrKSg/OlxccypcXCgoLispXFwpKT8vLFxuICAgICAgICAocmVzdWx0LCBbbWFqb3IsIG1pbm9yLCBwYXRjaCwgYWdlbnQgPSBcIlwiXSkgPT4ge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICB2ZXJzaW9uUmVzcG9uc2UoYXNOdW1iZXIobWFqb3IpLCBhc051bWJlcihtaW5vciksIGFzTnVtYmVyKHBhdGNoKSwgYWdlbnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvdmVyc2lvbiAoXFxkKylcXC4oXFxkKylcXC4oXFxEKykoLispPyQvLFxuICAgICAgICAocmVzdWx0LCBbbWFqb3IsIG1pbm9yLCBwYXRjaCwgYWdlbnQgPSBcIlwiXSkgPT4ge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2ZXJzaW9uUmVzcG9uc2UoYXNOdW1iZXIobWFqb3IpLCBhc051bWJlcihtaW5vciksIHBhdGNoLCBhZ2VudCkpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvc2ltcGxlLWdpdC1hcGkudHNcbnZhciBzaW1wbGVfZ2l0X2FwaV9leHBvcnRzID0ge307XG5fX2V4cG9ydChzaW1wbGVfZ2l0X2FwaV9leHBvcnRzLCB7XG4gIFNpbXBsZUdpdEFwaTogKCkgPT4gU2ltcGxlR2l0QXBpXG59KTtcbnZhciBTaW1wbGVHaXRBcGk7XG52YXIgaW5pdF9zaW1wbGVfZ2l0X2FwaSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3NpbXBsZS1naXQtYXBpLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF90YXNrX2NhbGxiYWNrKCk7XG4gICAgaW5pdF9jaGFuZ2Vfd29ya2luZ19kaXJlY3RvcnkoKTtcbiAgICBpbml0X2NoZWNrb3V0KCk7XG4gICAgaW5pdF9jb3VudF9vYmplY3RzKCk7XG4gICAgaW5pdF9jb21taXQoKTtcbiAgICBpbml0X2NvbmZpZygpO1xuICAgIGluaXRfZmlyc3RfY29tbWl0KCk7XG4gICAgaW5pdF9ncmVwKCk7XG4gICAgaW5pdF9oYXNoX29iamVjdCgpO1xuICAgIGluaXRfaW5pdCgpO1xuICAgIGluaXRfbG9nKCk7XG4gICAgaW5pdF9tZXJnZSgpO1xuICAgIGluaXRfcHVzaCgpO1xuICAgIGluaXRfc2hvdygpO1xuICAgIGluaXRfc3RhdHVzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gICAgaW5pdF92ZXJzaW9uKCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIFNpbXBsZUdpdEFwaSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKF9leGVjdXRvcikge1xuICAgICAgICB0aGlzLl9leGVjdXRvciA9IF9leGVjdXRvcjtcbiAgICAgIH1cbiAgICAgIF9ydW5UYXNrKHRhc2ssIHRoZW4pIHtcbiAgICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLl9leGVjdXRvci5jaGFpbigpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gY2hhaW4ucHVzaCh0YXNrKTtcbiAgICAgICAgaWYgKHRoZW4pIHtcbiAgICAgICAgICB0YXNrQ2FsbGJhY2sodGFzaywgcHJvbWlzZSwgdGhlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcywge1xuICAgICAgICAgIHRoZW46IHsgdmFsdWU6IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpIH0sXG4gICAgICAgICAgY2F0Y2g6IHsgdmFsdWU6IHByb21pc2UuY2F0Y2guYmluZChwcm9taXNlKSB9LFxuICAgICAgICAgIF9leGVjdXRvcjogeyB2YWx1ZTogY2hhaW4gfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFkZChmaWxlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFtcImFkZFwiLCAuLi5hc0FycmF5KGZpbGVzKV0pLFxuICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjd2QoZGlyZWN0b3J5KSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXJlY3RvcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayhkaXJlY3RvcnksIHRoaXMuX2V4ZWN1dG9yKSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkaXJlY3Rvcnk/LnBhdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKFxuICAgICAgICAgICAgICBkaXJlY3RvcnkucGF0aCxcbiAgICAgICAgICAgICAgZGlyZWN0b3J5LnJvb3QgJiYgdGhpcy5fZXhlY3V0b3IgfHwgdm9pZCAwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzayhcIkdpdC5jd2Q6IHdvcmtpbmdEaXJlY3RvcnkgbXVzdCBiZSBzdXBwbGllZCBhcyBhIHN0cmluZ1wiKSxcbiAgICAgICAgICBuZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBoYXNoT2JqZWN0KHBhdGgsIHdyaXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIGhhc2hPYmplY3RUYXNrKHBhdGgsIHdyaXRlID09PSB0cnVlKSxcbiAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaW5pdChiYXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIGluaXRUYXNrKGJhcmUgPT09IHRydWUsIHRoaXMuX2V4ZWN1dG9yLmN3ZCwgZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBtZXJnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgbWVyZ2VUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbWVyZ2VGcm9tVG8ocmVtb3RlLCBicmFuY2gpIHtcbiAgICAgICAgaWYgKCEoZmlsdGVyU3RyaW5nKHJlbW90ZSkgJiYgZmlsdGVyU3RyaW5nKGJyYW5jaCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICAgICBgR2l0Lm1lcmdlRnJvbVRvIHJlcXVpcmVzIHRoYXQgdGhlICdyZW1vdGUnIGFuZCAnYnJhbmNoJyBhcmd1bWVudHMgYXJlIHN1cHBsaWVkIGFzIHN0cmluZ3NgXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBtZXJnZVRhc2soW3JlbW90ZSwgYnJhbmNoLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMsIGZhbHNlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgb3V0cHV0SGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2V4ZWN1dG9yLm91dHB1dEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHB1c2goKSB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBwdXNoVGFzayhcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZW1vdGU6IGZpbHRlclR5cGUoYXJndW1lbnRzWzBdLCBmaWx0ZXJTdHJpbmcpLFxuICAgICAgICAgICAgYnJhbmNoOiBmaWx0ZXJUeXBlKGFyZ3VtZW50c1sxXSwgZmlsdGVyU3RyaW5nKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgICAgc3Rhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soW1wic3Rhc2hcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBzdGF0dXNUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihcbiAgICAgIFNpbXBsZUdpdEFwaS5wcm90b3R5cGUsXG4gICAgICBjaGVja291dF9kZWZhdWx0KCksXG4gICAgICBjb21taXRfZGVmYXVsdCgpLFxuICAgICAgY29uZmlnX2RlZmF1bHQoKSxcbiAgICAgIGNvdW50X29iamVjdHNfZGVmYXVsdCgpLFxuICAgICAgZmlyc3RfY29tbWl0X2RlZmF1bHQoKSxcbiAgICAgIGdyZXBfZGVmYXVsdCgpLFxuICAgICAgbG9nX2RlZmF1bHQoKSxcbiAgICAgIHNob3dfZGVmYXVsdCgpLFxuICAgICAgdmVyc2lvbl9kZWZhdWx0KClcbiAgICApO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9ydW5uZXJzL3NjaGVkdWxlci50c1xudmFyIHNjaGVkdWxlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChzY2hlZHVsZXJfZXhwb3J0cywge1xuICBTY2hlZHVsZXI6ICgpID0+IFNjaGVkdWxlclxufSk7XG5pbXBvcnQgeyBjcmVhdGVEZWZlcnJlZCB9IGZyb20gXCJAa3dzaXRlcy9wcm9taXNlLWRlZmVycmVkXCI7XG52YXIgY3JlYXRlU2NoZWR1bGVkVGFzaywgU2NoZWR1bGVyO1xudmFyIGluaXRfc2NoZWR1bGVyID0gX19lc20oe1xuICBcInNyYy9saWIvcnVubmVycy9zY2hlZHVsZXIudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9naXRfbG9nZ2VyKCk7XG4gICAgY3JlYXRlU2NoZWR1bGVkVGFzayA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgICAgbGV0IGlkID0gMDtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlkKys7XG4gICAgICAgIGNvbnN0IHsgcHJvbWlzZSwgZG9uZSB9ID0gY3JlYXRlRGVmZXJyZWQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgIGRvbmUsXG4gICAgICAgICAgaWRcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBTY2hlZHVsZXIgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSA9IDIpIHtcbiAgICAgICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5O1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGNyZWF0ZUxvZ2dlcihcIlwiLCBcInNjaGVkdWxlclwiKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gW107XG4gICAgICAgIHRoaXMucnVubmluZyA9IFtdO1xuICAgICAgICB0aGlzLmxvZ2dlcihgQ29uc3RydWN0ZWQsIGNvbmN1cnJlbmN5PSVzYCwgY29uY3VycmVuY3kpO1xuICAgICAgfVxuICAgICAgc2NoZWR1bGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nLmxlbmd0aCB8fCB0aGlzLnJ1bm5pbmcubGVuZ3RoID49IHRoaXMuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAgIGBTY2hlZHVsZSBhdHRlbXB0IGlnbm9yZWQsIHBlbmRpbmc9JXMgcnVubmluZz0lcyBjb25jdXJyZW5jeT0lc2AsXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRoaXMuY29uY3VycmVuY3lcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXNrID0gYXBwZW5kKHRoaXMucnVubmluZywgdGhpcy5wZW5kaW5nLnNoaWZ0KCkpO1xuICAgICAgICB0aGlzLmxvZ2dlcihgQXR0ZW1wdGluZyBpZD0lc2AsIHRhc2suaWQpO1xuICAgICAgICB0YXNrLmRvbmUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubG9nZ2VyKGBDb21wbGV0aW5nIGlkPWAsIHRhc2suaWQpO1xuICAgICAgICAgIHJlbW92ZSh0aGlzLnJ1bm5pbmcsIHRhc2spO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCB7IHByb21pc2UsIGlkIH0gPSBhcHBlbmQodGhpcy5wZW5kaW5nLCBjcmVhdGVTY2hlZHVsZWRUYXNrKCkpO1xuICAgICAgICB0aGlzLmxvZ2dlcihgU2NoZWR1bGluZyBpZD0lc2AsIGlkKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9hcHBseS1wYXRjaC50c1xudmFyIGFwcGx5X3BhdGNoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGFwcGx5X3BhdGNoX2V4cG9ydHMsIHtcbiAgYXBwbHlQYXRjaFRhc2s6ICgpID0+IGFwcGx5UGF0Y2hUYXNrXG59KTtcbmZ1bmN0aW9uIGFwcGx5UGF0Y2hUYXNrKHBhdGNoZXMsIGN1c3RvbUFyZ3MpIHtcbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soW1wiYXBwbHlcIiwgLi4uY3VzdG9tQXJncywgLi4ucGF0Y2hlc10pO1xufVxudmFyIGluaXRfYXBwbHlfcGF0Y2ggPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9hcHBseS1wYXRjaC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvQnJhbmNoRGVsZXRlU3VtbWFyeS50c1xuZnVuY3Rpb24gYnJhbmNoRGVsZXRpb25TdWNjZXNzKGJyYW5jaCwgaGFzaCkge1xuICByZXR1cm4ge1xuICAgIGJyYW5jaCxcbiAgICBoYXNoLFxuICAgIHN1Y2Nlc3M6IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGJyYW5jaERlbGV0aW9uRmFpbHVyZShicmFuY2gpIHtcbiAgcmV0dXJuIHtcbiAgICBicmFuY2gsXG4gICAgaGFzaDogbnVsbCxcbiAgICBzdWNjZXNzOiBmYWxzZVxuICB9O1xufVxudmFyIEJyYW5jaERlbGV0aW9uQmF0Y2g7XG52YXIgaW5pdF9CcmFuY2hEZWxldGVTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0JyYW5jaERlbGV0ZVN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBCcmFuY2hEZWxldGlvbkJhdGNoID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWxsID0gW107XG4gICAgICAgIHRoaXMuYnJhbmNoZXMgPSB7fTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXJyb3JzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWJyYW5jaC1kZWxldGUudHNcbmZ1bmN0aW9uIGhhc0JyYW5jaERlbGV0aW9uRXJyb3IoZGF0YSwgcHJvY2Vzc0V4aXRDb2RlKSB7XG4gIHJldHVybiBwcm9jZXNzRXhpdENvZGUgPT09IDEgLyogRVJST1IgKi8gJiYgZGVsZXRlRXJyb3JSZWdleC50ZXN0KGRhdGEpO1xufVxudmFyIGRlbGV0ZVN1Y2Nlc3NSZWdleCwgZGVsZXRlRXJyb3JSZWdleCwgcGFyc2VyczgsIHBhcnNlQnJhbmNoRGVsZXRpb25zO1xudmFyIGluaXRfcGFyc2VfYnJhbmNoX2RlbGV0ZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtYnJhbmNoLWRlbGV0ZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfQnJhbmNoRGVsZXRlU3VtbWFyeSgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBkZWxldGVTdWNjZXNzUmVnZXggPSAvKFxcUyspXFxzK1xcKFxcUytcXHMoW14pXSspXFwpLztcbiAgICBkZWxldGVFcnJvclJlZ2V4ID0gL15lcnJvclteJ10rJyhbXiddKyknL207XG4gICAgcGFyc2VyczggPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihkZWxldGVTdWNjZXNzUmVnZXgsIChyZXN1bHQsIFticmFuY2gsIGhhc2hdKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbGV0aW9uID0gYnJhbmNoRGVsZXRpb25TdWNjZXNzKGJyYW5jaCwgaGFzaCk7XG4gICAgICAgIHJlc3VsdC5hbGwucHVzaChkZWxldGlvbik7XG4gICAgICAgIHJlc3VsdC5icmFuY2hlc1ticmFuY2hdID0gZGVsZXRpb247XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKGRlbGV0ZUVycm9yUmVnZXgsIChyZXN1bHQsIFticmFuY2hdKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbGV0aW9uID0gYnJhbmNoRGVsZXRpb25GYWlsdXJlKGJyYW5jaCk7XG4gICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChkZWxldGlvbik7XG4gICAgICAgIHJlc3VsdC5hbGwucHVzaChkZWxldGlvbik7XG4gICAgICAgIHJlc3VsdC5icmFuY2hlc1ticmFuY2hdID0gZGVsZXRpb247XG4gICAgICB9KVxuICAgIF07XG4gICAgcGFyc2VCcmFuY2hEZWxldGlvbnMgPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hEZWxldGlvbkJhdGNoKCksIHBhcnNlcnM4LCBbc3RkT3V0LCBzdGRFcnJdKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvQnJhbmNoU3VtbWFyeS50c1xudmFyIEJyYW5jaFN1bW1hcnlSZXN1bHQ7XG52YXIgaW5pdF9CcmFuY2hTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0JyYW5jaFN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBCcmFuY2hTdW1tYXJ5UmVzdWx0ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWxsID0gW107XG4gICAgICAgIHRoaXMuYnJhbmNoZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gXCJcIjtcbiAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcHVzaChzdGF0dXMsIGRldGFjaGVkLCBuYW1lLCBjb21taXQsIGxhYmVsKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFwiKlwiIC8qIENVUlJFTlQgKi8pIHtcbiAgICAgICAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XG4gICAgICAgICAgdGhpcy5jdXJyZW50ID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbC5wdXNoKG5hbWUpO1xuICAgICAgICB0aGlzLmJyYW5jaGVzW25hbWVdID0ge1xuICAgICAgICAgIGN1cnJlbnQ6IHN0YXR1cyA9PT0gXCIqXCIgLyogQ1VSUkVOVCAqLyxcbiAgICAgICAgICBsaW5rZWRXb3JrVHJlZTogc3RhdHVzID09PSBcIitcIiAvKiBMSU5LRUQgKi8sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjb21taXQsXG4gICAgICAgICAgbGFiZWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWJyYW5jaC50c1xuZnVuY3Rpb24gYnJhbmNoU3RhdHVzKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCA/IGlucHV0LmNoYXJBdCgwKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBwYXJzZUJyYW5jaFN1bW1hcnkoc3RkT3V0LCBjdXJyZW50T25seSA9IGZhbHNlKSB7XG4gIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKFxuICAgIG5ldyBCcmFuY2hTdW1tYXJ5UmVzdWx0KCksXG4gICAgY3VycmVudE9ubHkgPyBbY3VycmVudEJyYW5jaFBhcnNlcl0gOiBwYXJzZXJzOSxcbiAgICBzdGRPdXRcbiAgKTtcbn1cbnZhciBwYXJzZXJzOSwgY3VycmVudEJyYW5jaFBhcnNlcjtcbnZhciBpbml0X3BhcnNlX2JyYW5jaCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtYnJhbmNoLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9CcmFuY2hTdW1tYXJ5KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIHBhcnNlcnM5ID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eKFsqK11cXHMpP1xcKCg/OkhFQUQgKT9kZXRhY2hlZCAoPzpmcm9tfGF0KSAoXFxTKylcXClcXHMrKFthLXowLTldKylcXHMoLiopJC8sXG4gICAgICAgIChyZXN1bHQsIFtjdXJyZW50LCBuYW1lLCBjb21taXQsIGxhYmVsXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGJyYW5jaFN0YXR1cyhjdXJyZW50KSwgdHJ1ZSwgbmFtZSwgY29tbWl0LCBsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL14oWyorXVxccyk/KFxcUyspXFxzKyhbYS16MC05XSspXFxzPyguKikkL3MsXG4gICAgICAgIChyZXN1bHQsIFtjdXJyZW50LCBuYW1lLCBjb21taXQsIGxhYmVsXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGJyYW5jaFN0YXR1cyhjdXJyZW50KSwgZmFsc2UsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgICBjdXJyZW50QnJhbmNoUGFyc2VyID0gbmV3IExpbmVQYXJzZXIoL14oXFxTKykkL3MsIChyZXN1bHQsIFtuYW1lXSkgPT4ge1xuICAgICAgcmVzdWx0LnB1c2goXCIqXCIgLyogQ1VSUkVOVCAqLywgZmFsc2UsIG5hbWUsIFwiXCIsIFwiXCIpO1xuICAgIH0pO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9icmFuY2gudHNcbnZhciBicmFuY2hfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoYnJhbmNoX2V4cG9ydHMsIHtcbiAgYnJhbmNoTG9jYWxUYXNrOiAoKSA9PiBicmFuY2hMb2NhbFRhc2ssXG4gIGJyYW5jaFRhc2s6ICgpID0+IGJyYW5jaFRhc2ssXG4gIGNvbnRhaW5zRGVsZXRlQnJhbmNoQ29tbWFuZDogKCkgPT4gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kLFxuICBkZWxldGVCcmFuY2hUYXNrOiAoKSA9PiBkZWxldGVCcmFuY2hUYXNrLFxuICBkZWxldGVCcmFuY2hlc1Rhc2s6ICgpID0+IGRlbGV0ZUJyYW5jaGVzVGFza1xufSk7XG5mdW5jdGlvbiBjb250YWluc0RlbGV0ZUJyYW5jaENvbW1hbmQoY29tbWFuZHMpIHtcbiAgY29uc3QgZGVsZXRlQ29tbWFuZHMgPSBbXCItZFwiLCBcIi1EXCIsIFwiLS1kZWxldGVcIl07XG4gIHJldHVybiBjb21tYW5kcy5zb21lKChjb21tYW5kKSA9PiBkZWxldGVDb21tYW5kcy5pbmNsdWRlcyhjb21tYW5kKSk7XG59XG5mdW5jdGlvbiBicmFuY2hUYXNrKGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgaXNEZWxldGUgPSBjb250YWluc0RlbGV0ZUJyYW5jaENvbW1hbmQoY3VzdG9tQXJncyk7XG4gIGNvbnN0IGlzQ3VycmVudE9ubHkgPSBjdXN0b21BcmdzLmluY2x1ZGVzKFwiLS1zaG93LWN1cnJlbnRcIik7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiYnJhbmNoXCIsIC4uLmN1c3RvbUFyZ3NdO1xuICBpZiAoY29tbWFuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgY29tbWFuZHMucHVzaChcIi1hXCIpO1xuICB9XG4gIGlmICghY29tbWFuZHMuaW5jbHVkZXMoXCItdlwiKSkge1xuICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCBcIi12XCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHMsXG4gICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICBpZiAoaXNEZWxldGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoRGVsZXRpb25zKHN0ZE91dCwgc3RkRXJyKS5hbGxbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VCcmFuY2hTdW1tYXJ5KHN0ZE91dCwgaXNDdXJyZW50T25seSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnJhbmNoTG9jYWxUYXNrKCkge1xuICByZXR1cm4ge1xuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIGNvbW1hbmRzOiBbXCJicmFuY2hcIiwgXCItdlwiXSxcbiAgICBwYXJzZXIoc3RkT3V0KSB7XG4gICAgICByZXR1cm4gcGFyc2VCcmFuY2hTdW1tYXJ5KHN0ZE91dCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlQnJhbmNoZXNUYXNrKGJyYW5jaGVzLCBmb3JjZURlbGV0ZSA9IGZhbHNlKSB7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcImJyYW5jaFwiLCBcIi12XCIsIGZvcmNlRGVsZXRlID8gXCItRFwiIDogXCItZFwiLCAuLi5icmFuY2hlc10sXG4gICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpO1xuICAgIH0sXG4gICAgb25FcnJvcih7IGV4aXRDb2RlLCBzdGRPdXQgfSwgZXJyb3IsIGRvbmUsIGZhaWwpIHtcbiAgICAgIGlmICghaGFzQnJhbmNoRGVsZXRpb25FcnJvcihTdHJpbmcoZXJyb3IpLCBleGl0Q29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgfVxuICAgICAgZG9uZShzdGRPdXQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJyYW5jaFRhc2soYnJhbmNoLCBmb3JjZURlbGV0ZSA9IGZhbHNlKSB7XG4gIGNvbnN0IHRhc2sgPSB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcImJyYW5jaFwiLCBcIi12XCIsIGZvcmNlRGVsZXRlID8gXCItRFwiIDogXCItZFwiLCBicmFuY2hdLFxuICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoRGVsZXRpb25zKHN0ZE91dCwgc3RkRXJyKS5icmFuY2hlc1ticmFuY2hdO1xuICAgIH0sXG4gICAgb25FcnJvcih7IGV4aXRDb2RlLCBzdGRFcnIsIHN0ZE91dCB9LCBlcnJvciwgXywgZmFpbCkge1xuICAgICAgaWYgKCFoYXNCcmFuY2hEZWxldGlvbkVycm9yKFN0cmluZyhlcnJvciksIGV4aXRDb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFpbChlcnJvcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgR2l0UmVzcG9uc2VFcnJvcihcbiAgICAgICAgdGFzay5wYXJzZXIoYnVmZmVyVG9TdHJpbmcoc3RkT3V0KSwgYnVmZmVyVG9TdHJpbmcoc3RkRXJyKSksXG4gICAgICAgIFN0cmluZyhlcnJvcilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdGFzaztcbn1cbnZhciBpbml0X2JyYW5jaCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2JyYW5jaC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG4gICAgaW5pdF9wYXJzZV9icmFuY2hfZGVsZXRlKCk7XG4gICAgaW5pdF9wYXJzZV9icmFuY2goKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9DaGVja0lnbm9yZS50c1xuaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSBcIm5vZGU6cGF0aFwiO1xuZnVuY3Rpb24gdG9QYXRoKGlucHV0KSB7XG4gIGNvbnN0IHBhdGggPSBpbnB1dC50cmltKCkucmVwbGFjZSgvXltcIiddfFtcIiddJC9nLCBcIlwiKTtcbiAgcmV0dXJuIHBhdGggJiYgbm9ybWFsaXplKHBhdGgpO1xufVxudmFyIHBhcnNlQ2hlY2tJZ25vcmU7XG52YXIgaW5pdF9DaGVja0lnbm9yZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9DaGVja0lnbm9yZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHBhcnNlQ2hlY2tJZ25vcmUgPSAodGV4dCkgPT4ge1xuICAgICAgcmV0dXJuIHRleHQuc3BsaXQoL1xcbi9nKS5tYXAodG9QYXRoKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY2hlY2staWdub3JlLnRzXG52YXIgY2hlY2tfaWdub3JlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNoZWNrX2lnbm9yZV9leHBvcnRzLCB7XG4gIGNoZWNrSWdub3JlVGFzazogKCkgPT4gY2hlY2tJZ25vcmVUYXNrXG59KTtcbmZ1bmN0aW9uIGNoZWNrSWdub3JlVGFzayhwYXRocykge1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzOiBbXCJjaGVjay1pZ25vcmVcIiwgLi4ucGF0aHNdLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogcGFyc2VDaGVja0lnbm9yZVxuICB9O1xufVxudmFyIGluaXRfY2hlY2tfaWdub3JlID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY2hlY2staWdub3JlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9DaGVja0lnbm9yZSgpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jbG9uZS50c1xudmFyIGNsb25lX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNsb25lX2V4cG9ydHMsIHtcbiAgY2xvbmVNaXJyb3JUYXNrOiAoKSA9PiBjbG9uZU1pcnJvclRhc2ssXG4gIGNsb25lVGFzazogKCkgPT4gY2xvbmVUYXNrXG59KTtcbmZ1bmN0aW9uIGRpc2FsbG93ZWRDb21tYW5kKGNvbW1hbmQpIHtcbiAgcmV0dXJuIC9eLS11cGxvYWQtcGFjayg9fCQpLy50ZXN0KGNvbW1hbmQpO1xufVxuZnVuY3Rpb24gY2xvbmVUYXNrKHJlcG8sIGRpcmVjdG9yeSwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImNsb25lXCIsIC4uLmN1c3RvbUFyZ3NdO1xuICBmaWx0ZXJTdHJpbmcocmVwbykgJiYgY29tbWFuZHMucHVzaChyZXBvKTtcbiAgZmlsdGVyU3RyaW5nKGRpcmVjdG9yeSkgJiYgY29tbWFuZHMucHVzaChkaXJlY3RvcnkpO1xuICBjb25zdCBiYW5uZWQgPSBjb21tYW5kcy5maW5kKGRpc2FsbG93ZWRDb21tYW5kKTtcbiAgaWYgKGJhbm5lZCkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGBnaXQuZmV0Y2g6IHBvdGVudGlhbCBleHBsb2l0IGFyZ3VtZW50IGJsb2NrZWQuYCk7XG4gIH1cbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gY2xvbmVNaXJyb3JUYXNrKHJlcG8sIGRpcmVjdG9yeSwgY3VzdG9tQXJncykge1xuICBhcHBlbmQoY3VzdG9tQXJncywgXCItLW1pcnJvclwiKTtcbiAgcmV0dXJuIGNsb25lVGFzayhyZXBvLCBkaXJlY3RvcnksIGN1c3RvbUFyZ3MpO1xufVxudmFyIGluaXRfY2xvbmUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jbG9uZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFzaygpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1mZXRjaC50c1xuZnVuY3Rpb24gcGFyc2VGZXRjaFJlc3VsdChzdGRPdXQsIHN0ZEVycikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcmF3OiBzdGRPdXQsXG4gICAgcmVtb3RlOiBudWxsLFxuICAgIGJyYW5jaGVzOiBbXSxcbiAgICB0YWdzOiBbXSxcbiAgICB1cGRhdGVkOiBbXSxcbiAgICBkZWxldGVkOiBbXVxuICB9O1xuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShyZXN1bHQsIHBhcnNlcnMxMCwgW3N0ZE91dCwgc3RkRXJyXSk7XG59XG52YXIgcGFyc2VyczEwO1xudmFyIGluaXRfcGFyc2VfZmV0Y2ggPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLWZldGNoLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIHBhcnNlcnMxMCA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9Gcm9tICguKykkLywgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHtcbiAgICAgICAgcmVzdWx0LnJlbW90ZSA9IHJlbW90ZTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL1xcKiBcXFtuZXcgYnJhbmNoXVxccysoXFxTKylcXHMqLT4gKC4rKSQvLCAocmVzdWx0LCBbbmFtZSwgdHJhY2tpbmddKSA9PiB7XG4gICAgICAgIHJlc3VsdC5icmFuY2hlcy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHRyYWNraW5nXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXFwqIFxcW25ldyB0YWddXFxzKyhcXFMrKVxccyotPiAoLispJC8sIChyZXN1bHQsIFtuYW1lLCB0cmFja2luZ10pID0+IHtcbiAgICAgICAgcmVzdWx0LnRhZ3MucHVzaCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0cmFja2luZ1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoLy0gXFxbZGVsZXRlZF1cXHMrXFxTK1xccyotPiAoLispJC8sIChyZXN1bHQsIFt0cmFja2luZ10pID0+IHtcbiAgICAgICAgcmVzdWx0LmRlbGV0ZWQucHVzaCh7XG4gICAgICAgICAgdHJhY2tpbmdcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvXFxzKihbXi5dKylcXC5cXC4oXFxTKylcXHMrKFxcUyspXFxzKi0+ICguKykkLyxcbiAgICAgICAgKHJlc3VsdCwgW2Zyb20sIHRvLCBuYW1lLCB0cmFja2luZ10pID0+IHtcbiAgICAgICAgICByZXN1bHQudXBkYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0cmFja2luZyxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgZnJvbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvZmV0Y2gudHNcbnZhciBmZXRjaF9leHBvcnRzID0ge307XG5fX2V4cG9ydChmZXRjaF9leHBvcnRzLCB7XG4gIGZldGNoVGFzazogKCkgPT4gZmV0Y2hUYXNrXG59KTtcbmZ1bmN0aW9uIGRpc2FsbG93ZWRDb21tYW5kMihjb21tYW5kKSB7XG4gIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cbmZ1bmN0aW9uIGZldGNoVGFzayhyZW1vdGUsIGJyYW5jaCwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcImZldGNoXCIsIC4uLmN1c3RvbUFyZ3NdO1xuICBpZiAocmVtb3RlICYmIGJyYW5jaCkge1xuICAgIGNvbW1hbmRzLnB1c2gocmVtb3RlLCBicmFuY2gpO1xuICB9XG4gIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQyKTtcbiAgaWYgKGJhbm5lZCkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGBnaXQuZmV0Y2g6IHBvdGVudGlhbCBleHBsb2l0IGFyZ3VtZW50IGJsb2NrZWQuYCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHBhcnNlRmV0Y2hSZXN1bHRcbiAgfTtcbn1cbnZhciBpbml0X2ZldGNoID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvZmV0Y2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3BhcnNlX2ZldGNoKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtbW92ZS50c1xuZnVuY3Rpb24gcGFyc2VNb3ZlUmVzdWx0KHN0ZE91dCkge1xuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IG1vdmVzOiBbXSB9LCBwYXJzZXJzMTEsIHN0ZE91dCk7XG59XG52YXIgcGFyc2VyczExO1xudmFyIGluaXRfcGFyc2VfbW92ZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtbW92ZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBwYXJzZXJzMTEgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcigvXlJlbmFtaW5nICguKykgdG8gKC4rKSQvLCAocmVzdWx0LCBbZnJvbSwgdG9dKSA9PiB7XG4gICAgICAgIHJlc3VsdC5tb3Zlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL21vdmUudHNcbnZhciBtb3ZlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1vdmVfZXhwb3J0cywge1xuICBtb3ZlVGFzazogKCkgPT4gbW92ZVRhc2tcbn0pO1xuZnVuY3Rpb24gbW92ZVRhc2soZnJvbSwgdG8pIHtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kczogW1wibXZcIiwgXCItdlwiLCAuLi5hc0FycmF5KGZyb20pLCB0b10sXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiBwYXJzZU1vdmVSZXN1bHRcbiAgfTtcbn1cbnZhciBpbml0X21vdmUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9tb3ZlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9wYXJzZV9tb3ZlKCk7XG4gICAgaW5pdF91dGlscygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9wdWxsLnRzXG52YXIgcHVsbF9leHBvcnRzID0ge307XG5fX2V4cG9ydChwdWxsX2V4cG9ydHMsIHtcbiAgcHVsbFRhc2s6ICgpID0+IHB1bGxUYXNrXG59KTtcbmZ1bmN0aW9uIHB1bGxUYXNrKHJlbW90ZSwgYnJhbmNoLCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wicHVsbFwiLCAuLi5jdXN0b21BcmdzXTtcbiAgaWYgKHJlbW90ZSAmJiBicmFuY2gpIHtcbiAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgcmVtb3RlLCBicmFuY2gpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICByZXR1cm4gcGFyc2VQdWxsUmVzdWx0KHN0ZE91dCwgc3RkRXJyKTtcbiAgICB9LFxuICAgIG9uRXJyb3IocmVzdWx0LCBfZXJyb3IsIF9kb25lLCBmYWlsKSB7XG4gICAgICBjb25zdCBwdWxsRXJyb3IgPSBwYXJzZVB1bGxFcnJvclJlc3VsdChcbiAgICAgICAgYnVmZmVyVG9TdHJpbmcocmVzdWx0LnN0ZE91dCksXG4gICAgICAgIGJ1ZmZlclRvU3RyaW5nKHJlc3VsdC5zdGRFcnIpXG4gICAgICApO1xuICAgICAgaWYgKHB1bGxFcnJvcikge1xuICAgICAgICByZXR1cm4gZmFpbChuZXcgR2l0UmVzcG9uc2VFcnJvcihwdWxsRXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIGZhaWwoX2Vycm9yKTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9wdWxsID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvcHVsbC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG4gICAgaW5pdF9wYXJzZV9wdWxsKCk7XG4gICAgaW5pdF91dGlscygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvR2V0UmVtb3RlU3VtbWFyeS50c1xuZnVuY3Rpb24gcGFyc2VHZXRSZW1vdGVzKHRleHQpIHtcbiAgY29uc3QgcmVtb3RlcyA9IHt9O1xuICBmb3JFYWNoKHRleHQsIChbbmFtZV0pID0+IHJlbW90ZXNbbmFtZV0gPSB7IG5hbWUgfSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHJlbW90ZXMpO1xufVxuZnVuY3Rpb24gcGFyc2VHZXRSZW1vdGVzVmVyYm9zZSh0ZXh0KSB7XG4gIGNvbnN0IHJlbW90ZXMgPSB7fTtcbiAgZm9yRWFjaCh0ZXh0LCAoW25hbWUsIHVybCwgcHVycG9zZV0pID0+IHtcbiAgICBpZiAoIU9iamVjdC5oYXNPd24ocmVtb3RlcywgbmFtZSkpIHtcbiAgICAgIHJlbW90ZXNbbmFtZV0gPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHJlZnM6IHsgZmV0Y2g6IFwiXCIsIHB1c2g6IFwiXCIgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHB1cnBvc2UgJiYgdXJsKSB7XG4gICAgICByZW1vdGVzW25hbWVdLnJlZnNbcHVycG9zZS5yZXBsYWNlKC9bXmEtel0vZywgXCJcIildID0gdXJsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHJlbW90ZXMpO1xufVxuZnVuY3Rpb24gZm9yRWFjaCh0ZXh0LCBoYW5kbGVyKSB7XG4gIGZvckVhY2hMaW5lV2l0aENvbnRlbnQodGV4dCwgKGxpbmUpID0+IGhhbmRsZXIobGluZS5zcGxpdCgvXFxzKy8pKSk7XG59XG52YXIgaW5pdF9HZXRSZW1vdGVTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0dldFJlbW90ZVN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3JlbW90ZS50c1xudmFyIHJlbW90ZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChyZW1vdGVfZXhwb3J0cywge1xuICBhZGRSZW1vdGVUYXNrOiAoKSA9PiBhZGRSZW1vdGVUYXNrLFxuICBnZXRSZW1vdGVzVGFzazogKCkgPT4gZ2V0UmVtb3Rlc1Rhc2ssXG4gIGxpc3RSZW1vdGVzVGFzazogKCkgPT4gbGlzdFJlbW90ZXNUYXNrLFxuICByZW1vdGVUYXNrOiAoKSA9PiByZW1vdGVUYXNrLFxuICByZW1vdmVSZW1vdGVUYXNrOiAoKSA9PiByZW1vdmVSZW1vdGVUYXNrXG59KTtcbmZ1bmN0aW9uIGFkZFJlbW90ZVRhc2socmVtb3RlTmFtZSwgcmVtb3RlUmVwbywgY3VzdG9tQXJncykge1xuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbXCJyZW1vdGVcIiwgXCJhZGRcIiwgLi4uY3VzdG9tQXJncywgcmVtb3RlTmFtZSwgcmVtb3RlUmVwb10pO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3Rlc1Rhc2sodmVyYm9zZSkge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInJlbW90ZVwiXTtcbiAgaWYgKHZlcmJvc2UpIHtcbiAgICBjb21tYW5kcy5wdXNoKFwiLXZcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHZlcmJvc2UgPyBwYXJzZUdldFJlbW90ZXNWZXJib3NlIDogcGFyc2VHZXRSZW1vdGVzXG4gIH07XG59XG5mdW5jdGlvbiBsaXN0UmVtb3Rlc1Rhc2soY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFsuLi5jdXN0b21BcmdzXTtcbiAgaWYgKGNvbW1hbmRzWzBdICE9PSBcImxzLXJlbW90ZVwiKSB7XG4gICAgY29tbWFuZHMudW5zaGlmdChcImxzLXJlbW90ZVwiKTtcbiAgfVxuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5mdW5jdGlvbiByZW1vdGVUYXNrKGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbLi4uY3VzdG9tQXJnc107XG4gIGlmIChjb21tYW5kc1swXSAhPT0gXCJyZW1vdGVcIikge1xuICAgIGNvbW1hbmRzLnVuc2hpZnQoXCJyZW1vdGVcIik7XG4gIH1cbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVtb3RlVGFzayhyZW1vdGVOYW1lKSB7XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFtcInJlbW90ZVwiLCBcInJlbW92ZVwiLCByZW1vdGVOYW1lXSk7XG59XG52YXIgaW5pdF9yZW1vdGUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9yZW1vdGUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0dldFJlbW90ZVN1bW1hcnkoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3Mvc3Rhc2gtbGlzdC50c1xudmFyIHN0YXNoX2xpc3RfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3Rhc2hfbGlzdF9leHBvcnRzLCB7XG4gIHN0YXNoTGlzdFRhc2s6ICgpID0+IHN0YXNoTGlzdFRhc2tcbn0pO1xuZnVuY3Rpb24gc3Rhc2hMaXN0VGFzayhvcHQgPSB7fSwgY3VzdG9tQXJncykge1xuICBjb25zdCBvcHRpb25zID0gcGFyc2VMb2dPcHRpb25zKG9wdCk7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wic3Rhc2hcIiwgXCJsaXN0XCIsIC4uLm9wdGlvbnMuY29tbWFuZHMsIC4uLmN1c3RvbUFyZ3NdO1xuICBjb25zdCBwYXJzZXI0ID0gY3JlYXRlTGlzdExvZ1N1bW1hcnlQYXJzZXIoXG4gICAgb3B0aW9ucy5zcGxpdHRlcixcbiAgICBvcHRpb25zLmZpZWxkcyxcbiAgICBsb2dGb3JtYXRGcm9tQ29tbWFuZChjb21tYW5kcylcbiAgKTtcbiAgcmV0dXJuIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKGNvbW1hbmRzKSB8fCB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiBwYXJzZXI0XG4gIH07XG59XG52YXIgaW5pdF9zdGFzaF9saXN0ID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3Mvc3Rhc2gtbGlzdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfbG9nX2Zvcm1hdCgpO1xuICAgIGluaXRfcGFyc2VfbGlzdF9sb2dfc3VtbWFyeSgpO1xuICAgIGluaXRfZGlmZigpO1xuICAgIGluaXRfbG9nKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3N1Yi1tb2R1bGUudHNcbnZhciBzdWJfbW9kdWxlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHN1Yl9tb2R1bGVfZXhwb3J0cywge1xuICBhZGRTdWJNb2R1bGVUYXNrOiAoKSA9PiBhZGRTdWJNb2R1bGVUYXNrLFxuICBpbml0U3ViTW9kdWxlVGFzazogKCkgPT4gaW5pdFN1Yk1vZHVsZVRhc2ssXG4gIHN1Yk1vZHVsZVRhc2s6ICgpID0+IHN1Yk1vZHVsZVRhc2ssXG4gIHVwZGF0ZVN1Yk1vZHVsZVRhc2s6ICgpID0+IHVwZGF0ZVN1Yk1vZHVsZVRhc2tcbn0pO1xuZnVuY3Rpb24gYWRkU3ViTW9kdWxlVGFzayhyZXBvLCBwYXRoKSB7XG4gIHJldHVybiBzdWJNb2R1bGVUYXNrKFtcImFkZFwiLCByZXBvLCBwYXRoXSk7XG59XG5mdW5jdGlvbiBpbml0U3ViTW9kdWxlVGFzayhjdXN0b21BcmdzKSB7XG4gIHJldHVybiBzdWJNb2R1bGVUYXNrKFtcImluaXRcIiwgLi4uY3VzdG9tQXJnc10pO1xufVxuZnVuY3Rpb24gc3ViTW9kdWxlVGFzayhjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gWy4uLmN1c3RvbUFyZ3NdO1xuICBpZiAoY29tbWFuZHNbMF0gIT09IFwic3VibW9kdWxlXCIpIHtcbiAgICBjb21tYW5kcy51bnNoaWZ0KFwic3VibW9kdWxlXCIpO1xuICB9XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN1Yk1vZHVsZVRhc2soY3VzdG9tQXJncykge1xuICByZXR1cm4gc3ViTW9kdWxlVGFzayhbXCJ1cGRhdGVcIiwgLi4uY3VzdG9tQXJnc10pO1xufVxudmFyIGluaXRfc3ViX21vZHVsZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3N1Yi1tb2R1bGUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL1RhZ0xpc3QudHNcbmZ1bmN0aW9uIHNpbmdsZVNvcnRlZChhLCBiKSB7XG4gIGNvbnN0IGFJc051bSA9IE51bWJlci5pc05hTihhKTtcbiAgY29uc3QgYklzTnVtID0gTnVtYmVyLmlzTmFOKGIpO1xuICBpZiAoYUlzTnVtICE9PSBiSXNOdW0pIHtcbiAgICByZXR1cm4gYUlzTnVtID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiBhSXNOdW0gPyBzb3J0ZWQoYSwgYikgOiAwO1xufVxuZnVuY3Rpb24gc29ydGVkKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5mdW5jdGlvbiB0cmltbWVkKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC50cmltKCk7XG59XG5mdW5jdGlvbiB0b051bWJlcihpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LnJlcGxhY2UoL15cXEQrL2csIFwiXCIpLCAxMCkgfHwgMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBUYWdMaXN0LCBwYXJzZVRhZ0xpc3Q7XG52YXIgaW5pdF9UYWdMaXN0ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL1RhZ0xpc3QudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBUYWdMaXN0ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoYWxsLCBsYXRlc3QpIHtcbiAgICAgICAgdGhpcy5hbGwgPSBhbGw7XG4gICAgICAgIHRoaXMubGF0ZXN0ID0gbGF0ZXN0O1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyc2VUYWdMaXN0ID0gZnVuY3Rpb24oZGF0YSwgY3VzdG9tU29ydCA9IGZhbHNlKSB7XG4gICAgICBjb25zdCB0YWdzID0gZGF0YS5zcGxpdChcIlxcblwiKS5tYXAodHJpbW1lZCkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgaWYgKCFjdXN0b21Tb3J0KSB7XG4gICAgICAgIHRhZ3Muc29ydChmdW5jdGlvbih0YWdBLCB0YWdCKSB7XG4gICAgICAgICAgY29uc3QgcGFydHNBID0gdGFnQS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgY29uc3QgcGFydHNCID0gdGFnQi5zcGxpdChcIi5cIik7XG4gICAgICAgICAgaWYgKHBhcnRzQS5sZW5ndGggPT09IDEgfHwgcGFydHNCLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbmdsZVNvcnRlZCh0b051bWJlcihwYXJ0c0FbMF0pLCB0b051bWJlcihwYXJ0c0JbMF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBNYXRoLm1heChwYXJ0c0EubGVuZ3RoLCBwYXJ0c0IubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHNvcnRlZCh0b051bWJlcihwYXJ0c0FbaV0pLCB0b051bWJlcihwYXJ0c0JbaV0pKTtcbiAgICAgICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsYXRlc3QgPSBjdXN0b21Tb3J0ID8gdGFnc1swXSA6IFsuLi50YWdzXS5yZXZlcnNlKCkuZmluZCgodGFnKSA9PiB0YWcuaW5kZXhPZihcIi5cIikgPj0gMCk7XG4gICAgICByZXR1cm4gbmV3IFRhZ0xpc3QodGFncywgbGF0ZXN0KTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy90YWcudHNcbnZhciB0YWdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodGFnX2V4cG9ydHMsIHtcbiAgYWRkQW5ub3RhdGVkVGFnVGFzazogKCkgPT4gYWRkQW5ub3RhdGVkVGFnVGFzayxcbiAgYWRkVGFnVGFzazogKCkgPT4gYWRkVGFnVGFzayxcbiAgdGFnTGlzdFRhc2s6ICgpID0+IHRhZ0xpc3RUYXNrXG59KTtcbmZ1bmN0aW9uIHRhZ0xpc3RUYXNrKGN1c3RvbUFyZ3MgPSBbXSkge1xuICBjb25zdCBoYXNDdXN0b21Tb3J0ID0gY3VzdG9tQXJncy5zb21lKChvcHRpb24pID0+IC9eLS1zb3J0PS8udGVzdChvcHRpb24pKTtcbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBjb21tYW5kczogW1widGFnXCIsIFwiLWxcIiwgLi4uY3VzdG9tQXJnc10sXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiBwYXJzZVRhZ0xpc3QodGV4dCwgaGFzQ3VzdG9tU29ydCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWRkVGFnVGFzayhuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcInRhZ1wiLCBuYW1lXSxcbiAgICBwYXJzZXIoKSB7XG4gICAgICByZXR1cm4geyBuYW1lIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWRkQW5ub3RhdGVkVGFnVGFzayhuYW1lLCB0YWdNZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcInRhZ1wiLCBcIi1hXCIsIFwiLW1cIiwgdGFnTWVzc2FnZSwgbmFtZV0sXG4gICAgcGFyc2VyKCkge1xuICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X3RhZyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3RhZy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfVGFnTGlzdCgpO1xuICB9XG59KTtcblxuLy8gc3JjL2dpdC5qc1xudmFyIHJlcXVpcmVfZ2l0ID0gX19jb21tb25KUyh7XG4gIFwic3JjL2dpdC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IEdpdEV4ZWN1dG9yOiBHaXRFeGVjdXRvcjIgfSA9IChpbml0X2dpdF9leGVjdXRvcigpLCBfX3RvQ29tbW9uSlMoZ2l0X2V4ZWN1dG9yX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBTaW1wbGVHaXRBcGk6IFNpbXBsZUdpdEFwaTIgfSA9IChpbml0X3NpbXBsZV9naXRfYXBpKCksIF9fdG9Db21tb25KUyhzaW1wbGVfZ2l0X2FwaV9leHBvcnRzKSk7XG4gICAgdmFyIHsgU2NoZWR1bGVyOiBTY2hlZHVsZXIyIH0gPSAoaW5pdF9zY2hlZHVsZXIoKSwgX190b0NvbW1vbkpTKHNjaGVkdWxlcl9leHBvcnRzKSk7XG4gICAgdmFyIHsgY29uZmlndXJhdGlvbkVycm9yVGFzazogY29uZmlndXJhdGlvbkVycm9yVGFzazIgfSA9IChpbml0X3Rhc2soKSwgX190b0NvbW1vbkpTKHRhc2tfZXhwb3J0cykpO1xuICAgIHZhciB7XG4gICAgICBhc0FycmF5OiBhc0FycmF5MixcbiAgICAgIGZpbHRlckFycmF5OiBmaWx0ZXJBcnJheTIsXG4gICAgICBmaWx0ZXJQcmltaXRpdmVzOiBmaWx0ZXJQcmltaXRpdmVzMixcbiAgICAgIGZpbHRlclN0cmluZzogZmlsdGVyU3RyaW5nMixcbiAgICAgIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXk6IGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkyLFxuICAgICAgZmlsdGVyVHlwZTogZmlsdGVyVHlwZTIsXG4gICAgICBnZXRUcmFpbGluZ09wdGlvbnM6IGdldFRyYWlsaW5nT3B0aW9uczIsXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQ6IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIsXG4gICAgICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudDogdHJhaWxpbmdPcHRpb25zQXJndW1lbnQyXG4gICAgfSA9IChpbml0X3V0aWxzKCksIF9fdG9Db21tb25KUyh1dGlsc19leHBvcnRzKSk7XG4gICAgdmFyIHsgYXBwbHlQYXRjaFRhc2s6IGFwcGx5UGF0Y2hUYXNrMiB9ID0gKGluaXRfYXBwbHlfcGF0Y2goKSwgX190b0NvbW1vbkpTKGFwcGx5X3BhdGNoX2V4cG9ydHMpKTtcbiAgICB2YXIge1xuICAgICAgYnJhbmNoVGFzazogYnJhbmNoVGFzazIsXG4gICAgICBicmFuY2hMb2NhbFRhc2s6IGJyYW5jaExvY2FsVGFzazIsXG4gICAgICBkZWxldGVCcmFuY2hlc1Rhc2s6IGRlbGV0ZUJyYW5jaGVzVGFzazIsXG4gICAgICBkZWxldGVCcmFuY2hUYXNrOiBkZWxldGVCcmFuY2hUYXNrMlxuICAgIH0gPSAoaW5pdF9icmFuY2goKSwgX190b0NvbW1vbkpTKGJyYW5jaF9leHBvcnRzKSk7XG4gICAgdmFyIHsgY2hlY2tJZ25vcmVUYXNrOiBjaGVja0lnbm9yZVRhc2syIH0gPSAoaW5pdF9jaGVja19pZ25vcmUoKSwgX190b0NvbW1vbkpTKGNoZWNrX2lnbm9yZV9leHBvcnRzKSk7XG4gICAgdmFyIHsgY2hlY2tJc1JlcG9UYXNrOiBjaGVja0lzUmVwb1Rhc2syIH0gPSAoaW5pdF9jaGVja19pc19yZXBvKCksIF9fdG9Db21tb25KUyhjaGVja19pc19yZXBvX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBjbG9uZVRhc2s6IGNsb25lVGFzazIsIGNsb25lTWlycm9yVGFzazogY2xvbmVNaXJyb3JUYXNrMiB9ID0gKGluaXRfY2xvbmUoKSwgX190b0NvbW1vbkpTKGNsb25lX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBjbGVhbldpdGhPcHRpb25zVGFzazogY2xlYW5XaXRoT3B0aW9uc1Rhc2syLCBpc0NsZWFuT3B0aW9uc0FycmF5OiBpc0NsZWFuT3B0aW9uc0FycmF5MiB9ID0gKGluaXRfY2xlYW4oKSwgX190b0NvbW1vbkpTKGNsZWFuX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBkaWZmU3VtbWFyeVRhc2s6IGRpZmZTdW1tYXJ5VGFzazIgfSA9IChpbml0X2RpZmYoKSwgX190b0NvbW1vbkpTKGRpZmZfZXhwb3J0cykpO1xuICAgIHZhciB7IGZldGNoVGFzazogZmV0Y2hUYXNrMiB9ID0gKGluaXRfZmV0Y2goKSwgX190b0NvbW1vbkpTKGZldGNoX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBtb3ZlVGFzazogbW92ZVRhc2syIH0gPSAoaW5pdF9tb3ZlKCksIF9fdG9Db21tb25KUyhtb3ZlX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBwdWxsVGFzazogcHVsbFRhc2syIH0gPSAoaW5pdF9wdWxsKCksIF9fdG9Db21tb25KUyhwdWxsX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBwdXNoVGFnc1Rhc2s6IHB1c2hUYWdzVGFzazIgfSA9IChpbml0X3B1c2goKSwgX190b0NvbW1vbkpTKHB1c2hfZXhwb3J0cykpO1xuICAgIHZhciB7XG4gICAgICBhZGRSZW1vdGVUYXNrOiBhZGRSZW1vdGVUYXNrMixcbiAgICAgIGdldFJlbW90ZXNUYXNrOiBnZXRSZW1vdGVzVGFzazIsXG4gICAgICBsaXN0UmVtb3Rlc1Rhc2s6IGxpc3RSZW1vdGVzVGFzazIsXG4gICAgICByZW1vdGVUYXNrOiByZW1vdGVUYXNrMixcbiAgICAgIHJlbW92ZVJlbW90ZVRhc2s6IHJlbW92ZVJlbW90ZVRhc2syXG4gICAgfSA9IChpbml0X3JlbW90ZSgpLCBfX3RvQ29tbW9uSlMocmVtb3RlX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBnZXRSZXNldE1vZGU6IGdldFJlc2V0TW9kZTIsIHJlc2V0VGFzazogcmVzZXRUYXNrMiB9ID0gKGluaXRfcmVzZXQoKSwgX190b0NvbW1vbkpTKHJlc2V0X2V4cG9ydHMpKTtcbiAgICB2YXIgeyBzdGFzaExpc3RUYXNrOiBzdGFzaExpc3RUYXNrMiB9ID0gKGluaXRfc3Rhc2hfbGlzdCgpLCBfX3RvQ29tbW9uSlMoc3Rhc2hfbGlzdF9leHBvcnRzKSk7XG4gICAgdmFyIHtcbiAgICAgIGFkZFN1Yk1vZHVsZVRhc2s6IGFkZFN1Yk1vZHVsZVRhc2syLFxuICAgICAgaW5pdFN1Yk1vZHVsZVRhc2s6IGluaXRTdWJNb2R1bGVUYXNrMixcbiAgICAgIHN1Yk1vZHVsZVRhc2s6IHN1Yk1vZHVsZVRhc2syLFxuICAgICAgdXBkYXRlU3ViTW9kdWxlVGFzazogdXBkYXRlU3ViTW9kdWxlVGFzazJcbiAgICB9ID0gKGluaXRfc3ViX21vZHVsZSgpLCBfX3RvQ29tbW9uSlMoc3ViX21vZHVsZV9leHBvcnRzKSk7XG4gICAgdmFyIHsgYWRkQW5ub3RhdGVkVGFnVGFzazogYWRkQW5ub3RhdGVkVGFnVGFzazIsIGFkZFRhZ1Rhc2s6IGFkZFRhZ1Rhc2syLCB0YWdMaXN0VGFzazogdGFnTGlzdFRhc2syIH0gPSAoaW5pdF90YWcoKSwgX190b0NvbW1vbkpTKHRhZ19leHBvcnRzKSk7XG4gICAgdmFyIHsgc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzazogc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzazIsIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2s6IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syIH0gPSAoaW5pdF90YXNrKCksIF9fdG9Db21tb25KUyh0YXNrX2V4cG9ydHMpKTtcbiAgICBmdW5jdGlvbiBHaXQyKG9wdGlvbnMsIHBsdWdpbnMpIHtcbiAgICAgIHRoaXMuX3BsdWdpbnMgPSBwbHVnaW5zO1xuICAgICAgdGhpcy5fZXhlY3V0b3IgPSBuZXcgR2l0RXhlY3V0b3IyKFxuICAgICAgICBvcHRpb25zLmJhc2VEaXIsXG4gICAgICAgIG5ldyBTY2hlZHVsZXIyKG9wdGlvbnMubWF4Q29uY3VycmVudFByb2Nlc3NlcyksXG4gICAgICAgIHBsdWdpbnNcbiAgICAgICk7XG4gICAgICB0aGlzLl90cmltbWVkID0gb3B0aW9ucy50cmltbWVkO1xuICAgIH1cbiAgICAoR2l0Mi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNpbXBsZUdpdEFwaTIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBHaXQyO1xuICAgIEdpdDIucHJvdG90eXBlLmN1c3RvbUJpbmFyeSA9IGZ1bmN0aW9uKGNvbW1hbmQpIHtcbiAgICAgIHRoaXMuX3BsdWdpbnMucmVjb25maWd1cmUoXCJiaW5hcnlcIiwgY29tbWFuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmVudiA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGlzLl9leGVjdXRvci5lbnYgPSBuYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHRoaXMuX2V4ZWN1dG9yLmVudiA9IHRoaXMuX2V4ZWN1dG9yLmVudiB8fCB7fSlbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuc3Rhc2hMaXN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0YXNoTGlzdFRhc2syKFxuICAgICAgICAgIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50Mihhcmd1bWVudHMpIHx8IHt9LFxuICAgICAgICAgIGZpbHRlckFycmF5MihvcHRpb25zKSAmJiBvcHRpb25zIHx8IFtdXG4gICAgICAgICksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNsb25lVGFzayhhcGksIHRhc2ssIHJlcG9QYXRoLCBsb2NhbFBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVwb1BhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2syKGBnaXQuJHthcGl9KCkgcmVxdWlyZXMgYSBzdHJpbmcgJ3JlcG9QYXRoJ2ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhc2socmVwb1BhdGgsIGZpbHRlclR5cGUyKGxvY2FsUGF0aCwgZmlsdGVyU3RyaW5nMiksIGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSk7XG4gICAgfVxuICAgIEdpdDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgY3JlYXRlQ2xvbmVUYXNrKFwiY2xvbmVcIiwgY2xvbmVUYXNrMiwgLi4uYXJndW1lbnRzKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUubWlycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgY3JlYXRlQ2xvbmVUYXNrKFwibWlycm9yXCIsIGNsb25lTWlycm9yVGFzazIsIC4uLmFyZ3VtZW50cyksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLm12ID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKG1vdmVUYXNrMihmcm9tLCB0byksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5jaGVja291dExhdGVzdFRhZyA9IGZ1bmN0aW9uKHRoZW4pIHtcbiAgICAgIHZhciBnaXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMucHVsbChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2l0LnRhZ3MoZnVuY3Rpb24oZXJyLCB0YWdzKSB7XG4gICAgICAgICAgZ2l0LmNoZWNrb3V0KHRhZ3MubGF0ZXN0LCB0aGVuKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnB1bGwgPSBmdW5jdGlvbihyZW1vdGUsIGJyYW5jaCwgb3B0aW9ucywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHB1bGxUYXNrMihcbiAgICAgICAgICBmaWx0ZXJUeXBlMihyZW1vdGUsIGZpbHRlclN0cmluZzIpLFxuICAgICAgICAgIGZpbHRlclR5cGUyKGJyYW5jaCwgZmlsdGVyU3RyaW5nMiksXG4gICAgICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpXG4gICAgICAgICksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24ocmVtb3RlLCBicmFuY2gpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBmZXRjaFRhc2syKFxuICAgICAgICAgIGZpbHRlclR5cGUyKHJlbW90ZSwgZmlsdGVyU3RyaW5nMiksXG4gICAgICAgICAgZmlsdGVyVHlwZTIoYnJhbmNoLCBmaWx0ZXJTdHJpbmcyKSxcbiAgICAgICAgICBnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cylcbiAgICAgICAgKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuc2lsZW50ID0gZnVuY3Rpb24oc2lsZW5jZSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcInNpbXBsZS1naXQgZGVwcmVjYXRpb24gbm90aWNlOiBnaXQuc2lsZW50OiBsb2dnaW5nIHNob3VsZCBiZSBjb25maWd1cmVkIHVzaW5nIHRoZSBgZGVidWdgIGxpYnJhcnkgLyBgREVCVUdgIGVudmlyb25tZW50IHZhcmlhYmxlLCB0aGlzIHdpbGwgYmUgYW4gZXJyb3IgaW4gdmVyc2lvbiAzXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnRhZ3MgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgdGFnTGlzdFRhc2syKGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJlYmFzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKFtcInJlYmFzZVwiLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cyldKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihtb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgcmVzZXRUYXNrMihnZXRSZXNldE1vZGUyKG1vZGUpLCBnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cykpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb21taXQpIHtcbiAgICAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cyk7XG4gICAgICBpZiAodHlwZW9mIGNvbW1pdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhjb25maWd1cmF0aW9uRXJyb3JUYXNrMihcIkNvbW1pdCBtdXN0IGJlIGEgc3RyaW5nXCIpLCBuZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihbXCJyZXZlcnRcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMsIDAsIHRydWUpLCBjb21taXRdKSxcbiAgICAgICAgbmV4dFxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmFkZFRhZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGNvbnN0IHRhc2sgPSB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IGFkZFRhZ1Rhc2syKG5hbWUpIDogY29uZmlndXJhdGlvbkVycm9yVGFzazIoXCJHaXQuYWRkVGFnIHJlcXVpcmVzIGEgdGFnIG5hbWVcIik7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuYWRkQW5ub3RhdGVkVGFnID0gZnVuY3Rpb24odGFnTmFtZSwgdGFnTWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGFkZEFubm90YXRlZFRhZ1Rhc2syKHRhZ05hbWUsIHRhZ01lc3NhZ2UpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5kZWxldGVMb2NhbEJyYW5jaCA9IGZ1bmN0aW9uKGJyYW5jaE5hbWUsIGZvcmNlRGVsZXRlLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgZGVsZXRlQnJhbmNoVGFzazIoYnJhbmNoTmFtZSwgdHlwZW9mIGZvcmNlRGVsZXRlID09PSBcImJvb2xlYW5cIiA/IGZvcmNlRGVsZXRlIDogZmFsc2UpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5kZWxldGVMb2NhbEJyYW5jaGVzID0gZnVuY3Rpb24oYnJhbmNoTmFtZXMsIGZvcmNlRGVsZXRlLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgZGVsZXRlQnJhbmNoZXNUYXNrMihicmFuY2hOYW1lcywgdHlwZW9mIGZvcmNlRGVsZXRlID09PSBcImJvb2xlYW5cIiA/IGZvcmNlRGVsZXRlIDogZmFsc2UpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5icmFuY2ggPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgYnJhbmNoVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuYnJhbmNoTG9jYWwgPSBmdW5jdGlvbih0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhicmFuY2hMb2NhbFRhc2syKCksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbihjb21tYW5kcykge1xuICAgICAgY29uc3QgY3JlYXRlUmVzdENvbW1hbmRzID0gIUFycmF5LmlzQXJyYXkoY29tbWFuZHMpO1xuICAgICAgY29uc3QgY29tbWFuZCA9IFtdLnNsaWNlLmNhbGwoY3JlYXRlUmVzdENvbW1hbmRzID8gYXJndW1lbnRzIDogY29tbWFuZHMsIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kLmxlbmd0aCAmJiBjcmVhdGVSZXN0Q29tbWFuZHM7IGkrKykge1xuICAgICAgICBpZiAoIWZpbHRlclByaW1pdGl2ZXMyKGNvbW1hbmRbaV0pKSB7XG4gICAgICAgICAgY29tbWFuZC5zcGxpY2UoaSwgY29tbWFuZC5sZW5ndGggLSBpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29tbWFuZC5wdXNoKC4uLmdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzLCAwLCB0cnVlKSk7XG4gICAgICB2YXIgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKTtcbiAgICAgIGlmICghY29tbWFuZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzazIoXCJSYXc6IG11c3Qgc3VwcGx5IG9uZSBvciBtb3JlIGNvbW1hbmQgdG8gZXhlY3V0ZVwiKSxcbiAgICAgICAgICBuZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihjb21tYW5kLCB0aGlzLl90cmltbWVkKSwgbmV4dCk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5zdWJtb2R1bGVBZGQgPSBmdW5jdGlvbihyZXBvLCBwYXRoLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhhZGRTdWJNb2R1bGVUYXNrMihyZXBvLCBwYXRoKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnN1Ym1vZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uKGFyZ3MsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICB1cGRhdGVTdWJNb2R1bGVUYXNrMihnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cywgdHJ1ZSkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5zdWJtb2R1bGVJbml0ID0gZnVuY3Rpb24oYXJncywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGluaXRTdWJNb2R1bGVUYXNrMihnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cywgdHJ1ZSkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5zdWJNb2R1bGUgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3ViTW9kdWxlVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUubGlzdFJlbW90ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGxpc3RSZW1vdGVzVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuYWRkUmVtb3RlID0gZnVuY3Rpb24ocmVtb3RlTmFtZSwgcmVtb3RlUmVwbywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGFkZFJlbW90ZVRhc2syKHJlbW90ZU5hbWUsIHJlbW90ZVJlcG8sIGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJlbW92ZVJlbW90ZSA9IGZ1bmN0aW9uKHJlbW90ZU5hbWUsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHJlbW92ZVJlbW90ZVRhc2syKHJlbW90ZU5hbWUpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuZ2V0UmVtb3RlcyA9IGZ1bmN0aW9uKHZlcmJvc2UsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGdldFJlbW90ZXNUYXNrMih2ZXJib3NlID09PSB0cnVlKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJlbW90ZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICByZW1vdGVUYXNrMihnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cykpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS50YWcgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICBjb25zdCBjb21tYW5kID0gZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpO1xuICAgICAgaWYgKGNvbW1hbmRbMF0gIT09IFwidGFnXCIpIHtcbiAgICAgICAgY29tbWFuZC51bnNoaWZ0KFwidGFnXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoY29tbWFuZCksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS51cGRhdGVTZXJ2ZXJJbmZvID0gZnVuY3Rpb24odGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKFtcInVwZGF0ZS1zZXJ2ZXItaW5mb1wiXSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnB1c2hUYWdzID0gZnVuY3Rpb24ocmVtb3RlLCB0aGVuKSB7XG4gICAgICBjb25zdCB0YXNrID0gcHVzaFRhZ3NUYXNrMihcbiAgICAgICAgeyByZW1vdGU6IGZpbHRlclR5cGUyKHJlbW90ZSwgZmlsdGVyU3RyaW5nMikgfSxcbiAgICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJtID0gZnVuY3Rpb24oZmlsZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihbXCJybVwiLCBcIi1mXCIsIC4uLmFzQXJyYXkyKGZpbGVzKV0pLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5ybUtlZXBMb2NhbCA9IGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoW1wicm1cIiwgXCItLWNhY2hlZFwiLCAuLi5hc0FycmF5MihmaWxlcyldKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuY2F0RmlsZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYXRGaWxlKFwidXRmLThcIiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmJpbmFyeUNhdEZpbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYXRGaWxlKFwiYnVmZmVyXCIsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5fY2F0RmlsZSA9IGZ1bmN0aW9uKGZvcm1hdCwgYXJncykge1xuICAgICAgdmFyIGhhbmRsZXIgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3MpO1xuICAgICAgdmFyIGNvbW1hbmQgPSBbXCJjYXQtZmlsZVwiXTtcbiAgICAgIHZhciBvcHRpb25zID0gYXJnc1swXTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrMihcIkdpdC5jYXRGaWxlOiBvcHRpb25zIG11c3QgYmUgc3VwcGxpZWQgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1wiKSxcbiAgICAgICAgICBoYW5kbGVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBjb21tYW5kLnB1c2guYXBwbHkoY29tbWFuZCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXNrID0gZm9ybWF0ID09PSBcImJ1ZmZlclwiID8gc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzazIoY29tbWFuZCkgOiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihjb21tYW5kKTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIGhhbmRsZXIpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRoZW4pIHtcbiAgICAgIGNvbnN0IHRhc2sgPSBmaWx0ZXJTdHJpbmcyKG9wdGlvbnMpID8gY29uZmlndXJhdGlvbkVycm9yVGFzazIoXG4gICAgICAgIFwiZ2l0LmRpZmY6IHN1cHBseWluZyBvcHRpb25zIGFzIGEgc2luZ2xlIHN0cmluZyBpcyBubyBsb25nZXIgc3VwcG9ydGVkLCBzd2l0Y2ggdG8gYW4gYXJyYXkgb2Ygc3RyaW5nc1wiXG4gICAgICApIDogc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoW1wiZGlmZlwiLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cyldKTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5kaWZmU3VtbWFyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGRpZmZTdW1tYXJ5VGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMsIDEpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuYXBwbHlQYXRjaCA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgICAgIGNvbnN0IHRhc2sgPSAhZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheTIocGF0Y2hlcykgPyBjb25maWd1cmF0aW9uRXJyb3JUYXNrMihcbiAgICAgICAgYGdpdC5hcHBseVBhdGNoIHJlcXVpcmVzIG9uZSBvciBtb3JlIHN0cmluZyBwYXRjaGVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudGBcbiAgICAgICkgOiBhcHBseVBhdGNoVGFzazIoYXNBcnJheTIocGF0Y2hlcyksIGdldFRyYWlsaW5nT3B0aW9uczIoW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUucmV2cGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGNvbW1hbmRzID0gW1wicmV2LXBhcnNlXCIsIC4uLmdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzLCB0cnVlKV07XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoY29tbWFuZHMsIHRydWUpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKG1vZGUsIG9wdGlvbnMsIHRoZW4pIHtcbiAgICAgIGNvbnN0IHVzaW5nQ2xlYW5PcHRpb25zQXJyYXkgPSBpc0NsZWFuT3B0aW9uc0FycmF5Mihtb2RlKTtcbiAgICAgIGNvbnN0IGNsZWFuTW9kZSA9IHVzaW5nQ2xlYW5PcHRpb25zQXJyYXkgJiYgbW9kZS5qb2luKFwiXCIpIHx8IGZpbHRlclR5cGUyKG1vZGUsIGZpbHRlclN0cmluZzIpIHx8IFwiXCI7XG4gICAgICBjb25zdCBjdXN0b21BcmdzID0gZ2V0VHJhaWxpbmdPcHRpb25zMihbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgdXNpbmdDbGVhbk9wdGlvbnNBcnJheSA/IDEgOiAwKSk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgY2xlYW5XaXRoT3B0aW9uc1Rhc2syKGNsZWFuTW9kZSwgY3VzdG9tQXJncyksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbih0aGVuKSB7XG4gICAgICBjb25zdCB0YXNrID0ge1xuICAgICAgICBjb21tYW5kczogW10sXG4gICAgICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgICAgICBwYXJzZXIoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmNsZWFyUXVldWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuY2hlY2tJZ25vcmUgPSBmdW5jdGlvbihwYXRobmFtZXMsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBjaGVja0lnbm9yZVRhc2syKGFzQXJyYXkyKGZpbHRlclR5cGUyKHBhdGhuYW1lcywgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheTIsIFtdKSkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5jaGVja0lzUmVwbyA9IGZ1bmN0aW9uKGNoZWNrVHlwZSwgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNoZWNrSXNSZXBvVGFzazIoZmlsdGVyVHlwZTIoY2hlY2tUeXBlLCBmaWx0ZXJTdHJpbmcyKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gR2l0MjtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXBpLnRzXG5pbml0X3BhdGhzcGVjKCk7XG5cbi8vIHNyYy9saWIvZXJyb3JzL2dpdC1jb25zdHJ1Y3QtZXJyb3IudHNcbmluaXRfZ2l0X2Vycm9yKCk7XG52YXIgR2l0Q29uc3RydWN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEdpdEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIodm9pZCAwLCBtZXNzYWdlKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9hcGkudHNcbmluaXRfZ2l0X2Vycm9yKCk7XG5cbi8vIHNyYy9saWIvZXJyb3JzL2dpdC1wbHVnaW4tZXJyb3IudHNcbmluaXRfZ2l0X2Vycm9yKCk7XG52YXIgR2l0UGx1Z2luRXJyb3IgPSBjbGFzcyBleHRlbmRzIEdpdEVycm9yIHtcbiAgY29uc3RydWN0b3IodGFzaywgcGx1Z2luLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIodGFzaywgbWVzc2FnZSk7XG4gICAgdGhpcy50YXNrID0gdGFzaztcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL2FwaS50c1xuaW5pdF9naXRfcmVzcG9uc2VfZXJyb3IoKTtcbmluaXRfdGFza19jb25maWd1cmF0aW9uX2Vycm9yKCk7XG5pbml0X2NoZWNrX2lzX3JlcG8oKTtcbmluaXRfY2xlYW4oKTtcbmluaXRfY29uZmlnKCk7XG5pbml0X2RpZmZfbmFtZV9zdGF0dXMoKTtcbmluaXRfZ3JlcCgpO1xuaW5pdF9yZXNldCgpO1xuXG4vLyBzcmMvbGliL3BsdWdpbnMvYWJvcnQtcGx1Z2luLnRzXG5mdW5jdGlvbiBhYm9ydFBsdWdpbihzaWduYWwpIHtcbiAgaWYgKCFzaWduYWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb25TcGF3bkFmdGVyID0ge1xuICAgIHR5cGU6IFwic3Bhd24uYWZ0ZXJcIixcbiAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgIGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgIGNvbnRleHQua2lsbChuZXcgR2l0UGx1Z2luRXJyb3Iodm9pZCAwLCBcImFib3J0XCIsIFwiQWJvcnQgc2lnbmFsIHJlY2VpdmVkXCIpKTtcbiAgICAgIH1cbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwga2lsbCk7XG4gICAgICBjb250ZXh0LnNwYXduZWQub24oXCJjbG9zZVwiLCAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGtpbGwpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9uU3Bhd25CZWZvcmUgPSB7XG4gICAgdHlwZTogXCJzcGF3bi5iZWZvcmVcIixcbiAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHZvaWQgMCwgXCJhYm9ydFwiLCBcIkFib3J0IGFscmVhZHkgc2lnbmFsZWRcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtvblNwYXduQmVmb3JlLCBvblNwYXduQWZ0ZXJdO1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvYmxvY2stdW5zYWZlLW9wZXJhdGlvbnMtcGx1Z2luLnRzXG5mdW5jdGlvbiBpc0NvbmZpZ1N3aXRjaChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgJiYgYXJnLnRyaW0oKS50b0xvd2VyQ2FzZSgpID09PSBcIi1jXCI7XG59XG5mdW5jdGlvbiBwcmV2ZW50UHJvdG9jb2xPdmVycmlkZShhcmcsIG5leHQpIHtcbiAgaWYgKCFpc0NvbmZpZ1N3aXRjaChhcmcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghL15cXHMqcHJvdG9jb2woLlthLXpdKyk/LmFsbG93Ly50ZXN0KG5leHQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICB2b2lkIDAsXG4gICAgXCJ1bnNhZmVcIixcbiAgICBcIkNvbmZpZ3VyaW5nIHByb3RvY29sLmFsbG93IGlzIG5vdCBwZXJtaXR0ZWQgd2l0aG91dCBlbmFibGluZyBhbGxvd1Vuc2FmZUV4dFByb3RvY29sXCJcbiAgKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRVcGxvYWRQYWNrKGFyZywgbWV0aG9kKSB7XG4gIGlmICgvXlxccyotLSh1cGxvYWR8cmVjZWl2ZSktcGFjay8udGVzdChhcmcpKSB7XG4gICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgdm9pZCAwLFxuICAgICAgXCJ1bnNhZmVcIixcbiAgICAgIGBVc2Ugb2YgLS11cGxvYWQtcGFjayBvciAtLXJlY2VpdmUtcGFjayBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICk7XG4gIH1cbiAgaWYgKG1ldGhvZCA9PT0gXCJjbG9uZVwiICYmIC9eXFxzKi11XFxiLy50ZXN0KGFyZykpIHtcbiAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IoXG4gICAgICB2b2lkIDAsXG4gICAgICBcInVuc2FmZVwiLFxuICAgICAgYFVzZSBvZiBjbG9uZSB3aXRoIG9wdGlvbiAtdSBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICk7XG4gIH1cbiAgaWYgKG1ldGhvZCA9PT0gXCJwdXNoXCIgJiYgL15cXHMqLS1leGVjXFxiLy50ZXN0KGFyZykpIHtcbiAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IoXG4gICAgICB2b2lkIDAsXG4gICAgICBcInVuc2FmZVwiLFxuICAgICAgYFVzZSBvZiBwdXNoIHdpdGggb3B0aW9uIC0tZXhlYyBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJsb2NrVW5zYWZlT3BlcmF0aW9uc1BsdWdpbih7XG4gIGFsbG93VW5zYWZlUHJvdG9jb2xPdmVycmlkZSA9IGZhbHNlLFxuICBhbGxvd1Vuc2FmZVBhY2sgPSBmYWxzZVxufSA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzcGF3bi5hcmdzXCIsXG4gICAgYWN0aW9uKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGFyZ3MuZm9yRWFjaCgoY3VycmVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGluZGV4IDwgYXJncy5sZW5ndGggPyBhcmdzW2luZGV4ICsgMV0gOiBcIlwiO1xuICAgICAgICBhbGxvd1Vuc2FmZVByb3RvY29sT3ZlcnJpZGUgfHwgcHJldmVudFByb3RvY29sT3ZlcnJpZGUoY3VycmVudCwgbmV4dCk7XG4gICAgICAgIGFsbG93VW5zYWZlUGFjayB8fCBwcmV2ZW50VXBsb2FkUGFjayhjdXJyZW50LCBjb250ZXh0Lm1ldGhvZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL2NvbW1hbmQtY29uZmlnLXByZWZpeGluZy1wbHVnaW4udHNcbmluaXRfdXRpbHMoKTtcbmZ1bmN0aW9uIGNvbW1hbmRDb25maWdQcmVmaXhpbmdQbHVnaW4oY29uZmlndXJhdGlvbikge1xuICBjb25zdCBwcmVmaXggPSBwcmVmaXhlZEFycmF5KGNvbmZpZ3VyYXRpb24sIFwiLWNcIik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzcGF3bi5hcmdzXCIsXG4gICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBbLi4ucHJlZml4LCAuLi5kYXRhXTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy9jb21wbGV0aW9uLWRldGVjdGlvbi5wbHVnaW4udHNcbmluaXRfdXRpbHMoKTtcbmltcG9ydCB7IGRlZmVycmVkIH0gZnJvbSBcIkBrd3NpdGVzL3Byb21pc2UtZGVmZXJyZWRcIjtcbnZhciBuZXZlciA9IGRlZmVycmVkKCkucHJvbWlzZTtcbmZ1bmN0aW9uIGNvbXBsZXRpb25EZXRlY3Rpb25QbHVnaW4oe1xuICBvbkNsb3NlID0gdHJ1ZSxcbiAgb25FeGl0ID0gNTBcbn0gPSB7fSkge1xuICBmdW5jdGlvbiBjcmVhdGVFdmVudHMoKSB7XG4gICAgbGV0IGV4aXRDb2RlID0gLTE7XG4gICAgY29uc3QgZXZlbnRzID0ge1xuICAgICAgY2xvc2U6IGRlZmVycmVkKCksXG4gICAgICBjbG9zZVRpbWVvdXQ6IGRlZmVycmVkKCksXG4gICAgICBleGl0OiBkZWZlcnJlZCgpLFxuICAgICAgZXhpdFRpbWVvdXQ6IGRlZmVycmVkKClcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IFByb21pc2UucmFjZShbXG4gICAgICBvbkNsb3NlID09PSBmYWxzZSA/IG5ldmVyIDogZXZlbnRzLmNsb3NlVGltZW91dC5wcm9taXNlLFxuICAgICAgb25FeGl0ID09PSBmYWxzZSA/IG5ldmVyIDogZXZlbnRzLmV4aXRUaW1lb3V0LnByb21pc2VcbiAgICBdKTtcbiAgICBjb25maWd1cmVUaW1lb3V0KG9uQ2xvc2UsIGV2ZW50cy5jbG9zZSwgZXZlbnRzLmNsb3NlVGltZW91dCk7XG4gICAgY29uZmlndXJlVGltZW91dChvbkV4aXQsIGV2ZW50cy5leGl0LCBldmVudHMuZXhpdFRpbWVvdXQpO1xuICAgIHJldHVybiB7XG4gICAgICBjbG9zZShjb2RlKSB7XG4gICAgICAgIGV4aXRDb2RlID0gY29kZTtcbiAgICAgICAgZXZlbnRzLmNsb3NlLmRvbmUoKTtcbiAgICAgIH0sXG4gICAgICBleGl0KGNvZGUpIHtcbiAgICAgICAgZXhpdENvZGUgPSBjb2RlO1xuICAgICAgICBldmVudHMuZXhpdC5kb25lKCk7XG4gICAgICB9LFxuICAgICAgZ2V0IGV4aXRDb2RlKCkge1xuICAgICAgICByZXR1cm4gZXhpdENvZGU7XG4gICAgICB9LFxuICAgICAgcmVzdWx0XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjb25maWd1cmVUaW1lb3V0KGZsYWcsIGV2ZW50LCB0aW1lb3V0KSB7XG4gICAgaWYgKGZsYWcgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIChmbGFnID09PSB0cnVlID8gZXZlbnQucHJvbWlzZSA6IGV2ZW50LnByb21pc2UudGhlbigoKSA9PiBkZWxheShmbGFnKSkpLnRoZW4odGltZW91dC5kb25lKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3Bhd24uYWZ0ZXJcIixcbiAgICBhc3luYyBhY3Rpb24oX2RhdGEsIHsgc3Bhd25lZCwgY2xvc2UgfSkge1xuICAgICAgY29uc3QgZXZlbnRzID0gY3JlYXRlRXZlbnRzKCk7XG4gICAgICBsZXQgZGVmZXJDbG9zZSA9IHRydWU7XG4gICAgICBsZXQgcXVpY2tDbG9zZSA9ICgpID0+IHZvaWQgKGRlZmVyQ2xvc2UgPSBmYWxzZSk7XG4gICAgICBzcGF3bmVkLnN0ZG91dD8ub24oXCJkYXRhXCIsIHF1aWNrQ2xvc2UpO1xuICAgICAgc3Bhd25lZC5zdGRlcnI/Lm9uKFwiZGF0YVwiLCBxdWlja0Nsb3NlKTtcbiAgICAgIHNwYXduZWQub24oXCJlcnJvclwiLCBxdWlja0Nsb3NlKTtcbiAgICAgIHNwYXduZWQub24oXCJjbG9zZVwiLCAoY29kZSkgPT4gZXZlbnRzLmNsb3NlKGNvZGUpKTtcbiAgICAgIHNwYXduZWQub24oXCJleGl0XCIsIChjb2RlKSA9PiBldmVudHMuZXhpdChjb2RlKSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBldmVudHMucmVzdWx0O1xuICAgICAgICBpZiAoZGVmZXJDbG9zZSkge1xuICAgICAgICAgIGF3YWl0IGRlbGF5KDUwKTtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZShldmVudHMuZXhpdENvZGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNsb3NlKGV2ZW50cy5leGl0Q29kZSwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy9jdXN0b20tYmluYXJ5LnBsdWdpbi50c1xuaW5pdF91dGlscygpO1xudmFyIFdST05HX05VTUJFUl9FUlIgPSBgSW52YWxpZCB2YWx1ZSBzdXBwbGllZCBmb3IgY3VzdG9tIGJpbmFyeSwgcmVxdWlyZXMgYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgZWl0aGVyIG9uZSBvciB0d28gc3RyaW5nc2A7XG52YXIgV1JPTkdfQ0hBUlNfRVJSID0gYEludmFsaWQgdmFsdWUgc3VwcGxpZWQgZm9yIGN1c3RvbSBiaW5hcnksIHJlc3RyaWN0ZWQgY2hhcmFjdGVycyBtdXN0IGJlIHJlbW92ZWQgb3Igc3VwcGx5IHRoZSB1bnNhZmUuYWxsb3dVbnNhZmVDdXN0b21CaW5hcnkgb3B0aW9uYDtcbmZ1bmN0aW9uIGlzQmFkQXJndW1lbnQoYXJnKSB7XG4gIHJldHVybiAhYXJnIHx8ICEvXihbYS16XTopPyhbYS16MC05Ly5cXFxcXy1dKykkL2kudGVzdChhcmcpO1xufVxuZnVuY3Rpb24gdG9CaW5hcnlDb25maWcoaW5wdXQsIGFsbG93VW5zYWZlKSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPCAxIHx8IGlucHV0Lmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3Iodm9pZCAwLCBcImJpbmFyeVwiLCBXUk9OR19OVU1CRVJfRVJSKTtcbiAgfVxuICBjb25zdCBpc0JhZCA9IGlucHV0LnNvbWUoaXNCYWRBcmd1bWVudCk7XG4gIGlmIChpc0JhZCkge1xuICAgIGlmIChhbGxvd1Vuc2FmZSkge1xuICAgICAgY29uc29sZS53YXJuKFdST05HX0NIQVJTX0VSUik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcih2b2lkIDAsIFwiYmluYXJ5XCIsIFdST05HX0NIQVJTX0VSUik7XG4gICAgfVxuICB9XG4gIGNvbnN0IFtiaW5hcnksIHByZWZpeF0gPSBpbnB1dDtcbiAgcmV0dXJuIHtcbiAgICBiaW5hcnksXG4gICAgcHJlZml4XG4gIH07XG59XG5mdW5jdGlvbiBjdXN0b21CaW5hcnlQbHVnaW4ocGx1Z2lucywgaW5wdXQgPSBbXCJnaXRcIl0sIGFsbG93VW5zYWZlID0gZmFsc2UpIHtcbiAgbGV0IGNvbmZpZyA9IHRvQmluYXJ5Q29uZmlnKGFzQXJyYXkoaW5wdXQpLCBhbGxvd1Vuc2FmZSk7XG4gIHBsdWdpbnMub24oXCJiaW5hcnlcIiwgKGlucHV0MikgPT4ge1xuICAgIGNvbmZpZyA9IHRvQmluYXJ5Q29uZmlnKGFzQXJyYXkoaW5wdXQyKSwgYWxsb3dVbnNhZmUpO1xuICB9KTtcbiAgcGx1Z2lucy5hcHBlbmQoXCJzcGF3bi5iaW5hcnlcIiwgKCkgPT4ge1xuICAgIHJldHVybiBjb25maWcuYmluYXJ5O1xuICB9KTtcbiAgcGx1Z2lucy5hcHBlbmQoXCJzcGF3bi5hcmdzXCIsIChkYXRhKSA9PiB7XG4gICAgcmV0dXJuIGNvbmZpZy5wcmVmaXggPyBbY29uZmlnLnByZWZpeCwgLi4uZGF0YV0gOiBkYXRhO1xuICB9KTtcbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL2Vycm9yLWRldGVjdGlvbi5wbHVnaW4udHNcbmluaXRfZ2l0X2Vycm9yKCk7XG5mdW5jdGlvbiBpc1Rhc2tFcnJvcihyZXN1bHQpIHtcbiAgcmV0dXJuICEhKHJlc3VsdC5leGl0Q29kZSAmJiByZXN1bHQuc3RkRXJyLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UocmVzdWx0KSB7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFsuLi5yZXN1bHQuc3RkT3V0LCAuLi5yZXN1bHQuc3RkRXJyXSk7XG59XG5mdW5jdGlvbiBlcnJvckRldGVjdGlvbkhhbmRsZXIob3ZlcndyaXRlID0gZmFsc2UsIGlzRXJyb3IgPSBpc1Rhc2tFcnJvciwgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKSB7XG4gIHJldHVybiAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgIGlmICghb3ZlcndyaXRlICYmIGVycm9yIHx8ICFpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yTWVzc2FnZShyZXN1bHQpO1xuICB9O1xufVxuZnVuY3Rpb24gZXJyb3JEZXRlY3Rpb25QbHVnaW4oY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0YXNrLmVycm9yXCIsXG4gICAgYWN0aW9uKGRhdGEsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gY29uZmlnKGRhdGEuZXJyb3IsIHtcbiAgICAgICAgc3RkRXJyOiBjb250ZXh0LnN0ZEVycixcbiAgICAgICAgc3RkT3V0OiBjb250ZXh0LnN0ZE91dCxcbiAgICAgICAgZXhpdENvZGU6IGNvbnRleHQuZXhpdENvZGVcbiAgICAgIH0pO1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG5ldyBHaXRFcnJvcih2b2lkIDAsIGVycm9yLnRvU3RyaW5nKFwidXRmLThcIikpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy9wbHVnaW4tc3RvcmUudHNcbmluaXRfdXRpbHMoKTtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJub2RlOmV2ZW50c1wiO1xudmFyIFBsdWdpblN0b3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICB9XG4gIG9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudHMub24odHlwZSwgbGlzdGVuZXIpO1xuICB9XG4gIHJlY29uZmlndXJlKHR5cGUsIGRhdGEpIHtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KHR5cGUsIGRhdGEpO1xuICB9XG4gIGFwcGVuZCh0eXBlLCBhY3Rpb24pIHtcbiAgICBjb25zdCBwbHVnaW4gPSBhcHBlbmQodGhpcy5wbHVnaW5zLCB7IHR5cGUsIGFjdGlvbiB9KTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5wbHVnaW5zLmRlbGV0ZShwbHVnaW4pO1xuICB9XG4gIGFkZChwbHVnaW4pIHtcbiAgICBjb25zdCBwbHVnaW5zID0gW107XG4gICAgYXNBcnJheShwbHVnaW4pLmZvckVhY2goKHBsdWdpbjIpID0+IHBsdWdpbjIgJiYgdGhpcy5wbHVnaW5zLmFkZChhcHBlbmQocGx1Z2lucywgcGx1Z2luMikpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW4yKSA9PiB0aGlzLnBsdWdpbnMuZGVsZXRlKHBsdWdpbjIpKTtcbiAgICB9O1xuICB9XG4gIGV4ZWModHlwZSwgZGF0YSwgY29udGV4dCkge1xuICAgIGxldCBvdXRwdXQgPSBkYXRhO1xuICAgIGNvbnN0IGNvbnRleHR1YWwgPSBPYmplY3QuZnJlZXplKE9iamVjdC5jcmVhdGUoY29udGV4dCkpO1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgaWYgKHBsdWdpbi50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIG91dHB1dCA9IHBsdWdpbi5hY3Rpb24ob3V0cHV0LCBjb250ZXh0dWFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9wbHVnaW5zL3Byb2dyZXNzLW1vbml0b3ItcGx1Z2luLnRzXG5pbml0X3V0aWxzKCk7XG5mdW5jdGlvbiBwcm9ncmVzc01vbml0b3JQbHVnaW4ocHJvZ3Jlc3MpIHtcbiAgY29uc3QgcHJvZ3Jlc3NDb21tYW5kID0gXCItLXByb2dyZXNzXCI7XG4gIGNvbnN0IHByb2dyZXNzTWV0aG9kcyA9IFtcImNoZWNrb3V0XCIsIFwiY2xvbmVcIiwgXCJmZXRjaFwiLCBcInB1bGxcIiwgXCJwdXNoXCJdO1xuICBjb25zdCBvblByb2dyZXNzID0ge1xuICAgIHR5cGU6IFwic3Bhd24uYWZ0ZXJcIixcbiAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgIGlmICghY29udGV4dC5jb21tYW5kcy5pbmNsdWRlcyhwcm9ncmVzc0NvbW1hbmQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc3Bhd25lZC5zdGRlcnI/Lm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IC9eKFtcXHNcXFNdKz8pOlxccyooXFxkKyklIFxcKChcXGQrKVxcLyhcXGQrKVxcKS8uZXhlYyhjaHVuay50b1N0cmluZyhcInV0ZjhcIikpO1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvZ3Jlc3Moe1xuICAgICAgICAgIG1ldGhvZDogY29udGV4dC5tZXRob2QsXG4gICAgICAgICAgc3RhZ2U6IHByb2dyZXNzRXZlbnRTdGFnZShtZXNzYWdlWzFdKSxcbiAgICAgICAgICBwcm9ncmVzczogYXNOdW1iZXIobWVzc2FnZVsyXSksXG4gICAgICAgICAgcHJvY2Vzc2VkOiBhc051bWJlcihtZXNzYWdlWzNdKSxcbiAgICAgICAgICB0b3RhbDogYXNOdW1iZXIobWVzc2FnZVs0XSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9uQXJncyA9IHtcbiAgICB0eXBlOiBcInNwYXduLmFyZ3NcIixcbiAgICBhY3Rpb24oYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKCFwcm9ncmVzc01ldGhvZHMuaW5jbHVkZXMoY29udGV4dC5tZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluY2x1ZGluZyhhcmdzLCBwcm9ncmVzc0NvbW1hbmQpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtvbkFyZ3MsIG9uUHJvZ3Jlc3NdO1xufVxuZnVuY3Rpb24gcHJvZ3Jlc3NFdmVudFN0YWdlKGlucHV0KSB7XG4gIHJldHVybiBTdHJpbmcoaW5wdXQudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIiwgMSkpIHx8IFwidW5rbm93blwiO1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvc3Bhd24tb3B0aW9ucy1wbHVnaW4udHNcbmluaXRfdXRpbHMoKTtcbmZ1bmN0aW9uIHNwYXduT3B0aW9uc1BsdWdpbihzcGF3bk9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHBpY2soc3Bhd25PcHRpb25zLCBbXCJ1aWRcIiwgXCJnaWRcIl0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3Bhd24ub3B0aW9uc1wiLFxuICAgIGFjdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4geyAuLi5vcHRpb25zLCAuLi5kYXRhIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvdGltb3V0LXBsdWdpbi50c1xuZnVuY3Rpb24gdGltZW91dFBsdWdpbih7XG4gIGJsb2NrLFxuICBzdGRFcnIgPSB0cnVlLFxuICBzdGRPdXQgPSB0cnVlXG59KSB7XG4gIGlmIChibG9jayA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzcGF3bi5hZnRlclwiLFxuICAgICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCB0aW1lb3V0O1xuICAgICAgICBmdW5jdGlvbiB3YWl0KCkge1xuICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGtpbGwsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5zdGRvdXQ/Lm9mZihcImRhdGFcIiwgd2FpdCk7XG4gICAgICAgICAgY29udGV4dC5zcGF3bmVkLnN0ZGVycj8ub2ZmKFwiZGF0YVwiLCB3YWl0KTtcbiAgICAgICAgICBjb250ZXh0LnNwYXduZWQub2ZmKFwiZXhpdFwiLCBzdG9wKTtcbiAgICAgICAgICBjb250ZXh0LnNwYXduZWQub2ZmKFwiY2xvc2VcIiwgc3RvcCk7XG4gICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgY29udGV4dC5raWxsKG5ldyBHaXRQbHVnaW5FcnJvcih2b2lkIDAsIFwidGltZW91dFwiLCBgYmxvY2sgdGltZW91dCByZWFjaGVkYCkpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZE91dCAmJiBjb250ZXh0LnNwYXduZWQuc3Rkb3V0Py5vbihcImRhdGFcIiwgd2FpdCk7XG4gICAgICAgIHN0ZEVyciAmJiBjb250ZXh0LnNwYXduZWQuc3RkZXJyPy5vbihcImRhdGFcIiwgd2FpdCk7XG4gICAgICAgIGNvbnRleHQuc3Bhd25lZC5vbihcImV4aXRcIiwgc3RvcCk7XG4gICAgICAgIGNvbnRleHQuc3Bhd25lZC5vbihcImNsb3NlXCIsIHN0b3ApO1xuICAgICAgICB3YWl0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvc3VmZml4LXBhdGhzLnBsdWdpbi50c1xuaW5pdF9wYXRoc3BlYygpO1xuZnVuY3Rpb24gc3VmZml4UGF0aHNQbHVnaW4oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzcGF3bi5hcmdzXCIsXG4gICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IFtdO1xuICAgICAgbGV0IHN1ZmZpeDtcbiAgICAgIGZ1bmN0aW9uIGFwcGVuZDIoYXJncykge1xuICAgICAgICAoc3VmZml4ID0gc3VmZml4IHx8IFtdKS5wdXNoKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gZGF0YVtpXTtcbiAgICAgICAgaWYgKGlzUGF0aFNwZWMocGFyYW0pKSB7XG4gICAgICAgICAgYXBwZW5kMih0b1BhdGhzKHBhcmFtKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtID09PSBcIi0tXCIpIHtcbiAgICAgICAgICBhcHBlbmQyKFxuICAgICAgICAgICAgZGF0YS5zbGljZShpICsgMSkuZmxhdE1hcCgoaXRlbSkgPT4gaXNQYXRoU3BlYyhpdGVtKSAmJiB0b1BhdGhzKGl0ZW0pIHx8IGl0ZW0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmVmaXgucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gIXN1ZmZpeCA/IHByZWZpeCA6IFsuLi5wcmVmaXgsIFwiLS1cIiwgLi4uc3VmZml4Lm1hcChTdHJpbmcpXTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZ2l0LWZhY3RvcnkudHNcbmluaXRfdXRpbHMoKTtcbnZhciBHaXQgPSByZXF1aXJlX2dpdCgpO1xuZnVuY3Rpb24gZ2l0SW5zdGFuY2VGYWN0b3J5KGJhc2VEaXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGx1Z2lucyA9IG5ldyBQbHVnaW5TdG9yZSgpO1xuICBjb25zdCBjb25maWcgPSBjcmVhdGVJbnN0YW5jZUNvbmZpZyhcbiAgICBiYXNlRGlyICYmICh0eXBlb2YgYmFzZURpciA9PT0gXCJzdHJpbmdcIiA/IHsgYmFzZURpciB9IDogYmFzZURpcikgfHwge30sXG4gICAgb3B0aW9uc1xuICApO1xuICBpZiAoIWZvbGRlckV4aXN0cyhjb25maWcuYmFzZURpcikpIHtcbiAgICB0aHJvdyBuZXcgR2l0Q29uc3RydWN0RXJyb3IoXG4gICAgICBjb25maWcsXG4gICAgICBgQ2Fubm90IHVzZSBzaW1wbGUtZ2l0IG9uIGEgZGlyZWN0b3J5IHRoYXQgZG9lcyBub3QgZXhpc3RgXG4gICAgKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcuY29uZmlnKSkge1xuICAgIHBsdWdpbnMuYWRkKGNvbW1hbmRDb25maWdQcmVmaXhpbmdQbHVnaW4oY29uZmlnLmNvbmZpZykpO1xuICB9XG4gIHBsdWdpbnMuYWRkKGJsb2NrVW5zYWZlT3BlcmF0aW9uc1BsdWdpbihjb25maWcudW5zYWZlKSk7XG4gIHBsdWdpbnMuYWRkKHN1ZmZpeFBhdGhzUGx1Z2luKCkpO1xuICBwbHVnaW5zLmFkZChjb21wbGV0aW9uRGV0ZWN0aW9uUGx1Z2luKGNvbmZpZy5jb21wbGV0aW9uKSk7XG4gIGNvbmZpZy5hYm9ydCAmJiBwbHVnaW5zLmFkZChhYm9ydFBsdWdpbihjb25maWcuYWJvcnQpKTtcbiAgY29uZmlnLnByb2dyZXNzICYmIHBsdWdpbnMuYWRkKHByb2dyZXNzTW9uaXRvclBsdWdpbihjb25maWcucHJvZ3Jlc3MpKTtcbiAgY29uZmlnLnRpbWVvdXQgJiYgcGx1Z2lucy5hZGQodGltZW91dFBsdWdpbihjb25maWcudGltZW91dCkpO1xuICBjb25maWcuc3Bhd25PcHRpb25zICYmIHBsdWdpbnMuYWRkKHNwYXduT3B0aW9uc1BsdWdpbihjb25maWcuc3Bhd25PcHRpb25zKSk7XG4gIHBsdWdpbnMuYWRkKGVycm9yRGV0ZWN0aW9uUGx1Z2luKGVycm9yRGV0ZWN0aW9uSGFuZGxlcih0cnVlKSkpO1xuICBjb25maWcuZXJyb3JzICYmIHBsdWdpbnMuYWRkKGVycm9yRGV0ZWN0aW9uUGx1Z2luKGNvbmZpZy5lcnJvcnMpKTtcbiAgY3VzdG9tQmluYXJ5UGx1Z2luKHBsdWdpbnMsIGNvbmZpZy5iaW5hcnksIGNvbmZpZy51bnNhZmU/LmFsbG93VW5zYWZlQ3VzdG9tQmluYXJ5KTtcbiAgcmV0dXJuIG5ldyBHaXQoY29uZmlnLCBwbHVnaW5zKTtcbn1cblxuLy8gc3JjL2xpYi9ydW5uZXJzL3Byb21pc2Utd3JhcHBlZC50c1xuaW5pdF9naXRfcmVzcG9uc2VfZXJyb3IoKTtcbnZhciBmdW5jdGlvbk5hbWVzQnVpbGRlckFwaSA9IFtcImN1c3RvbUJpbmFyeVwiLCBcImVudlwiLCBcIm91dHB1dEhhbmRsZXJcIiwgXCJzaWxlbnRcIl07XG52YXIgZnVuY3Rpb25OYW1lc1Byb21pc2VBcGkgPSBbXG4gIFwiYWRkXCIsXG4gIFwiYWRkQW5ub3RhdGVkVGFnXCIsXG4gIFwiYWRkQ29uZmlnXCIsXG4gIFwiYWRkUmVtb3RlXCIsXG4gIFwiYWRkVGFnXCIsXG4gIFwiYXBwbHlQYXRjaFwiLFxuICBcImJpbmFyeUNhdEZpbGVcIixcbiAgXCJicmFuY2hcIixcbiAgXCJicmFuY2hMb2NhbFwiLFxuICBcImNhdEZpbGVcIixcbiAgXCJjaGVja0lnbm9yZVwiLFxuICBcImNoZWNrSXNSZXBvXCIsXG4gIFwiY2hlY2tvdXRcIixcbiAgXCJjaGVja291dEJyYW5jaFwiLFxuICBcImNoZWNrb3V0TGF0ZXN0VGFnXCIsXG4gIFwiY2hlY2tvdXRMb2NhbEJyYW5jaFwiLFxuICBcImNsZWFuXCIsXG4gIFwiY2xvbmVcIixcbiAgXCJjb21taXRcIixcbiAgXCJjd2RcIixcbiAgXCJkZWxldGVMb2NhbEJyYW5jaFwiLFxuICBcImRlbGV0ZUxvY2FsQnJhbmNoZXNcIixcbiAgXCJkaWZmXCIsXG4gIFwiZGlmZlN1bW1hcnlcIixcbiAgXCJleGVjXCIsXG4gIFwiZmV0Y2hcIixcbiAgXCJnZXRSZW1vdGVzXCIsXG4gIFwiaW5pdFwiLFxuICBcImxpc3RDb25maWdcIixcbiAgXCJsaXN0UmVtb3RlXCIsXG4gIFwibG9nXCIsXG4gIFwibWVyZ2VcIixcbiAgXCJtZXJnZUZyb21Ub1wiLFxuICBcIm1pcnJvclwiLFxuICBcIm12XCIsXG4gIFwicHVsbFwiLFxuICBcInB1c2hcIixcbiAgXCJwdXNoVGFnc1wiLFxuICBcInJhd1wiLFxuICBcInJlYmFzZVwiLFxuICBcInJlbW90ZVwiLFxuICBcInJlbW92ZVJlbW90ZVwiLFxuICBcInJlc2V0XCIsXG4gIFwicmV2ZXJ0XCIsXG4gIFwicmV2cGFyc2VcIixcbiAgXCJybVwiLFxuICBcInJtS2VlcExvY2FsXCIsXG4gIFwic2hvd1wiLFxuICBcInN0YXNoXCIsXG4gIFwic3Rhc2hMaXN0XCIsXG4gIFwic3RhdHVzXCIsXG4gIFwic3ViTW9kdWxlXCIsXG4gIFwic3VibW9kdWxlQWRkXCIsXG4gIFwic3VibW9kdWxlSW5pdFwiLFxuICBcInN1Ym1vZHVsZVVwZGF0ZVwiLFxuICBcInRhZ1wiLFxuICBcInRhZ3NcIixcbiAgXCJ1cGRhdGVTZXJ2ZXJJbmZvXCJcbl07XG5mdW5jdGlvbiBnaXRQKC4uLmFyZ3MpIHtcbiAgbGV0IGdpdDtcbiAgbGV0IGNoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRyeSB7XG4gICAgZ2l0ID0gZ2l0SW5zdGFuY2VGYWN0b3J5KC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2hhaW4gPSBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZGVyUmV0dXJuKCkge1xuICAgIHJldHVybiBwcm9taXNlQXBpO1xuICB9XG4gIGZ1bmN0aW9uIGNoYWluUmV0dXJuKCkge1xuICAgIHJldHVybiBjaGFpbjtcbiAgfVxuICBjb25zdCBwcm9taXNlQXBpID0gWy4uLmZ1bmN0aW9uTmFtZXNCdWlsZGVyQXBpLCAuLi5mdW5jdGlvbk5hbWVzUHJvbWlzZUFwaV0ucmVkdWNlKFxuICAgIChhcGksIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGlzQXN5bmMgPSBmdW5jdGlvbk5hbWVzUHJvbWlzZUFwaS5pbmNsdWRlcyhuYW1lKTtcbiAgICAgIGNvbnN0IHZhbGlkID0gaXNBc3luYyA/IGFzeW5jV3JhcHBlcihuYW1lLCBnaXQpIDogc3luY1dyYXBwZXIobmFtZSwgZ2l0LCBhcGkpO1xuICAgICAgY29uc3QgYWx0ZXJuYXRpdmUgPSBpc0FzeW5jID8gY2hhaW5SZXR1cm4gOiBidWlsZGVyUmV0dXJuO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaSwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGdpdCA/IHZhbGlkIDogYWx0ZXJuYXRpdmVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFwaTtcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiBwcm9taXNlQXBpO1xuICBmdW5jdGlvbiBhc3luY1dyYXBwZXIoZm4sIGdpdDIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczIpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnczJbYXJnczIubGVuZ3RoXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJQcm9taXNlIGludGVyZmFjZSByZXF1aXJlcyB0aGF0IGhhbmRsZXJzIGFyZSBub3Qgc3VwcGxpZWQgaW5saW5lLCB0cmFpbGluZyBmdW5jdGlvbiBub3QgYWxsb3dlZCBpbiBjYWxsIHRvIFwiICsgZm5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFpbi50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCh0b0Vycm9yKGVycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgYXJnczIucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgZ2l0Mltmbl0uYXBwbHkoZ2l0MiwgYXJnczIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3luY1dyYXBwZXIoZm4sIGdpdDIsIGFwaSkge1xuICAgIHJldHVybiAoLi4uYXJnczIpID0+IHtcbiAgICAgIGdpdDJbZm5dKC4uLmFyZ3MyKTtcbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gdG9FcnJvcihlcnJvcikge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihlcnJvcik7XG4gIH1cbiAgcmV0dXJuIG5ldyBHaXRSZXNwb25zZUVycm9yKGVycm9yKTtcbn1cblxuLy8gc3JjL2VzbS5tanNcbnZhciBzaW1wbGVHaXQgPSBnaXRJbnN0YW5jZUZhY3Rvcnk7XG52YXIgZXNtX2RlZmF1bHQgPSBnaXRJbnN0YW5jZUZhY3Rvcnk7XG5leHBvcnQge1xuICBDaGVja1JlcG9BY3Rpb25zLFxuICBDbGVhbk9wdGlvbnMsXG4gIERpZmZOYW1lU3RhdHVzLFxuICBHaXRDb25maWdTY29wZSxcbiAgR2l0Q29uc3RydWN0RXJyb3IsXG4gIEdpdEVycm9yLFxuICBHaXRQbHVnaW5FcnJvcixcbiAgR2l0UmVzcG9uc2VFcnJvcixcbiAgUmVzZXRNb2RlLFxuICBUYXNrQ29uZmlndXJhdGlvbkVycm9yLFxuICBlc21fZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBnaXRQLFxuICBncmVwUXVlcnlCdWlsZGVyLFxuICBwYXRoc3BlYyxcbiAgc2ltcGxlR2l0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/simple-git/dist/esm/index.js\n");

/***/ })

};
;